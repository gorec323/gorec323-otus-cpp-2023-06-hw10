<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bulk_server: Шаблон класса asio::ssl::stream&lt; Stream &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bulk_server
   &#160;<span id="projectnumber">0.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceasio.html">asio</a></li><li class="navelem"><a class="el" href="namespaceasio_1_1ssl.html">ssl</a></li><li class="navelem"><a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Классы</a> &#124;
<a href="#pub-types">Открытые типы</a> &#124;
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="classasio_1_1ssl_1_1stream-members.html">Полный список членов класса</a>  </div>
  <div class="headertitle">
<div class="title">Шаблон класса asio::ssl::stream&lt; Stream &gt;</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides stream-oriented functionality using SSL.  
 <a href="classasio_1_1ssl_1_1stream.html#details">Подробнее...</a></p>

<p><code>#include &lt;<a class="el" href="stream_8hpp_source.html">stream.hpp</a>&gt;</code></p>
<div class="dynheader">
Граф наследования:asio::ssl::stream&lt; Stream &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classasio_1_1ssl_1_1stream__inherit__graph.png" border="0" usemap="#aasio_1_1ssl_1_1stream_3_01Stream_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aasio_1_1ssl_1_1stream_3_01Stream_01_4_inherit__map" id="aasio_1_1ssl_1_1stream_3_01Stream_01_4_inherit__map">
<area shape="rect" title="Provides stream&#45;oriented functionality using SSL." alt="" coords="119,80,259,121"/>
<area shape="rect" href="classasio_1_1ssl_1_1stream__base.html" title=" " alt="" coords="5,5,172,32"/>
<area shape="rect" href="classasio_1_1detail_1_1noncopyable.html" title=" " alt="" coords="196,5,381,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">см. легенду</a>]</span></center></div>
<div class="dynheader">
Граф связей класса asio::ssl::stream&lt; Stream &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classasio_1_1ssl_1_1stream__coll__graph.png" border="0" usemap="#aasio_1_1ssl_1_1stream_3_01Stream_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aasio_1_1ssl_1_1stream_3_01Stream_01_4_coll__map" id="aasio_1_1ssl_1_1stream_3_01Stream_01_4_coll__map">
<area shape="rect" title="Provides stream&#45;oriented functionality using SSL." alt="" coords="119,80,259,121"/>
<area shape="rect" href="classasio_1_1ssl_1_1stream__base.html" title=" " alt="" coords="5,5,172,32"/>
<area shape="rect" href="classasio_1_1detail_1_1noncopyable.html" title=" " alt="" coords="196,5,381,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">см. легенду</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Классы</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1ssl_1_1stream_1_1impl__struct.html">impl_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for use with deprecated impl_type.  <a href="structasio_1_1ssl_1_1stream_1_1impl__struct.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Открытые типы</h2></td></tr>
<tr class="memitem:ad10bd7f631ed0704388d4dd90b5f3342"><td class="memItemLeft" align="right" valign="top">typedef SSL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ad10bd7f631ed0704388d4dd90b5f3342">native_handle_type</a></td></tr>
<tr class="memdesc:ad10bd7f631ed0704388d4dd90b5f3342"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native handle type of the SSL stream.  <a href="classasio_1_1ssl_1_1stream.html#ad10bd7f631ed0704388d4dd90b5f3342">Подробнее...</a><br /></td></tr>
<tr class="separator:ad10bd7f631ed0704388d4dd90b5f3342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0d98307a114d63f9a69db33eaa177d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a>&lt; Stream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#aec0d98307a114d63f9a69db33eaa177d">next_layer_type</a></td></tr>
<tr class="memdesc:aec0d98307a114d63f9a69db33eaa177d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the next layer.  <a href="classasio_1_1ssl_1_1stream.html#aec0d98307a114d63f9a69db33eaa177d">Подробнее...</a><br /></td></tr>
<tr class="separator:aec0d98307a114d63f9a69db33eaa177d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3642d059991c8d0285b888673c677ca"><td class="memItemLeft" align="right" valign="top">typedef next_layer_type::lowest_layer_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ae3642d059991c8d0285b888673c677ca">lowest_layer_type</a></td></tr>
<tr class="memdesc:ae3642d059991c8d0285b888673c677ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the lowest layer.  <a href="classasio_1_1ssl_1_1stream.html#ae3642d059991c8d0285b888673c677ca">Подробнее...</a><br /></td></tr>
<tr class="separator:ae3642d059991c8d0285b888673c677ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca16e85f03c2ac2adb1851ac09adc8f6"><td class="memItemLeft" align="right" valign="top">typedef lowest_layer_type::executor_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a></td></tr>
<tr class="memdesc:aca16e85f03c2ac2adb1851ac09adc8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object.  <a href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">Подробнее...</a><br /></td></tr>
<tr class="separator:aca16e85f03c2ac2adb1851ac09adc8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classasio_1_1ssl_1_1stream__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classasio_1_1ssl_1_1stream__base')"><img src="closed.png" alt="-"/>&#160;Открытые типы унаследованные от <a class="el" href="classasio_1_1ssl_1_1stream__base.html">asio::ssl::stream_base</a></td></tr>
<tr class="memitem:a2f18813d3860bc8aee99249834d7c320 inherit pub_types_classasio_1_1ssl_1_1stream__base"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> { <a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320a68134fb041cb11ffe46e248ed1e1d73f">client</a>
, <a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320a2f9bac13b8adb5945e7436945061d090">server</a>
 }</td></tr>
<tr class="memdesc:a2f18813d3860bc8aee99249834d7c320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different handshake types.  <a href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">Подробнее...</a><br /></td></tr>
<tr class="separator:a2f18813d3860bc8aee99249834d7c320 inherit pub_types_classasio_1_1ssl_1_1stream__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr class="memitem:aba9228655482c6878c31c798af446cb5"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:aba9228655482c6878c31c798af446cb5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#aba9228655482c6878c31c798af446cb5">stream</a> (Arg &amp;&amp;arg, <a class="el" href="classasio_1_1ssl_1_1context.html">context</a> &amp;ctx)</td></tr>
<tr class="memdesc:aba9228655482c6878c31c798af446cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a stream.  <a href="classasio_1_1ssl_1_1stream.html#aba9228655482c6878c31c798af446cb5">Подробнее...</a><br /></td></tr>
<tr class="separator:aba9228655482c6878c31c798af446cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b3a01958d30b7c1ac21f5dfec8f809"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:aa6b3a01958d30b7c1ac21f5dfec8f809"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#aa6b3a01958d30b7c1ac21f5dfec8f809">stream</a> (Arg &amp;&amp;arg, <a class="el" href="classasio_1_1ssl_1_1stream.html#ad10bd7f631ed0704388d4dd90b5f3342">native_handle_type</a> handle)</td></tr>
<tr class="memdesc:aa6b3a01958d30b7c1ac21f5dfec8f809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a stream from an existing native implementation.  <a href="classasio_1_1ssl_1_1stream.html#aa6b3a01958d30b7c1ac21f5dfec8f809">Подробнее...</a><br /></td></tr>
<tr class="separator:aa6b3a01958d30b7c1ac21f5dfec8f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f5839fba525c1afd96dec0727ef3a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a47f5839fba525c1afd96dec0727ef3a5">stream</a> (<a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a47f5839fba525c1afd96dec0727ef3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct a stream from another.  <a href="classasio_1_1ssl_1_1stream.html#a47f5839fba525c1afd96dec0727ef3a5">Подробнее...</a><br /></td></tr>
<tr class="separator:a47f5839fba525c1afd96dec0727ef3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034b4d51af48e64b5019a2373114f55c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a034b4d51af48e64b5019a2373114f55c">operator=</a> (<a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a034b4d51af48e64b5019a2373114f55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign a stream from another.  <a href="classasio_1_1ssl_1_1stream.html#a034b4d51af48e64b5019a2373114f55c">Подробнее...</a><br /></td></tr>
<tr class="separator:a034b4d51af48e64b5019a2373114f55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cbc4691960a13f26b19fb7dec1e195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a51cbc4691960a13f26b19fb7dec1e195">~stream</a> ()</td></tr>
<tr class="memdesc:a51cbc4691960a13f26b19fb7dec1e195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classasio_1_1ssl_1_1stream.html#a51cbc4691960a13f26b19fb7dec1e195">Подробнее...</a><br /></td></tr>
<tr class="separator:a51cbc4691960a13f26b19fb7dec1e195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c2cc94b807608b54ea4e3908acadf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a614c2cc94b807608b54ea4e3908acadf">get_executor</a> () noexcept</td></tr>
<tr class="memdesc:a614c2cc94b807608b54ea4e3908acadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor associated with the object.  <a href="classasio_1_1ssl_1_1stream.html#a614c2cc94b807608b54ea4e3908acadf">Подробнее...</a><br /></td></tr>
<tr class="separator:a614c2cc94b807608b54ea4e3908acadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08506517747d6f5b2174f0f35dd49fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ssl_1_1stream.html#ad10bd7f631ed0704388d4dd90b5f3342">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a08506517747d6f5b2174f0f35dd49fa9">native_handle</a> ()</td></tr>
<tr class="memdesc:a08506517747d6f5b2174f0f35dd49fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying implementation in the native type.  <a href="classasio_1_1ssl_1_1stream.html#a08506517747d6f5b2174f0f35dd49fa9">Подробнее...</a><br /></td></tr>
<tr class="separator:a08506517747d6f5b2174f0f35dd49fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbad8acb17df77ee6cb08f1eaacf376"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1ssl_1_1stream.html#aec0d98307a114d63f9a69db33eaa177d">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a6bbad8acb17df77ee6cb08f1eaacf376">next_layer</a> () const</td></tr>
<tr class="memdesc:a6bbad8acb17df77ee6cb08f1eaacf376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the next layer.  <a href="classasio_1_1ssl_1_1stream.html#a6bbad8acb17df77ee6cb08f1eaacf376">Подробнее...</a><br /></td></tr>
<tr class="separator:a6bbad8acb17df77ee6cb08f1eaacf376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae923c2a65c0f6fec01a335384f752d12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ssl_1_1stream.html#aec0d98307a114d63f9a69db33eaa177d">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ae923c2a65c0f6fec01a335384f752d12">next_layer</a> ()</td></tr>
<tr class="memdesc:ae923c2a65c0f6fec01a335384f752d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the next layer.  <a href="classasio_1_1ssl_1_1stream.html#ae923c2a65c0f6fec01a335384f752d12">Подробнее...</a><br /></td></tr>
<tr class="separator:ae923c2a65c0f6fec01a335384f752d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaab4ba6e92ef6b2009d103bb71bfdef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ssl_1_1stream.html#ae3642d059991c8d0285b888673c677ca">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#adaab4ba6e92ef6b2009d103bb71bfdef">lowest_layer</a> ()</td></tr>
<tr class="memdesc:adaab4ba6e92ef6b2009d103bb71bfdef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="classasio_1_1ssl_1_1stream.html#adaab4ba6e92ef6b2009d103bb71bfdef">Подробнее...</a><br /></td></tr>
<tr class="separator:adaab4ba6e92ef6b2009d103bb71bfdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266ccbc89d82d9384ceb6148c9bd13bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1ssl_1_1stream.html#ae3642d059991c8d0285b888673c677ca">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a266ccbc89d82d9384ceb6148c9bd13bf">lowest_layer</a> () const</td></tr>
<tr class="memdesc:a266ccbc89d82d9384ceb6148c9bd13bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="classasio_1_1ssl_1_1stream.html#a266ccbc89d82d9384ceb6148c9bd13bf">Подробнее...</a><br /></td></tr>
<tr class="separator:a266ccbc89d82d9384ceb6148c9bd13bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99e1eb0409e05c3439d478229bf0a0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#aa99e1eb0409e05c3439d478229bf0a0c">set_verify_mode</a> (<a class="el" href="namespaceasio_1_1ssl.html#aa6497e51bc608f2397a731a14f80b563">verify_mode</a> v)</td></tr>
<tr class="memdesc:aa99e1eb0409e05c3439d478229bf0a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the peer verification mode.  <a href="classasio_1_1ssl_1_1stream.html#aa99e1eb0409e05c3439d478229bf0a0c">Подробнее...</a><br /></td></tr>
<tr class="separator:aa99e1eb0409e05c3439d478229bf0a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e6ad5f06dd90b8dbe85f479a010239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ad7e6ad5f06dd90b8dbe85f479a010239">set_verify_mode</a> (<a class="el" href="namespaceasio_1_1ssl.html#aa6497e51bc608f2397a731a14f80b563">verify_mode</a> v, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ad7e6ad5f06dd90b8dbe85f479a010239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the peer verification mode.  <a href="classasio_1_1ssl_1_1stream.html#ad7e6ad5f06dd90b8dbe85f479a010239">Подробнее...</a><br /></td></tr>
<tr class="separator:ad7e6ad5f06dd90b8dbe85f479a010239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb5030ca05dee079ded85891da9a7de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a9eb5030ca05dee079ded85891da9a7de">set_verify_depth</a> (int depth)</td></tr>
<tr class="memdesc:a9eb5030ca05dee079ded85891da9a7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the peer verification depth.  <a href="classasio_1_1ssl_1_1stream.html#a9eb5030ca05dee079ded85891da9a7de">Подробнее...</a><br /></td></tr>
<tr class="separator:a9eb5030ca05dee079ded85891da9a7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bc41e2879105d57143910d80fd35e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a71bc41e2879105d57143910d80fd35e2">set_verify_depth</a> (int depth, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a71bc41e2879105d57143910d80fd35e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the peer verification depth.  <a href="classasio_1_1ssl_1_1stream.html#a71bc41e2879105d57143910d80fd35e2">Подробнее...</a><br /></td></tr>
<tr class="separator:a71bc41e2879105d57143910d80fd35e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fbf34c4cd1386754e8395b8e2ce65e"><td class="memTemplParams" colspan="2">template&lt;typename VerifyCallback &gt; </td></tr>
<tr class="memitem:ae3fbf34c4cd1386754e8395b8e2ce65e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ae3fbf34c4cd1386754e8395b8e2ce65e">set_verify_callback</a> (VerifyCallback callback)</td></tr>
<tr class="memdesc:ae3fbf34c4cd1386754e8395b8e2ce65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback used to verify peer certificates.  <a href="classasio_1_1ssl_1_1stream.html#ae3fbf34c4cd1386754e8395b8e2ce65e">Подробнее...</a><br /></td></tr>
<tr class="separator:ae3fbf34c4cd1386754e8395b8e2ce65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8d40bc7c1ffc28372b085a3f1edf2"><td class="memTemplParams" colspan="2">template&lt;typename VerifyCallback &gt; </td></tr>
<tr class="memitem:a4ec8d40bc7c1ffc28372b085a3f1edf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a4ec8d40bc7c1ffc28372b085a3f1edf2">set_verify_callback</a> (VerifyCallback callback, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a4ec8d40bc7c1ffc28372b085a3f1edf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback used to verify peer certificates.  <a href="classasio_1_1ssl_1_1stream.html#a4ec8d40bc7c1ffc28372b085a3f1edf2">Подробнее...</a><br /></td></tr>
<tr class="separator:a4ec8d40bc7c1ffc28372b085a3f1edf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab033983103661135df087954a0a104a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ab033983103661135df087954a0a104a4">handshake</a> (<a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> type)</td></tr>
<tr class="memdesc:ab033983103661135df087954a0a104a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SSL handshaking.  <a href="classasio_1_1ssl_1_1stream.html#ab033983103661135df087954a0a104a4">Подробнее...</a><br /></td></tr>
<tr class="separator:ab033983103661135df087954a0a104a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53d0718b8940993a96edbfcbe0abf92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#aa53d0718b8940993a96edbfcbe0abf92">handshake</a> (<a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> type, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aa53d0718b8940993a96edbfcbe0abf92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SSL handshaking.  <a href="classasio_1_1ssl_1_1stream.html#aa53d0718b8940993a96edbfcbe0abf92">Подробнее...</a><br /></td></tr>
<tr class="separator:aa53d0718b8940993a96edbfcbe0abf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae576e595f41b72459ded95b88cd870c8"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ae576e595f41b72459ded95b88cd870c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ae576e595f41b72459ded95b88cd870c8">handshake</a> (<a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> type, const ConstBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:ae576e595f41b72459ded95b88cd870c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SSL handshaking.  <a href="classasio_1_1ssl_1_1stream.html#ae576e595f41b72459ded95b88cd870c8">Подробнее...</a><br /></td></tr>
<tr class="separator:ae576e595f41b72459ded95b88cd870c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460cf902049df2a6c9d3b8731aad9532"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a460cf902049df2a6c9d3b8731aad9532"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a460cf902049df2a6c9d3b8731aad9532">handshake</a> (<a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> type, const ConstBufferSequence &amp;buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a460cf902049df2a6c9d3b8731aad9532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SSL handshaking.  <a href="classasio_1_1ssl_1_1stream.html#a460cf902049df2a6c9d3b8731aad9532">Подробнее...</a><br /></td></tr>
<tr class="separator:a460cf902049df2a6c9d3b8731aad9532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af524e1639657b7ca700aa769c0443a1f"><td class="memTemplParams" colspan="2">template&lt;HandshakeToken  = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:af524e1639657b7ca700aa769c0443a1f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#af524e1639657b7ca700aa769c0443a1f">async_handshake</a> (<a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> type, HandshakeToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; <a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a> &gt;()) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; HandshakeToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>)&gt;(declval&lt; initiate_async_handshake &gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, type))</td></tr>
<tr class="memdesc:af524e1639657b7ca700aa769c0443a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous SSL handshake.  <a href="classasio_1_1ssl_1_1stream.html#af524e1639657b7ca700aa769c0443a1f">Подробнее...</a><br /></td></tr>
<tr class="separator:af524e1639657b7ca700aa769c0443a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e105dcbe6fe8a26faa17752942c831"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) BufferedHandshakeToken = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a54e105dcbe6fe8a26faa17752942c831"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a54e105dcbe6fe8a26faa17752942c831">async_handshake</a> (<a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> type, const ConstBufferSequence &amp;buffers, BufferedHandshakeToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; <a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a> &gt;()) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; BufferedHandshakeToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; initiate_async_buffered_handshake &gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, type, buffers))</td></tr>
<tr class="memdesc:a54e105dcbe6fe8a26faa17752942c831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous SSL handshake.  <a href="classasio_1_1ssl_1_1stream.html#a54e105dcbe6fe8a26faa17752942c831">Подробнее...</a><br /></td></tr>
<tr class="separator:a54e105dcbe6fe8a26faa17752942c831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5738d2511541cdee020d4b6a24d2df4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a5738d2511541cdee020d4b6a24d2df4f">shutdown</a> ()</td></tr>
<tr class="memdesc:a5738d2511541cdee020d4b6a24d2df4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down SSL on the stream.  <a href="classasio_1_1ssl_1_1stream.html#a5738d2511541cdee020d4b6a24d2df4f">Подробнее...</a><br /></td></tr>
<tr class="separator:a5738d2511541cdee020d4b6a24d2df4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced61ce3e50c0588680538ff06c1199d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#aced61ce3e50c0588680538ff06c1199d">shutdown</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aced61ce3e50c0588680538ff06c1199d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down SSL on the stream.  <a href="classasio_1_1ssl_1_1stream.html#aced61ce3e50c0588680538ff06c1199d">Подробнее...</a><br /></td></tr>
<tr class="separator:aced61ce3e50c0588680538ff06c1199d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41783b8c9fc87726c44bee65498b4bc"><td class="memTemplParams" colspan="2">template&lt;ShutdownToken  = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:ad41783b8c9fc87726c44bee65498b4bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ad41783b8c9fc87726c44bee65498b4bc">async_shutdown</a> (ShutdownToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; <a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a> &gt;()) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ShutdownToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>)&gt;(declval&lt; initiate_async_shutdown &gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:ad41783b8c9fc87726c44bee65498b4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously shut down SSL on the stream.  <a href="classasio_1_1ssl_1_1stream.html#ad41783b8c9fc87726c44bee65498b4bc">Подробнее...</a><br /></td></tr>
<tr class="separator:ad41783b8c9fc87726c44bee65498b4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12478afb2ddb7d73b9eb91f523fc5df"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ab12478afb2ddb7d73b9eb91f523fc5df"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ab12478afb2ddb7d73b9eb91f523fc5df">write_some</a> (const ConstBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:ab12478afb2ddb7d73b9eb91f523fc5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some data to the stream.  <a href="classasio_1_1ssl_1_1stream.html#ab12478afb2ddb7d73b9eb91f523fc5df">Подробнее...</a><br /></td></tr>
<tr class="separator:ab12478afb2ddb7d73b9eb91f523fc5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7079c181a877bd4450d118a63999d83"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ab7079c181a877bd4450d118a63999d83"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ab7079c181a877bd4450d118a63999d83">write_some</a> (const ConstBufferSequence &amp;buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ab7079c181a877bd4450d118a63999d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some data to the stream.  <a href="classasio_1_1ssl_1_1stream.html#ab7079c181a877bd4450d118a63999d83">Подробнее...</a><br /></td></tr>
<tr class="separator:ab7079c181a877bd4450d118a63999d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2dbfa851f9f9cecc4ed805bfe3a86c"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a9e2dbfa851f9f9cecc4ed805bfe3a86c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a9e2dbfa851f9f9cecc4ed805bfe3a86c">async_write_some</a> (const ConstBufferSequence &amp;buffers, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; <a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a> &gt;()) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; initiate_async_write_some &gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers))</td></tr>
<tr class="memdesc:a9e2dbfa851f9f9cecc4ed805bfe3a86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous write.  <a href="classasio_1_1ssl_1_1stream.html#a9e2dbfa851f9f9cecc4ed805bfe3a86c">Подробнее...</a><br /></td></tr>
<tr class="separator:a9e2dbfa851f9f9cecc4ed805bfe3a86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c216bb02d351b2f94d96aa60a056ea"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ac0c216bb02d351b2f94d96aa60a056ea"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ac0c216bb02d351b2f94d96aa60a056ea">read_some</a> (const MutableBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:ac0c216bb02d351b2f94d96aa60a056ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data from the stream.  <a href="classasio_1_1ssl_1_1stream.html#ac0c216bb02d351b2f94d96aa60a056ea">Подробнее...</a><br /></td></tr>
<tr class="separator:ac0c216bb02d351b2f94d96aa60a056ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5419b179aba75341cc72d6be84b99d0"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ad5419b179aba75341cc72d6be84b99d0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#ad5419b179aba75341cc72d6be84b99d0">read_some</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ad5419b179aba75341cc72d6be84b99d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data from the stream.  <a href="classasio_1_1ssl_1_1stream.html#ad5419b179aba75341cc72d6be84b99d0">Подробнее...</a><br /></td></tr>
<tr class="separator:ad5419b179aba75341cc72d6be84b99d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c7c656ef50bb2c7030e3b82895faab"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken = default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a65c7c656ef50bb2c7030e3b82895faab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream.html#a65c7c656ef50bb2c7030e3b82895faab">async_read_some</a> (const MutableBufferSequence &amp;buffers, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; <a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a> &gt;()) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; initiate_async_read_some &gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers))</td></tr>
<tr class="memdesc:a65c7c656ef50bb2c7030e3b82895faab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous read.  <a href="classasio_1_1ssl_1_1stream.html#a65c7c656ef50bb2c7030e3b82895faab">Подробнее...</a><br /></td></tr>
<tr class="separator:a65c7c656ef50bb2c7030e3b82895faab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Дополнительные унаследованные члены</h2></td></tr>
<tr class="inherit_header pro_methods_classasio_1_1ssl_1_1stream__base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classasio_1_1ssl_1_1stream__base')"><img src="closed.png" alt="-"/>&#160;Защищенные члены унаследованные от <a class="el" href="classasio_1_1ssl_1_1stream__base.html">asio::ssl::stream_base</a></td></tr>
<tr class="memitem:af44f60fc18949a1235701c7ab76848b8 inherit pro_methods_classasio_1_1ssl_1_1stream__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#af44f60fc18949a1235701c7ab76848b8">~stream_base</a> ()</td></tr>
<tr class="memdesc:af44f60fc18949a1235701c7ab76848b8 inherit pro_methods_classasio_1_1ssl_1_1stream__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor to prevent deletion through this type.  <a href="classasio_1_1ssl_1_1stream__base.html#af44f60fc18949a1235701c7ab76848b8">Подробнее...</a><br /></td></tr>
<tr class="separator:af44f60fc18949a1235701c7ab76848b8 inherit pro_methods_classasio_1_1ssl_1_1stream__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><h3>template&lt;typename Stream&gt;<br />
class asio::ssl::stream&lt; Stream &gt;</h3>

<p>Provides stream-oriented functionality using SSL. </p>
<p>The stream class template provides asynchronous and blocking stream-oriented functionality using SSL.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br  />
<em>Shared</em> <em>objects:</em> Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To use the SSL stream template with an <a class="el" href="classasio_1_1ip_1_1tcp.html#a6f5bf95251747bb81d75784387938d6a" title="The TCP socket type.">ip::tcp::socket</a>, you would write: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1io__context.html">asio::io_context</a> my_context;</div>
<div class="line"><a class="code" href="classasio_1_1ssl_1_1context.html">asio::ssl::context</a> ctx(<a class="code" href="classasio_1_1ssl_1_1context__base.html#ac37d498266e3b13607f011ace6417525ae478c3ede58b50c99d6c6ff9ed7c0124">asio::ssl::context::sslv23</a>);</div>
<div class="line"><a class="code" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream&lt;asio:ip::tcp::socket&gt;</a> sock(my_context, ctx);</div>
<div class="ttc" id="aclassasio_1_1io__context_html"><div class="ttname"><a href="classasio_1_1io__context.html">asio::io_context</a></div><div class="ttdoc">Provides core I/O functionality.</div><div class="ttdef"><b>Definition:</b> io_context.hpp:193</div></div>
<div class="ttc" id="aclassasio_1_1ssl_1_1context__base_html_ac37d498266e3b13607f011ace6417525ae478c3ede58b50c99d6c6ff9ed7c0124"><div class="ttname"><a href="classasio_1_1ssl_1_1context__base.html#ac37d498266e3b13607f011ace6417525ae478c3ede58b50c99d6c6ff9ed7c0124">asio::ssl::context_base::sslv23</a></div><div class="ttdeci">@ sslv23</div><div class="ttdoc">Generic SSL/TLS.</div><div class="ttdef"><b>Definition:</b> context_base.hpp:62</div></div>
<div class="ttc" id="aclassasio_1_1ssl_1_1context_html"><div class="ttname"><a href="classasio_1_1ssl_1_1context.html">asio::ssl::context</a></div><div class="ttdef"><b>Definition:</b> context.hpp:38</div></div>
<div class="ttc" id="aclassasio_1_1ssl_1_1stream_html"><div class="ttname"><a href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a></div><div class="ttdoc">Provides stream-oriented functionality using SSL.</div><div class="ttdef"><b>Definition:</b> stream.hpp:67</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream. </dd></dl>
</div><h2 class="groupheader">Определения типов</h2>
<a id="aca16e85f03c2ac2adb1851ac09adc8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca16e85f03c2ac2adb1851ac09adc8f6">&#9670;&nbsp;</a></span>executor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef lowest_layer_type::executor_type <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::<a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the executor associated with the object. </p>

</div>
</div>
<a id="ae3642d059991c8d0285b888673c677ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3642d059991c8d0285b888673c677ca">&#9670;&nbsp;</a></span>lowest_layer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef next_layer_type::lowest_layer_type <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::<a class="el" href="classasio_1_1ssl_1_1stream.html#ae3642d059991c8d0285b888673c677ca">lowest_layer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the lowest layer. </p>

</div>
</div>
<a id="ad10bd7f631ed0704388d4dd90b5f3342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10bd7f631ed0704388d4dd90b5f3342">&#9670;&nbsp;</a></span>native_handle_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef SSL* <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::<a class="el" href="classasio_1_1ssl_1_1stream.html#ad10bd7f631ed0704388d4dd90b5f3342">native_handle_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The native handle type of the SSL stream. </p>

</div>
</div>
<a id="aec0d98307a114d63f9a69db33eaa177d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0d98307a114d63f9a69db33eaa177d">&#9670;&nbsp;</a></span>next_layer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a>&lt;Stream&gt; <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::<a class="el" href="classasio_1_1ssl_1_1stream.html#aec0d98307a114d63f9a69db33eaa177d">next_layer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the next layer. </p>

</div>
</div>
<h2 class="groupheader">Конструктор(ы)</h2>
<a id="aba9228655482c6878c31c798af446cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9228655482c6878c31c798af446cb5">&#9670;&nbsp;</a></span>stream() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::<a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a stream. </p>
<p>This constructor creates a stream and initialises the underlying stream object.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The argument to be passed to initialise the underlying stream.</td></tr>
    <tr><td class="paramname">ctx</td><td>The SSL context to be used for the stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6b3a01958d30b7c1ac21f5dfec8f809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b3a01958d30b7c1ac21f5dfec8f809">&#9670;&nbsp;</a></span>stream() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::<a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream.html#ad10bd7f631ed0704388d4dd90b5f3342">native_handle_type</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a stream from an existing native implementation. </p>
<p>This constructor creates a stream and initialises the underlying stream object. On success, ownership of the native implementation is transferred to the stream, and it will be cleaned up when the stream is destroyed.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The argument to be passed to initialise the underlying stream.</td></tr>
    <tr><td class="paramname">handle</td><td>An existing native SSL implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47f5839fba525c1afd96dec0727ef3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f5839fba525c1afd96dec0727ef3a5">&#9670;&nbsp;</a></span>stream() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::<a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a>&lt; Stream &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct a stream from another. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other stream object from which the move will occur. Must have no outstanding asynchronous operations associated with it. Following the move, <code>other</code> has a valid but unspecified state where the only safe operation is destruction, or use as the target of a move assignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51cbc4691960a13f26b19fb7dec1e195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cbc4691960a13f26b19fb7dec1e195">&#9670;&nbsp;</a></span>~stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::~<a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<dl class="section note"><dt>Заметки</dt><dd>A <code>stream</code> object must not be destroyed while there are pending asynchronous operations associated with it. </dd></dl>

</div>
</div>
<h2 class="groupheader">Методы</h2>
<a id="a54e105dcbe6fe8a26faa17752942c831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e105dcbe6fe8a26faa17752942c831">&#9670;&nbsp;</a></span>async_handshake() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) BufferedHandshakeToken = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::async_handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferedHandshakeToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;<a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
      <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;BufferedHandshakeToken,
        <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
          declval&lt;initiate_async_buffered_handshake&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, type, buffers))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start an asynchronous SSL handshake. </p>
<p>This function is used to asynchronously perform an SSL handshake on the stream. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">buffers</td><td>The buffered data to be reused for the handshake. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the handshake completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred <span class="comment">// Amount of buffers used in handshake.</span></div>
<div class="line">); </div>
<div class="ttc" id="anamespaceasio_html_ac8914468bc40252ae5e5c666adb951cf"><div class="ttname"><a href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a></div><div class="ttdeci">std::error_code error_code</div><div class="ttdef"><b>Definition:</b> error_code.hpp:26</div></div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
<div class="ttc" id="abind__immediate__executor_8cpp_html_a59a5a6248bbe8018ef97e7c0490d1508"><div class="ttname"><a href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a></div><div class="ttdeci">void()&gt;(declval&lt; initiate_immediate &gt;()</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>Stream</code> type's <code>async_read_some</code> and <code>async_write_some</code> operations. </p>

</div>
</div>
<a id="af524e1639657b7ca700aa769c0443a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af524e1639657b7ca700aa769c0443a1f">&#9670;&nbsp;</a></span>async_handshake() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;HandshakeToken  = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::async_handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandshakeToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;<a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
      <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;HandshakeToken,
        <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>)&gt;(
          declval&lt;initiate_async_handshake&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, type))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start an asynchronous SSL handshake. </p>
<p>This function is used to asynchronously perform an SSL handshake on the stream. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the handshake completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error <span class="comment">// Result of operation.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>Stream</code> type's <code>async_read_some</code> and <code>async_write_some</code> operations. </p>

</div>
</div>
<a id="a65c7c656ef50bb2c7030e3b82895faab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c7c656ef50bb2c7030e3b82895faab">&#9670;&nbsp;</a></span>async_read_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;<a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
      <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;ReadToken,
        <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
          declval&lt;initiate_async_read_some&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start an asynchronous read. </p>
<p>This function is used to asynchronously read one or more bytes of data from the stream. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred <span class="comment">// Number of bytes read.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The async_read_some operation may not read all of the requested number of bytes. Consider using the <a class="el" href="group__async__read.html">asio::async_read</a> function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>Stream</code> type's <code>async_read_some</code> and <code>async_write_some</code> operations. </p>

</div>
</div>
<a id="ad41783b8c9fc87726c44bee65498b4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41783b8c9fc87726c44bee65498b4bc">&#9670;&nbsp;</a></span>async_shutdown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;ShutdownToken  = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::async_shutdown </td>
          <td>(</td>
          <td class="paramtype">ShutdownToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;<a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a>&gt;()</code></td><td>)</td>
          <td> -&gt; decltype(
      <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;ShutdownToken,
        <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>)&gt;(
          declval&lt;initiate_async_shutdown&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously shut down SSL on the stream. </p>
<p>This function is used to asynchronously shut down SSL on the stream. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the shutdown completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error <span class="comment">// Result of operation.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>Stream</code> type's <code>async_read_some</code> and <code>async_write_some</code> operations. </p>

</div>
</div>
<a id="a9e2dbfa851f9f9cecc4ed805bfe3a86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2dbfa851f9f9cecc4ed805bfe3a86c">&#9670;&nbsp;</a></span>async_write_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken = default_completion_token_t&lt;executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::async_write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;<a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
      <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;WriteToken,
        <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(
          declval&lt;initiate_async_write_some&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start an asynchronous write. </p>
<p>This function is used to asynchronously write one or more bytes of data to the stream. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred <span class="comment">// Number of bytes written.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The async_write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__async__write.html">asio::async_write</a> function if you need to ensure that all data is written before the asynchronous operation completes.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>Stream</code> type's <code>async_read_some</code> and <code>async_write_some</code> operations. </p>

</div>
</div>
<a id="a614c2cc94b807608b54ea4e3908acadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614c2cc94b807608b54ea4e3908acadf">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1stream.html#aca16e85f03c2ac2adb1851ac09adc8f6">executor_type</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor associated with the object. </p>
<p>This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>Возвращает</dt><dd>A copy of the executor that stream will use to dispatch handlers. </dd></dl>

</div>
</div>
<a id="ab033983103661135df087954a0a104a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab033983103661135df087954a0a104a4">&#9670;&nbsp;</a></span>handshake() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform SSL handshaking. </p>
<p>This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa53d0718b8940993a96edbfcbe0abf92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53d0718b8940993a96edbfcbe0abf92">&#9670;&nbsp;</a></span>handshake() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform SSL handshaking. </p>
<p>This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae576e595f41b72459ded95b88cd870c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae576e595f41b72459ded95b88cd870c8">&#9670;&nbsp;</a></span>handshake() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform SSL handshaking. </p>
<p>This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">buffers</td><td>The buffered data to be reused for the handshake.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a460cf902049df2a6c9d3b8731aad9532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460cf902049df2a6c9d3b8731aad9532">&#9670;&nbsp;</a></span>handshake() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform SSL handshaking. </p>
<p>This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">buffers</td><td>The buffered data to be reused for the handshake.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaab4ba6e92ef6b2009d103bb71bfdef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaab4ba6e92ef6b2009d103bb71bfdef">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1stream.html#ae3642d059991c8d0285b888673c677ca">lowest_layer_type</a>&amp; <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the lowest layer. </p>
<p>This function returns a reference to the lowest layer in a stack of stream layers.</p>
<dl class="section return"><dt>Возвращает</dt><dd>A reference to the lowest layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a266ccbc89d82d9384ceb6148c9bd13bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266ccbc89d82d9384ceb6148c9bd13bf">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1ssl_1_1stream.html#ae3642d059991c8d0285b888673c677ca">lowest_layer_type</a>&amp; <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the lowest layer. </p>
<p>This function returns a reference to the lowest layer in a stack of stream layers.</p>
<dl class="section return"><dt>Возвращает</dt><dd>A reference to the lowest layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a08506517747d6f5b2174f0f35dd49fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08506517747d6f5b2174f0f35dd49fa9">&#9670;&nbsp;</a></span>native_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1stream.html#ad10bd7f631ed0704388d4dd90b5f3342">native_handle_type</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying implementation in the native type. </p>
<p>This function may be used to obtain the underlying implementation of the context. This is intended to allow access to context functionality that is not otherwise provided.</p>
<dl class="section user"><dt>Example</dt><dd>The <a class="el" href="classasio_1_1ssl_1_1stream.html#a08506517747d6f5b2174f0f35dd49fa9" title="Get the underlying implementation in the native type.">native_handle()</a> function returns a pointer of type <code>SSL*</code> that is suitable for passing to functions such as <code>SSL_get_verify_result</code> and <code>SSL_get_peer_certificate:</code> <div class="fragment"><div class="line"><a class="code" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream&lt;asio:ip::tcp::socket&gt;</a> sock(my_context, ctx);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... establish connection and perform handshake ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (X509* cert = SSL_get_peer_certificate(sock.native_handle()))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (SSL_get_verify_result(sock.native_handle()) == X509_V_OK)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae923c2a65c0f6fec01a335384f752d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae923c2a65c0f6fec01a335384f752d12">&#9670;&nbsp;</a></span>next_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1stream.html#aec0d98307a114d63f9a69db33eaa177d">next_layer_type</a>&amp; <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the next layer. </p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section return"><dt>Возвращает</dt><dd>A reference to the next layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a6bbad8acb17df77ee6cb08f1eaacf376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbad8acb17df77ee6cb08f1eaacf376">&#9670;&nbsp;</a></span>next_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1ssl_1_1stream.html#aec0d98307a114d63f9a69db33eaa177d">next_layer_type</a>&amp; <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the next layer. </p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section return"><dt>Возвращает</dt><dd>A reference to the next layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a034b4d51af48e64b5019a2373114f55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034b4d51af48e64b5019a2373114f55c">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a>&amp; <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream.html">stream</a>&lt; Stream &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assign a stream from another. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other stream object from which the move will occur. Must have no outstanding asynchronous operations associated with it. Following the move, <code>other</code> has a valid but unspecified state where the only safe operation is destruction, or use as the target of a move assignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0c216bb02d351b2f94d96aa60a056ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c216bb02d351b2f94d96aa60a056ea">&#9670;&nbsp;</a></span>read_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read some data from the stream. </p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes read.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>The read_some operation may not read all of the requested number of bytes. Consider using the <a class="el" href="group__read.html">asio::read</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="ad5419b179aba75341cc72d6be84b99d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5419b179aba75341cc72d6be84b99d0">&#9670;&nbsp;</a></span>read_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read some data from the stream. </p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes read. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The read_some operation may not read all of the requested number of bytes. Consider using the <a class="el" href="group__read.html">asio::read</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="ae3fbf34c4cd1386754e8395b8e2ce65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fbf34c4cd1386754e8395b8e2ce65e">&#9670;&nbsp;</a></span>set_verify_callback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename VerifyCallback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::set_verify_callback </td>
          <td>(</td>
          <td class="paramtype">VerifyCallback&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the callback used to verify peer certificates. </p>
<p>This function is used to specify a callback function that will be called by the implementation when it needs to verify a peer certificate.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function object to be used for verifying a certificate. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">bool</span> <a class="code" href="namespacessl__stream__compile.html#a44cb0d99b5b25b3d215089097d16f0f0">verify_callback</a>(</div>
<div class="line">  <span class="keywordtype">bool</span> preverified, <span class="comment">// True if the certificate passed pre-verification.</span></div>
<div class="line">  verify_context&amp; ctx <span class="comment">// The peer certificate and other context.</span></div>
<div class="line">); </div>
<div class="ttc" id="anamespacessl__stream__compile_html_a44cb0d99b5b25b3d215089097d16f0f0"><div class="ttname"><a href="namespacessl__stream__compile.html#a44cb0d99b5b25b3d215089097d16f0f0">ssl_stream_compile::verify_callback</a></div><div class="ttdeci">bool verify_callback(bool, asio::ssl::verify_context &amp;)</div><div class="ttdef"><b>Definition:</b> stream.cpp:33</div></div>
</div><!-- fragment --> The return value of the callback is true if the certificate has passed verification, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>Calls <code>SSL_set_verify</code>. </dd></dl>

</div>
</div>
<a id="a4ec8d40bc7c1ffc28372b085a3f1edf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec8d40bc7c1ffc28372b085a3f1edf2">&#9670;&nbsp;</a></span>set_verify_callback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename VerifyCallback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::set_verify_callback </td>
          <td>(</td>
          <td class="paramtype">VerifyCallback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the callback used to verify peer certificates. </p>
<p>This function is used to specify a callback function that will be called by the implementation when it needs to verify a peer certificate.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function object to be used for verifying a certificate. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">bool</span> <a class="code" href="namespacessl__stream__compile.html#a44cb0d99b5b25b3d215089097d16f0f0">verify_callback</a>(</div>
<div class="line">  <span class="keywordtype">bool</span> preverified, <span class="comment">// True if the certificate passed pre-verification.</span></div>
<div class="line">  verify_context&amp; ctx <span class="comment">// The peer certificate and other context.</span></div>
<div class="line">); </div>
</div><!-- fragment --> The return value of the callback is true if the certificate has passed verification, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>Calls <code>SSL_set_verify</code>. </dd></dl>

</div>
</div>
<a id="a9eb5030ca05dee079ded85891da9a7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb5030ca05dee079ded85891da9a7de">&#9670;&nbsp;</a></span>set_verify_depth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::set_verify_depth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the peer verification depth. </p>
<p>This function may be used to configure the maximum verification depth allowed by the stream.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>Maximum depth for the certificate chain verification that shall be allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>Calls <code>SSL_set_verify_depth</code>. </dd></dl>

</div>
</div>
<a id="a71bc41e2879105d57143910d80fd35e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bc41e2879105d57143910d80fd35e2">&#9670;&nbsp;</a></span>set_verify_depth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::set_verify_depth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the peer verification depth. </p>
<p>This function may be used to configure the maximum verification depth allowed by the stream.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>Maximum depth for the certificate chain verification that shall be allowed.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>Calls <code>SSL_set_verify_depth</code>. </dd></dl>

</div>
</div>
<a id="aa99e1eb0409e05c3439d478229bf0a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99e1eb0409e05c3439d478229bf0a0c">&#9670;&nbsp;</a></span>set_verify_mode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::set_verify_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceasio_1_1ssl.html#aa6497e51bc608f2397a731a14f80b563">verify_mode</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the peer verification mode. </p>
<p>This function may be used to configure the peer verification mode used by the stream. The new mode will override the mode inherited from the context.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A bitmask of peer verification modes. See <a class="el" href="namespaceasio_1_1ssl.html#aa6497e51bc608f2397a731a14f80b563">verify_mode</a> for available values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>Calls <code>SSL_set_verify</code>. </dd></dl>

</div>
</div>
<a id="ad7e6ad5f06dd90b8dbe85f479a010239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e6ad5f06dd90b8dbe85f479a010239">&#9670;&nbsp;</a></span>set_verify_mode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::set_verify_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceasio_1_1ssl.html#aa6497e51bc608f2397a731a14f80b563">verify_mode</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the peer verification mode. </p>
<p>This function may be used to configure the peer verification mode used by the stream. The new mode will override the mode inherited from the context.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A bitmask of peer verification modes. See <a class="el" href="namespaceasio_1_1ssl.html#aa6497e51bc608f2397a731a14f80b563">verify_mode</a> for available values.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>Calls <code>SSL_set_verify</code>. </dd></dl>

</div>
</div>
<a id="a5738d2511541cdee020d4b6a24d2df4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5738d2511541cdee020d4b6a24d2df4f">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shut down SSL on the stream. </p>
<p>This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.</p>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aced61ce3e50c0588680538ff06c1199d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced61ce3e50c0588680538ff06c1199d">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a83e66f7c66c4e73c01aa6b3d523e12a4">ASIO_SYNC_OP_VOID</a> <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shut down SSL on the stream. </p>
<p>This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab12478afb2ddb7d73b9eb91f523fc5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12478afb2ddb7d73b9eb91f523fc5df">&#9670;&nbsp;</a></span>write_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write some data to the stream. </p>
<p>This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes written.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>The write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">asio::write</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="ab7079c181a877bd4450d118a63999d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7079c181a877bd4450d118a63999d83">&#9670;&nbsp;</a></span>write_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream</a>&lt; Stream &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write some data to the stream. </p>
<p>This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written to the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes written. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">asio::write</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<hr/>Объявления и описания членов класса находятся в файле:<ul>
<li>_deps/asio-src/asio/include/asio/ssl/<a class="el" href="stream_8hpp_source.html">stream.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
