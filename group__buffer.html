<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bulk_server: asio::buffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bulk_server
   &#160;<span id="projectnumber">0.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">asio::buffer</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string.  
</p>
<p>The <a class="el" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string. </p>
<p>A buffer object represents a contiguous region of memory as a 2-tuple consisting of a pointer and size in bytes. A tuple of the form <code>{void*, size_t}</code> specifies a mutable (modifiable) region of memory. Similarly, a tuple of the form <code>{const void*, size_t}</code> specifies a const (non-modifiable) region of memory. These two forms correspond to the classes <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> and <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a>, respectively. To mirror C++'s conversion rules, a <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> is implicitly convertible to a <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a>, and the opposite conversion is not permitted.</p>
<p>The simplest use case involves reading or writing a single buffer of a specified size:</p>
<div class="fragment"><div class="line">sock.send(<a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size)); </div>
<div class="ttc" id="anamespaceasio_html_af691d016b23fd6c2da9ac91ce00c2e7e"><div class="ttname"><a href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a></div><div class="ttdeci">ASIO_NODISCARD ASIO_MUTABLE_BUFFER buffer(const mutable_buffer &amp;b) noexcept</div><div class="ttdoc">Create a new modifiable buffer from an existing buffer.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:862</div></div>
</div><!-- fragment --><p>In the above example, the return value of <a class="el" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> meets the requirements of the ConstBufferSequence concept so that it may be directly passed to the socket's write function. A buffer created for modifiable memory also meets the requirements of the MutableBufferSequence concept.</p>
<p>An individual buffer may be created from a builtin array, std::vector, std::array or <a class="el" href="classboost_1_1array.html">boost::array</a> of POD elements. This helps prevent buffer overruns by automatically determining the size of the buffer:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">char</span> d1[128];</div>
<div class="line"><span class="keywordtype">size_t</span> bytes_transferred = sock.receive(<a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(d1));</div>
<div class="line"> </div>
<div class="line">std::vector&lt;char&gt; d2(128);</div>
<div class="line">bytes_transferred = sock.receive(<a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(d2));</div>
<div class="line"> </div>
<div class="line">std::array&lt;char, 128&gt; d3;</div>
<div class="line">bytes_transferred = sock.receive(<a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(d3));</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> d4;</div>
<div class="line">bytes_transferred = sock.receive(<a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(d4)); </div>
<div class="ttc" id="aclassboost_1_1array_html"><div class="ttname"><a href="classboost_1_1array.html">boost::array&lt; char, 128 &gt;</a></div></div>
</div><!-- fragment --><p>In all three cases above, the buffers created are exactly 128 bytes long. Note that a vector is <em>never</em> automatically resized when creating or using a buffer. The buffer size is determined using the vector's <code>size()</code> member function, and not its capacity.</p>
<dl class="section user"><dt>Accessing Buffer Contents</dt><dd></dd></dl>
<p>The contents of a buffer may be accessed using the <code>data()</code> and <code>size()</code> member functions:</p>
<div class="fragment"><div class="line"> <a class="code" href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a> b1 = ...;</div>
<div class="line">std::size_t s1 = b1.<a class="code" href="classasio_1_1mutable__buffer.html#ab9d28de61ccf85b1e87f3c2394024af8">size</a>();</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* p1 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(b1.<a class="code" href="classasio_1_1mutable__buffer.html#ac97107b8cdf91665d7a904e0330c5665">data</a>());</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classasio_1_1const__buffer.html">asio::const_buffer</a> b2 = ...;</div>
<div class="line">std::size_t s2 = b2.<a class="code" href="classasio_1_1const__buffer.html#a2abf65b9fa9590ac238e1d17c5b46e8b">size</a>();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">void</span>* p2 = b2.<a class="code" href="classasio_1_1const__buffer.html#aac009108b503e6426b3029cfa67d4e73">data</a>(); </div>
<div class="ttc" id="aclassasio_1_1const__buffer_html"><div class="ttname"><a href="classasio_1_1const__buffer.html">asio::const_buffer</a></div><div class="ttdoc">Holds a buffer that cannot be modified.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:213</div></div>
<div class="ttc" id="aclassasio_1_1const__buffer_html_a2abf65b9fa9590ac238e1d17c5b46e8b"><div class="ttname"><a href="classasio_1_1const__buffer.html#a2abf65b9fa9590ac238e1d17c5b46e8b">asio::const_buffer::size</a></div><div class="ttdeci">std::size_t size() const noexcept</div><div class="ttdoc">Get the size of the memory range.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:265</div></div>
<div class="ttc" id="aclassasio_1_1const__buffer_html_aac009108b503e6426b3029cfa67d4e73"><div class="ttname"><a href="classasio_1_1const__buffer.html#aac009108b503e6426b3029cfa67d4e73">asio::const_buffer::data</a></div><div class="ttdeci">const void * data() const noexcept</div><div class="ttdoc">Get a pointer to the beginning of the memory range.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:255</div></div>
<div class="ttc" id="aclassasio_1_1mutable__buffer_html"><div class="ttname"><a href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a></div><div class="ttdoc">Holds a buffer that can be modified.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:79</div></div>
<div class="ttc" id="aclassasio_1_1mutable__buffer_html_ab9d28de61ccf85b1e87f3c2394024af8"><div class="ttname"><a href="classasio_1_1mutable__buffer.html#ab9d28de61ccf85b1e87f3c2394024af8">asio::mutable_buffer::size</a></div><div class="ttdeci">std::size_t size() const noexcept</div><div class="ttdoc">Get the size of the memory range.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:121</div></div>
<div class="ttc" id="aclassasio_1_1mutable__buffer_html_ac97107b8cdf91665d7a904e0330c5665"><div class="ttname"><a href="classasio_1_1mutable__buffer.html#ac97107b8cdf91665d7a904e0330c5665">asio::mutable_buffer::data</a></div><div class="ttdeci">void * data() const noexcept</div><div class="ttdoc">Get a pointer to the beginning of the memory range.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:111</div></div>
</div><!-- fragment --><p>The <code>data()</code> member function permits violations of type safety, so uses of it in application code should be carefully considered.</p>
<p>For convenience, a <a class="el" href="namespaceasio.html#a32ffb00a82a2cb0dcbb976e02d82cc79">buffer_size</a> function is provided that works with both buffers and buffer sequences (that is, types meeting the ConstBufferSequence or MutableBufferSequence type requirements). In this case, the function returns the total size of all buffers in the sequence.</p>
<dl class="section user"><dt>Buffer Copying</dt><dd></dd></dl>
<p>The <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> function may be used to copy raw bytes between individual buffers and buffer sequences.</p>
<p>In particular, when used with the <a class="el" href="namespaceasio.html#a32ffb00a82a2cb0dcbb976e02d82cc79">buffer_size</a> function, the <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> function can be used to linearise a sequence of buffers. For example:</p>
<div class="fragment"><div class="line"> vector&lt;const_buffer&gt; buffers = ...;</div>
<div class="line"> </div>
<div class="line">vector&lt;unsigned char&gt; data(<a class="code" href="namespaceasio.html#a32ffb00a82a2cb0dcbb976e02d82cc79">asio::buffer_size</a>(buffers));</div>
<div class="line"><a class="code" href="namespaceasio.html#a9ab876ca15e1fd4f5f12caa8e0cac327">asio::buffer_copy</a>(<a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data), buffers); </div>
<div class="ttc" id="anamespaceasio_html_a32ffb00a82a2cb0dcbb976e02d82cc79"><div class="ttname"><a href="namespaceasio.html#a32ffb00a82a2cb0dcbb976e02d82cc79">asio::buffer_size</a></div><div class="ttdeci">std::size_t buffer_size(const BufferSequence &amp;b) noexcept</div><div class="ttdoc">Get the total number of bytes in a buffer sequence.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:529</div></div>
<div class="ttc" id="anamespaceasio_html_a9ab876ca15e1fd4f5f12caa8e0cac327"><div class="ttname"><a href="namespaceasio.html#a9ab876ca15e1fd4f5f12caa8e0cac327">asio::buffer_copy</a></div><div class="ttdeci">std::size_t buffer_copy(const MutableBufferSequence &amp;target, const ConstBufferSequence &amp;source) noexcept</div><div class="ttdoc">Copies bytes from a source buffer sequence to a target buffer sequence.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:2461</div></div>
</div><!-- fragment --><p>Note that <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions.</p>
<dl class="section user"><dt>Buffer Invalidation</dt><dd></dd></dl>
<p>A buffer object does not have any ownership of the memory it refers to. It is the responsibility of the application to ensure the memory region remains valid until it is no longer required for an I/O operation. When the memory is no longer available, the buffer is said to have been invalidated.</p>
<p>For the <a class="el" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> overloads that accept an argument of type std::vector, the buffer objects returned are invalidated by any vector operation that also invalidates all references, pointers and iterators referring to the elements in the sequence (C++ Std, 23.2.4)</p>
<p>For the <a class="el" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> overloads that accept an argument of type std::basic_string, the buffer objects returned are invalidated according to the rules defined for invalidation of references, pointers and iterators referring to elements of the sequence (C++ Std, 21.3).</p>
<dl class="section user"><dt>Buffer Arithmetic</dt><dd></dd></dl>
<p>Buffer objects may be manipulated using simple arithmetic in a safe way which helps prevent buffer overruns. Consider an array initialised as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 6&gt;</a> <a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a> = { <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span> }; </div>
<div class="ttc" id="anamespaceasio_html_aa80c4033469ae5aaa092c0d49852403c"><div class="ttname"><a href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">asio::a</a></div><div class="ttdeci">awaitable&lt; T, AwaitableExecutor &gt; a</div><div class="ttdef"><b>Definition:</b> co_spawn.hpp:342</div></div>
</div><!-- fragment --><p>A buffer object <code>b1</code> created using:</p>
<div class="fragment"><div class="line">b1 = <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(<a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>); </div>
</div><!-- fragment --><p>represents the entire array, <code>{ 'a', 'b', 'c', 'd', 'e' }</code>. An optional second argument to the <a class="el" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> function may be used to limit the size, in bytes, of the buffer:</p>
<div class="fragment"><div class="line">b2 = <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(<a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>, 3); </div>
</div><!-- fragment --><p>such that <code>b2</code> represents the data <code>{ 'a', 'b', 'c' }</code>. Even if the size argument exceeds the actual size of the array, the size of the buffer object created will be limited to the array size.</p>
<p>An offset may be applied to an existing buffer to create a new one:</p>
<div class="fragment"><div class="line">b3 = b1 + 2; </div>
</div><!-- fragment --><p>where <code>b3</code> will set to represent <code>{ 'c', 'd', 'e' }</code>. If the offset exceeds the size of the existing buffer, the newly created buffer will be empty.</p>
<p>Both an offset and size may be specified to create a buffer that corresponds to a specific range of bytes within an existing buffer:</p>
<div class="fragment"><div class="line">b4 = <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(b1 + 1, 3); </div>
</div><!-- fragment --><p>so that <code>b4</code> will refer to the bytes <code>{ 'b', 'c', 'd' }</code>.</p>
<dl class="section user"><dt>Buffers and Scatter-Gather I/O</dt><dd></dd></dl>
<p>To read or write using multiple buffers (i.e. scatter-gather I/O), multiple buffer objects may be assigned into a container that supports the MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> d1[128];</div>
<div class="line">std::vector&lt;char&gt; d2(128);</div>
<div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> d3;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;mutable_buffer, 3&gt;</a> bufs1 = {</div>
<div class="line">  <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(d1),</div>
<div class="line">  <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(d2),</div>
<div class="line">  <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(d3) };</div>
<div class="line">bytes_transferred = sock.receive(bufs1);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;const_buffer&gt; bufs2;</div>
<div class="line">bufs2.push_back(<a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(d1));</div>
<div class="line">bufs2.push_back(<a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(d2));</div>
<div class="line">bufs2.push_back(<a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(d3));</div>
<div class="line">bytes_transferred = sock.send(bufs2); </div>
</div><!-- fragment --><dl class="section user"><dt>Buffer Literals</dt><dd></dd></dl>
<p>The <code>_buf</code> literal suffix, defined in namespace <code><a class="el" href="namespaceasio_1_1buffer__literals.html">asio::buffer_literals</a></code>, may be used to create <code><a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a></code> objects from string, binary integer, and hexadecimal integer literals. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceasio_1_1buffer__literals.html">asio::buffer_literals</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classasio_1_1const__buffer.html">asio::const_buffer</a> b1 = <span class="stringliteral">&quot;hello&quot;</span>_buf;</div>
<div class="line"><a class="code" href="classasio_1_1const__buffer.html">asio::const_buffer</a> b2 = 0xdeadbeef_buf;</div>
<div class="line"><a class="code" href="classasio_1_1const__buffer.html">asio::const_buffer</a> b3 = 0x0123456789abcdef0123456789abcdef_buf;</div>
<div class="line"><a class="code" href="classasio_1_1const__buffer.html">asio::const_buffer</a> b4 = 0b1010101011001100_buf; </div>
<div class="ttc" id="anamespaceasio_1_1buffer__literals_html"><div class="ttname"><a href="namespaceasio_1_1buffer__literals.html">asio::buffer_literals</a></div><div class="ttdef"><b>Definition:</b> buffer.hpp:2590</div></div>
</div><!-- fragment --><p>Note that the memory associated with a buffer literal is valid for the lifetime of the program. This means that the buffer can be safely used with asynchronous operations. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
