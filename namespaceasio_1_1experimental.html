<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bulk_server: Пространство имен asio::experimental</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bulk_server
   &#160;<span id="projectnumber">0.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceasio.html">asio</a></li><li class="navelem"><a class="el" href="namespaceasio_1_1experimental.html">experimental</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Пространства имен</a> &#124;
<a href="#nested-classes">Классы</a> &#124;
<a href="#typedef-members">Определения типов</a> &#124;
<a href="#func-members">Функции</a> &#124;
<a href="#var-members">Переменные</a>  </div>
  <div class="headertitle">
<div class="title">Пространство имен asio::experimental</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Пространства имен</h2></td></tr>
<tr class="memitem:namespaceasio_1_1experimental_1_1awaitable__operators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental_1_1awaitable__operators.html">awaitable_operators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1experimental_1_1channel__errc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental_1_1channel__errc.html">channel_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1experimental_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1experimental_1_1error"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental_1_1error.html">error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Классы</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1as__single__t.html">as_single_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1basic__channel.html">basic_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A channel for messages.  <a href="classasio_1_1experimental_1_1basic__channel.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1basic__concurrent__channel.html">basic_concurrent_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A channel for messages.  <a href="classasio_1_1experimental_1_1basic__concurrent__channel.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1wait__for__all.html">wait_for_all</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all operations to complete.  <a href="classasio_1_1experimental_1_1wait__for__all.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1wait__for__one.html">wait_for_one</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until an operation completes, then cancel the others.  <a href="classasio_1_1experimental_1_1wait__for__one.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1wait__for__one__success.html">wait_for_one_success</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until an operation completes without an error, then cancel the others.  <a href="classasio_1_1experimental_1_1wait__for__one__success.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1wait__for__one__error.html">wait_for_one_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until an operation completes with an error, then cancel the others.  <a href="classasio_1_1experimental_1_1wait__for__one__error.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits.html">channel_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits used for customising channel behaviour.  <a href="structasio_1_1experimental_1_1channel__traits.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits_3_01R_07asio_1_1error__code_08_4.html">channel_traits&lt; R(asio::error_code)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits_3_01R_07asio_1_1error__code_00_01Args_8_8_8_08_00_01Signatures_8_8_8_01_4.html">channel_traits&lt; R(asio::error_code, Args...), Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits_3_01R_07std_1_1exception__ptr_08_4.html">channel_traits&lt; R(std::exception_ptr)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits_3_01R_07std_1_1exception__ptr_00_01Args_8_8_8_08_00_01Signatures_8_8_8_01_4.html">channel_traits&lt; R(std::exception_ptr, Args...), Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1channel__traits_3_01R_07T_08_4.html">channel_traits&lt; R(T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main type of a resumable coroutine.  <a href="structasio_1_1experimental_1_1coro.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1coro__traits.html">coro_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1coro__traits_3_01T_07U_08_00_01Return_00_01Executor_01_4.html">coro_traits&lt; T(U), Return, Executor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1coro__traits_3_01T_07U_08_01noexcept_00_01Return_00_01Executor_01_4.html">coro_traits&lt; T(U) noexcept, Return, Executor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1promise.html">promise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1use__promise__t.html">use_promise_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1is__async__operation__range.html">is_async_operation_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1parallel__group.html">parallel_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A group of asynchronous operations that may be launched in parallel.  <a href="classasio_1_1experimental_1_1parallel__group.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1experimental_1_1ranged__parallel__group.html">ranged_parallel_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1is__promise.html">is_promise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1is__promise_3_01promise_3_01Ts_8_8_8_01_4_01_4.html">is_promise&lt; promise&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1promise__value__type.html">promise_value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1promise__value__type_3_01T_01_4.html">promise_value_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1promise__value__type_3_4.html">promise_value_type&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1promise_3_01void_07Ts_8_8_8_08_00_01Executor_00_01Allocator_01_4.html">promise&lt; void(Ts...), Executor, Allocator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1experimental_1_1use__coro__t.html">use_coro_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A completion_token that creates another coro for the task completion.  <a href="structasio_1_1experimental_1_1use__coro__t.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Определения типов</h2></td></tr>
<tr class="memitem:ab360a432854fdf77bccc3e0079ae3d8d"><td class="memTemplParams" colspan="2">template&lt;typename ExecutorOrSignature , typename... Signatures&gt; </td></tr>
<tr class="memitem:ab360a432854fdf77bccc3e0079ae3d8d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#ab360a432854fdf77bccc3e0079ae3d8d">channel</a> = typename <a class="el" href="structasio_1_1experimental_1_1detail_1_1channel__type.html">detail::channel_type</a>&lt; ExecutorOrSignature &gt;::template inner&lt; Signatures... &gt;::type</td></tr>
<tr class="memdesc:ab360a432854fdf77bccc3e0079ae3d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type alias for common use of channel.  <a href="namespaceasio_1_1experimental.html#ab360a432854fdf77bccc3e0079ae3d8d">Подробнее...</a><br /></td></tr>
<tr class="separator:ab360a432854fdf77bccc3e0079ae3d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a68f089b90bda97e79ab1855f02b0d"><td class="memTemplParams" colspan="2">template&lt;typename ExecutorOrSignature , typename... Signatures&gt; </td></tr>
<tr class="memitem:a33a68f089b90bda97e79ab1855f02b0d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a33a68f089b90bda97e79ab1855f02b0d">concurrent_channel</a> = typename <a class="el" href="structasio_1_1experimental_1_1detail_1_1concurrent__channel__type.html">detail::concurrent_channel_type</a>&lt; ExecutorOrSignature &gt;::template inner&lt; Signatures... &gt;::type</td></tr>
<tr class="memdesc:a33a68f089b90bda97e79ab1855f02b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type alias for common use of channel.  <a href="namespaceasio_1_1experimental.html#a33a68f089b90bda97e79ab1855f02b0d">Подробнее...</a><br /></td></tr>
<tr class="separator:a33a68f089b90bda97e79ab1855f02b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73dcb4e54e3f5c2f062180559c76a91a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor  = asio::any_io_executor, typename Allocator  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a73dcb4e54e3f5c2f062180559c76a91a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a73dcb4e54e3f5c2f062180559c76a91a">generator</a> = <a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor, Allocator &gt;</td></tr>
<tr class="memdesc:a73dcb4e54e3f5c2f062180559c76a91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generator is a coro that returns void and yields value.  <a href="namespaceasio_1_1experimental.html#a73dcb4e54e3f5c2f062180559c76a91a">Подробнее...</a><br /></td></tr>
<tr class="separator:a73dcb4e54e3f5c2f062180559c76a91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65ccdddb39d7eb98cbf26d1a8868c22"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor  = asio::any_io_executor, typename Allocator  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:af65ccdddb39d7eb98cbf26d1a8868c22"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#af65ccdddb39d7eb98cbf26d1a8868c22">task</a> = <a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor, Allocator &gt;</td></tr>
<tr class="memdesc:af65ccdddb39d7eb98cbf26d1a8868c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task is a coro that does not yield values.  <a href="namespaceasio_1_1experimental.html#af65ccdddb39d7eb98cbf26d1a8868c22">Подробнее...</a><br /></td></tr>
<tr class="separator:af65ccdddb39d7eb98cbf26d1a8868c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Функции</h2></td></tr>
<tr class="memitem:ac40085d70004257598fdc2a80b9a6e93"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:ac40085d70004257598fdc2a80b9a6e93"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1as__single__t.html">as_single_t</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; CompletionToken &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#ac40085d70004257598fdc2a80b9a6e93">as_single</a> (CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:ac40085d70004257598fdc2a80b9a6e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff7d9e99424546e76c794c60cb218f6"><td class="memTemplParams" colspan="2">template&lt;completion_signature... Signatures, typename Implementation , typename... IoObjectsOrExecutors&gt; </td></tr>
<tr class="memitem:a4ff7d9e99424546e76c794c60cb218f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a4ff7d9e99424546e76c794c60cb218f6">co_composed</a> (Implementation &amp;&amp;implementation, IoObjectsOrExecutors &amp;&amp;... io_objects_or_executors)</td></tr>
<tr class="separator:a4ff7d9e99424546e76c794c60cb218f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac83b8b49276d49470c7a45cdb5eb2bf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:aac83b8b49276d49470c7a45cdb5eb2bf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#aac83b8b49276d49470c7a45cdb5eb2bf">ASIO_INITFN_AUTO_RESULT_TYPE</a> (CompletionToken, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr, <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>)) <a class="el" href="namespaceasio_1_1experimental.html#af580e11a7608adfd35588421fbc592b3">co_spawn</a>(<a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a></td></tr>
<tr class="memdesc:aac83b8b49276d49470c7a45cdb5eb2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a resumable coroutine.  <a href="namespaceasio_1_1experimental.html#aac83b8b49276d49470c7a45cdb5eb2bf">Подробнее...</a><br /></td></tr>
<tr class="separator:aac83b8b49276d49470c7a45cdb5eb2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1558c3d3b0c140ab3bc99d78d8372ed8"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a1558c3d3b0c140ab3bc99d78d8372ed8">async_compose&lt; CompletionToken, void(std::exception_ptr, T)&gt;</a> (<a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt;{std::move(<a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>)}, <a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>, exec)</td></tr>
<tr class="separator:a1558c3d3b0c140ab3bc99d78d8372ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dd4cdae510a6353182475976cb8594"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#ac7dd4cdae510a6353182475976cb8594">async_compose&lt; CompletionToken, void(std::exception_ptr, T)&gt;</a> (<a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt;{std::move(<a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>)}, <a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>, exec)</td></tr>
<tr class="separator:ac7dd4cdae510a6353182475976cb8594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af580e11a7608adfd35588421fbc592b3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:af580e11a7608adfd35588421fbc592b3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#af580e11a7608adfd35588421fbc592b3">co_spawn</a> (<a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>() noexcept, <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt; <a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>, CompletionToken &amp;&amp;<a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>)</td></tr>
<tr class="memdesc:af580e11a7608adfd35588421fbc592b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a resumable coroutine.  <a href="namespaceasio_1_1experimental.html#af580e11a7608adfd35588421fbc592b3">Подробнее...</a><br /></td></tr>
<tr class="separator:af580e11a7608adfd35588421fbc592b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88bbac9488527afe4a8e0055fcbf6d3"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:ad88bbac9488527afe4a8e0055fcbf6d3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#ad88bbac9488527afe4a8e0055fcbf6d3">ASIO_INITFN_AUTO_RESULT_TYPE</a> (CompletionToken, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr)) <a class="el" href="namespaceasio_1_1experimental.html#af580e11a7608adfd35588421fbc592b3">co_spawn</a>(<a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a></td></tr>
<tr class="memdesc:ad88bbac9488527afe4a8e0055fcbf6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a resumable coroutine.  <a href="namespaceasio_1_1experimental.html#ad88bbac9488527afe4a8e0055fcbf6d3">Подробнее...</a><br /></td></tr>
<tr class="separator:ad88bbac9488527afe4a8e0055fcbf6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3e8c93a15f335b266e14235f20291b"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a0b3e8c93a15f335b266e14235f20291b">async_compose&lt; CompletionToken, void(std::exception_ptr)&gt;</a> (<a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt;{std::move(<a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>)}, <a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>, exec)</td></tr>
<tr class="separator:a0b3e8c93a15f335b266e14235f20291b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89249a63579083cae4bab8a2513e4a49"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a89249a63579083cae4bab8a2513e4a49">async_compose&lt; CompletionToken, void(std::exception_ptr)&gt;</a> (<a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt;{std::move(<a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>)}, <a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>, exec)</td></tr>
<tr class="separator:a89249a63579083cae4bab8a2513e4a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157a82d35a5d4826c5151c7e8f146607"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:a157a82d35a5d4826c5151c7e8f146607"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a157a82d35a5d4826c5151c7e8f146607">co_spawn</a> (<a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>() noexcept, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt; <a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>, CompletionToken &amp;&amp;<a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>)</td></tr>
<tr class="memdesc:a157a82d35a5d4826c5151c7e8f146607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a resumable coroutine.  <a href="namespaceasio_1_1experimental.html#a157a82d35a5d4826c5151c7e8f146607">Подробнее...</a><br /></td></tr>
<tr class="separator:a157a82d35a5d4826c5151c7e8f146607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22debae745bb0fa45a824d9b5e601498"><td class="memTemplParams" colspan="2">template&lt;typename... Ops&gt; </td></tr>
<tr class="memitem:a22debae745bb0fa45a824d9b5e601498"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1parallel__group.html">parallel_group</a>&lt; Ops... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a22debae745bb0fa45a824d9b5e601498">make_parallel_group</a> (Ops... ops)</td></tr>
<tr class="memdesc:a22debae745bb0fa45a824d9b5e601498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a group of operations that may be launched in parallel.  <a href="namespaceasio_1_1experimental.html#a22debae745bb0fa45a824d9b5e601498">Подробнее...</a><br /></td></tr>
<tr class="separator:a22debae745bb0fa45a824d9b5e601498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01364ed6f4cb4ae67b63e43a0808e56"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:aa01364ed6f4cb4ae67b63e43a0808e56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1ranged__parallel__group.html">ranged_parallel_group</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; Range &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#aa01364ed6f4cb4ae67b63e43a0808e56">make_parallel_group</a> (Range &amp;&amp;range, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1experimental_1_1is__async__operation__range.html">is_async_operation_range</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; Range &gt;&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:aa01364ed6f4cb4ae67b63e43a0808e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a group of operations that may be launched in parallel.  <a href="namespaceasio_1_1experimental.html#aa01364ed6f4cb4ae67b63e43a0808e56">Подробнее...</a><br /></td></tr>
<tr class="separator:aa01364ed6f4cb4ae67b63e43a0808e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d46c0113e7168ad74b6ca8b11776f93"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , typename Range &gt; </td></tr>
<tr class="memitem:a8d46c0113e7168ad74b6ca8b11776f93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1ranged__parallel__group.html">ranged_parallel_group</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; Range &gt;, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a8d46c0113e7168ad74b6ca8b11776f93">make_parallel_group</a> (allocator_arg_t, const Allocator &amp;<a class="el" href="classallocator.html">allocator</a>, Range &amp;&amp;range, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1experimental_1_1is__async__operation__range.html">is_async_operation_range</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; Range &gt;&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a8d46c0113e7168ad74b6ca8b11776f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a group of operations that may be launched in parallel.  <a href="namespaceasio_1_1experimental.html#a8d46c0113e7168ad74b6ca8b11776f93">Подробнее...</a><br /></td></tr>
<tr class="separator:a8d46c0113e7168ad74b6ca8b11776f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17de9a3a0372f2dad10fba4fe41d3194"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structasio_1_1experimental_1_1use__coro__t.html">use_coro_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a17de9a3a0372f2dad10fba4fe41d3194">use_coro</a> (0, 0, 0)</td></tr>
<tr class="separator:a17de9a3a0372f2dad10fba4fe41d3194"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Переменные</h2></td></tr>
<tr class="memitem:a229bf7c85d1678e8808e8bc543af3d44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a></td></tr>
<tr class="separator:a229bf7c85d1678e8808e8bc543af3d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4607a9754bf2707c054f0ff16b958b82"><td class="memItemLeft" align="right" valign="top">Executor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a></td></tr>
<tr class="separator:a4607a9754bf2707c054f0ff16b958b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9975daab69c7b93e79ce807410ffb9d9"><td class="memItemLeft" align="right" valign="top">Executor CompletionToken &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a></td></tr>
<tr class="separator:a9975daab69c7b93e79ce807410ffb9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04f505f291ec3b9eb3018fea6835fea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a></td></tr>
<tr class="separator:ac04f505f291ec3b9eb3018fea6835fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6a92f119223e8ce2c565c4c9fa5983"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b6a92f119223e8ce2c565c4c9fa5983"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#a7b6a92f119223e8ce2c565c4c9fa5983">is_promise_v</a> = <a class="el" href="structasio_1_1experimental_1_1is__promise.html">is_promise</a>&lt;<a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>&gt;::value</td></tr>
<tr class="separator:a7b6a92f119223e8ce2c565c4c9fa5983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa827ba54c9e250e7bab4d1fb741cbb94"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structasio_1_1experimental_1_1use__promise__t.html">use_promise_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html#aa827ba54c9e250e7bab4d1fb741cbb94">use_promise</a></td></tr>
<tr class="separator:aa827ba54c9e250e7bab4d1fb741cbb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Типы</h2>
<a id="ab360a432854fdf77bccc3e0079ae3d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab360a432854fdf77bccc3e0079ae3d8d">&#9670;&nbsp;</a></span>channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutorOrSignature , typename... Signatures&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio_1_1experimental.html#ab360a432854fdf77bccc3e0079ae3d8d">asio::experimental::channel</a> = typedef typename <a class="el" href="structasio_1_1experimental_1_1detail_1_1channel__type.html">detail::channel_type</a>&lt; ExecutorOrSignature&gt;::template inner&lt;Signatures...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template type alias for common use of channel. </p>

</div>
</div>
<a id="a33a68f089b90bda97e79ab1855f02b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a68f089b90bda97e79ab1855f02b0d">&#9670;&nbsp;</a></span>concurrent_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutorOrSignature , typename... Signatures&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio_1_1experimental.html#a33a68f089b90bda97e79ab1855f02b0d">asio::experimental::concurrent_channel</a> = typedef typename <a class="el" href="structasio_1_1experimental_1_1detail_1_1concurrent__channel__type.html">detail::concurrent_channel_type</a>&lt; ExecutorOrSignature&gt;::template inner&lt;Signatures...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template type alias for common use of channel. </p>

</div>
</div>
<a id="a73dcb4e54e3f5c2f062180559c76a91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73dcb4e54e3f5c2f062180559c76a91a">&#9670;&nbsp;</a></span>generator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor  = asio::any_io_executor, typename Allocator  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio_1_1experimental.html#a73dcb4e54e3f5c2f062180559c76a91a">asio::experimental::generator</a> = typedef <a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt;<a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generator is a coro that returns void and yields value. </p>

</div>
</div>
<a id="af65ccdddb39d7eb98cbf26d1a8868c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65ccdddb39d7eb98cbf26d1a8868c22">&#9670;&nbsp;</a></span>task</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor  = asio::any_io_executor, typename Allocator  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio_1_1experimental.html#af65ccdddb39d7eb98cbf26d1a8868c22">asio::experimental::task</a> = typedef <a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt;<a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A task is a coro that does not yield values. </p>

</div>
</div>
<h2 class="groupheader">Функции</h2>
<a id="ac40085d70004257598fdc2a80b9a6e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40085d70004257598fdc2a80b9a6e93">&#9670;&nbsp;</a></span>as_single()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1as__single__t.html">as_single_t</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;CompletionToken&gt; &gt; asio::experimental::as_single </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>completion_token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to specify that the completion handler arguments should be combined into a single argument. </p>

</div>
</div>
<a id="ad88bbac9488527afe4a8e0055fcbf6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88bbac9488527afe4a8e0055fcbf6d3">&#9670;&nbsp;</a></span>ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a resumable coroutine. </p>
<p>This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coroutine</td></tr>
    <tr><td class="paramname">token</td><td>The completion token</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Implementation defined </dd></dl>

</div>
</div>
<a id="aac83b8b49276d49470c7a45cdb5eb2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac83b8b49276d49470c7a45cdb5eb2bf">&#9670;&nbsp;</a></span>ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr, <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a resumable coroutine. </p>
<p>This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coroutine</td></tr>
    <tr><td class="paramname">token</td><td>The completion token</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Implementation defined </dd></dl>

</div>
</div>
<a id="a89249a63579083cae4bab8a2513e4a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89249a63579083cae4bab8a2513e4a49">&#9670;&nbsp;</a></span>async_compose&lt; CompletionToken, void(std::exception_ptr)&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return asio::experimental::async_compose&lt; CompletionToken, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr)&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt;{std::move(<a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>)}&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exec&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b3e8c93a15f335b266e14235f20291b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3e8c93a15f335b266e14235f20291b">&#9670;&nbsp;</a></span>async_compose&lt; CompletionToken, void(std::exception_ptr)&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return asio::experimental::async_compose&lt; CompletionToken, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr)&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt;{std::move(<a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>)}&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exec&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7dd4cdae510a6353182475976cb8594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dd4cdae510a6353182475976cb8594">&#9670;&nbsp;</a></span>async_compose&lt; CompletionToken, void(std::exception_ptr, T)&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return asio::experimental::async_compose&lt; CompletionToken, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr, <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>)&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(), <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt;{std::move(<a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>)}&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exec&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1558c3d3b0c140ab3bc99d78d8372ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1558c3d3b0c140ab3bc99d78d8372ed8">&#9670;&nbsp;</a></span>async_compose&lt; CompletionToken, void(std::exception_ptr, T)&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return asio::experimental::async_compose&lt; CompletionToken, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(std::exception_ptr, <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>)&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1detail_1_1coro__spawn__op.html">detail::coro_spawn_op</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt;{std::move(<a class="el" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>)}&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exec&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ff7d9e99424546e76c794c60cb218f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff7d9e99424546e76c794c60cb218f6">&#9670;&nbsp;</a></span>co_composed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;completion_signature... Signatures, typename Implementation , typename... IoObjectsOrExecutors&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::experimental::co_composed </td>
          <td>(</td>
          <td class="paramtype">Implementation &amp;&amp;&#160;</td>
          <td class="paramname"><em>implementation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IoObjectsOrExecutors &amp;&amp;...&#160;</td>
          <td class="paramname"><em>io_objects_or_executors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an initiation function object that may be used to launch a coroutine-based composed asynchronous operation. The <a class="el" href="namespaceasio_1_1experimental.html#a4ff7d9e99424546e76c794c60cb218f6">experimental::co_composed</a> utility simplifies the implementation of composed asynchronous operations by automatically adapting a coroutine to be an initiation function object for use with <code>async_initiate</code>. When awaiting asynchronous operations, the coroutine automatically uses a conforming intermediate completion handler.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">implementation</td><td>A function object that contains the coroutine-based implementation of the composed asynchronous operation. The first argument to the function object represents the state of the operation, and may be used to test for cancellation. The remaining arguments are those passed to <code>async_initiate</code> after the completion token.</td></tr>
    <tr><td class="paramname">io_objects_or_executors</td><td>Zero or more I/O objects or I/O executors for which outstanding work must be maintained while the operation is incomplete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>By default, terminal per-operation cancellation is enabled for composed operations that use <a class="el" href="namespaceasio_1_1experimental.html#a4ff7d9e99424546e76c794c60cb218f6">experimental::co_composed</a>. To disable cancellation for the composed operation, or to alter its supported cancellation types, call the state's <code>reset_cancellation_state</code> function.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The following example illustrates manual error handling and explicit checks for cancellation. The completion handler is invoked via a <code>co_yield</code> to the state's <code>complete</code> function, which never returns.</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionToken&gt;</div>
<div class="line"><span class="keyword">auto</span> async_echo(<a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a>&amp; <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>,</div>
<div class="line">    CompletionToken&amp;&amp; <a class="code" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">asio::async_initiate</a>&lt;</div>
<div class="line">    CompletionToken, <a class="code" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">std::error_code</a>)&gt;(</div>
<div class="line">      <a class="code" href="namespaceasio_1_1experimental.html#a4ff7d9e99424546e76c794c60cb218f6">asio::experimental::co_composed</a>(</div>
<div class="line">        [](<span class="keyword">auto</span> state, <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a>&amp; <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>) -&gt; <span class="keywordtype">void</span></div>
<div class="line">        {</div>
<div class="line">          state.reset_cancellation_state(</div>
<div class="line">            <a class="code" href="structasio_1_1cancellation__filter.html">asio::enable_terminal_cancellation</a>());</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">while</span> (!state.cancelled())</div>
<div class="line">          {</div>
<div class="line">            char data[1024];</div>
<div class="line">            auto [e1, n1] =</div>
<div class="line">              co_await socket.async_read_some(</div>
<div class="line">                asio::buffer(data),</div>
<div class="line">                asio::as_tuple(asio::deferred));</div>
<div class="line"> </div>
<div class="line">            if (e1)</div>
<div class="line">              co_yield state.complete(e1);</div>
<div class="line"> </div>
<div class="line">            if (!!state.cancelled())</div>
<div class="line">              co_yield state.complete(</div>
<div class="line">                make_error_code(asio::error::operation_aborted));</div>
<div class="line"> </div>
<div class="line">            auto [e2, n2] =</div>
<div class="line">              co_await asio::async_write(socket,</div>
<div class="line">                asio::buffer(data, n1),</div>
<div class="line">                asio::as_tuple(asio::deferred));</div>
<div class="line"> </div>
<div class="line">            if (e2)</div>
<div class="line">              co_yield state.complete(e2);</div>
<div class="line">          }</div>
<div class="line">        }, <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>),</div>
<div class="line">      <a class="code" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>, std::ref(<a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>));</div>
<div class="line">} </div>
<div class="ttc" id="anamespaceasio_1_1detail_1_1socket__ops_html_a90aa9a854148c26da8232e25988623d8"><div class="ttname"><a href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">asio::detail::socket_ops::socket</a></div><div class="ttdeci">socket_type socket(int af, int type, int protocol, asio::error_code &amp;ec)</div><div class="ttdef"><b>Definition:</b> socket_ops.ipp:1808</div></div>
<div class="ttc" id="anamespaceasio_1_1experimental_html_a4ff7d9e99424546e76c794c60cb218f6"><div class="ttname"><a href="namespaceasio_1_1experimental.html#a4ff7d9e99424546e76c794c60cb218f6">asio::experimental::co_composed</a></div><div class="ttdeci">auto co_composed(Implementation &amp;&amp;implementation, IoObjectsOrExecutors &amp;&amp;... io_objects_or_executors)</div><div class="ttdef"><b>Definition:</b> co_composed.hpp:1073</div></div>
<div class="ttc" id="anamespaceasio_1_1experimental_html_a9975daab69c7b93e79ce807410ffb9d9"><div class="ttname"><a href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">asio::experimental::token</a></div><div class="ttdeci">Executor CompletionToken &amp;&amp; token</div><div class="ttdef"><b>Definition:</b> co_spawn.hpp:67</div></div>
<div class="ttc" id="anamespaceasio_1_1experimental_html_ac04f505f291ec3b9eb3018fea6835fea"><div class="ttname"><a href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">asio::experimental::void</a></div><div class="ttdeci">void</div><div class="ttdef"><b>Definition:</b> co_spawn.hpp:131</div></div>
<div class="ttc" id="anamespaceasio_html_ac8914468bc40252ae5e5c666adb951cf"><div class="ttname"><a href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a></div><div class="ttdeci">std::error_code error_code</div><div class="ttdef"><b>Definition:</b> error_code.hpp:26</div></div>
<div class="ttc" id="anamespaceasio_html_acbf600e256af39d8a0c65fb6e3eb988d"><div class="ttname"><a href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">asio::async_initiate</a></div><div class="ttdeci">auto async_initiate(Initiation &amp;&amp;initiation, type_identity_t&lt; CompletionToken &gt; &amp;token, Args &amp;&amp;... args) -&gt; constraint_t&lt; detail::async_result_has_initiate_memfn&lt; CompletionToken, Signatures... &gt;::value, decltype(async_result&lt; decay_t&lt; CompletionToken &gt;, Signatures... &gt;::initiate(static_cast&lt; Initiation &amp;&amp; &gt;(initiation), static_cast&lt; CompletionToken &amp;&amp; &gt;(token), static_cast&lt; Args &amp;&amp; &gt;(args)...))&gt;</div><div class="ttdef"><b>Definition:</b> async_result.hpp:558</div></div>
<div class="ttc" id="astructasio_1_1cancellation__filter_html"><div class="ttname"><a href="structasio_1_1cancellation__filter.html">asio::cancellation_filter</a></div><div class="ttdoc">A simple cancellation signal propagation filter.</div><div class="ttdef"><b>Definition:</b> cancellation_state.hpp:32</div></div>
</div><!-- fragment --><p>This next example shows exception-based error handling and implicit checks for cancellation. The completion handler is invoked after returning from the coroutine via <code>co_return</code>. Valid <code>co_return</code> values are specified using completion signatures passed to the <code>co_composed</code> function.</p>
<div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionToken&gt;</div>
<div class="line"><span class="keyword">auto</span> async_echo(<a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a>&amp; <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>,</div>
<div class="line">    CompletionToken&amp;&amp; <a class="code" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">asio::async_initiate</a>&lt;</div>
<div class="line">    CompletionToken, <a class="code" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">std::error_code</a>)&gt;(</div>
<div class="line">      <a class="code" href="namespaceasio_1_1experimental.html#a4ff7d9e99424546e76c794c60cb218f6">asio::experimental::co_composed</a>&lt;</div>
<div class="line">        <a class="code" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">std::error_code</a>)&gt;(</div>
<div class="line">          [](<span class="keyword">auto</span> state, <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a>&amp; <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>) -&gt; <span class="keywordtype">void</span></div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">try</span></div>
<div class="line">            {</div>
<div class="line">              state.throw_if_cancelled(<span class="keyword">true</span>);</div>
<div class="line">              state.reset_cancellation_state(</div>
<div class="line">                <a class="code" href="structasio_1_1cancellation__filter.html">asio::enable_terminal_cancellation</a>());</div>
<div class="line"> </div>
<div class="line">              <span class="keywordflow">for</span> (;;)</div>
<div class="line">              {</div>
<div class="line">                <span class="keywordtype">char</span> data[1024];</div>
<div class="line">                std::size_t n = co_await <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>.async_read_some(</div>
<div class="line">                    <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data), <a class="code" href="namespaceasio.html#a3a930211f940077a2cd1fb88532f9a9d">asio::deferred</a>);</div>
<div class="line"> </div>
<div class="line">                co_await <a class="code" href="namespaceasio.html#a505e7a885317c073053fb7f252cc7b04">asio::async_write</a>(<a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>,</div>
<div class="line">                    <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, n), <a class="code" href="namespaceasio.html#a3a930211f940077a2cd1fb88532f9a9d">asio::deferred</a>);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">std::system_error</a>&amp; e)</div>
<div class="line">            {</div>
<div class="line">              co_return {e.code()};</div>
<div class="line">            }</div>
<div class="line">          }, <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>),</div>
<div class="line">      <a class="code" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>, std::ref(<a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>));</div>
<div class="line">} </div>
<div class="ttc" id="anamespaceasio_html_a3a930211f940077a2cd1fb88532f9a9d"><div class="ttname"><a href="namespaceasio.html#a3a930211f940077a2cd1fb88532f9a9d">asio::deferred</a></div><div class="ttdeci">constexpr deferred_t deferred</div><div class="ttdef"><b>Definition:</b> deferred.hpp:707</div></div>
<div class="ttc" id="anamespaceasio_html_a505e7a885317c073053fb7f252cc7b04"><div class="ttname"><a href="namespaceasio.html#a505e7a885317c073053fb7f252cc7b04">asio::async_write</a></div><div class="ttdeci">auto async_write(AsyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;token, constraint_t&lt; is_const_buffer_sequence&lt; ConstBufferSequence &gt;::value &gt;) -&gt; decltype(async_initiate&lt; WriteToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_write&lt; AsyncWriteStream &gt;&gt;(), token, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</div><div class="ttdef"><b>Definition:</b> write.hpp:469</div></div>
<div class="ttc" id="anamespaceasio_html_ac5e0b6db67d52eba50e168ae78c1a049"><div class="ttname"><a href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></div><div class="ttdeci">std::system_error system_error</div><div class="ttdef"><b>Definition:</b> system_error.hpp:25</div></div>
<div class="ttc" id="anamespaceasio_html_af691d016b23fd6c2da9ac91ce00c2e7e"><div class="ttname"><a href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a></div><div class="ttdeci">ASIO_NODISCARD ASIO_MUTABLE_BUFFER buffer(const mutable_buffer &amp;b) noexcept</div><div class="ttdoc">Create a new modifiable buffer from an existing buffer.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:862</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af580e11a7608adfd35588421fbc592b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af580e11a7608adfd35588421fbc592b3">&#9670;&nbsp;</a></span>co_spawn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::co_spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>() noexcept, <a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>, Executor &gt;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a resumable coroutine. </p>
<p>This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coroutine</td></tr>
    <tr><td class="paramname">token</td><td>The completion token</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Implementation defined </dd></dl>

</div>
</div>
<a id="a157a82d35a5d4826c5151c7e8f146607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157a82d35a5d4826c5151c7e8f146607">&#9670;&nbsp;</a></span>co_spawn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::co_spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1experimental_1_1coro.html">coro</a>&lt; <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>() noexcept, <a class="el" href="namespaceasio_1_1experimental.html#ac04f505f291ec3b9eb3018fea6835fea">void</a>, Executor &gt;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a resumable coroutine. </p>
<p>This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The coroutine</td></tr>
    <tr><td class="paramname">token</td><td>The completion token</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Implementation defined </dd></dl>

</div>
</div>
<a id="a8d46c0113e7168ad74b6ca8b11776f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d46c0113e7168ad74b6ca8b11776f93">&#9670;&nbsp;</a></span>make_parallel_group() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1ranged__parallel__group.html">ranged_parallel_group</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;Range&gt;, Allocator&gt; asio::experimental::make_parallel_group </td>
          <td>(</td>
          <td class="paramtype">allocator_arg_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1experimental_1_1is__async__operation__range.html">is_async_operation_range</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; Range &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a group of operations that may be launched in parallel. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>Specifies the allocator to be used with the result vectors.</td></tr>
    <tr><td class="paramname">range</td><td>A range containing the operations to be launched.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> op_type = decltype(</div>
<div class="line">    socket1.async_read_some(</div>
<div class="line">      <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data1),</div>
<div class="line">      <a class="code" href="namespaceasio.html#a3a930211f940077a2cd1fb88532f9a9d">asio::deferred</a></div>
<div class="line">    )</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">std::vector&lt;op_type&gt; ops;</div>
<div class="line"> </div>
<div class="line">ops.push_back(</div>
<div class="line">    socket1.async_read_some(</div>
<div class="line">      <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data1),</div>
<div class="line">      <a class="code" href="namespaceasio.html#a3a930211f940077a2cd1fb88532f9a9d">asio::deferred</a></div>
<div class="line">    )</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">ops.push_back(</div>
<div class="line">    socket2.async_read_some(</div>
<div class="line">      <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data2),</div>
<div class="line">      <a class="code" href="namespaceasio.html#a3a930211f940077a2cd1fb88532f9a9d">asio::deferred</a></div>
<div class="line">    )</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceasio_1_1experimental.html#a22debae745bb0fa45a824d9b5e601498">asio::experimental::make_parallel_group</a>(</div>
<div class="line">    std::allocator_arg_t,</div>
<div class="line">    my_allocator,</div>
<div class="line">    ops</div>
<div class="line">  ).async_wait(</div>
<div class="line">    <a class="code" href="classasio_1_1experimental_1_1wait__for__all.html">asio::experimental::wait_for_all</a>(),</div>
<div class="line">    [](</div>
<div class="line">        std::vector&lt;std::size_t&gt; completion_order,</div>
<div class="line">        std::vector&lt;std::error_code&gt; e,</div>
<div class="line">        std::vector&lt;std::size_t&gt; n</div>
<div class="line">      )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; completion_order.size(); ++i)</div>
<div class="line">      {</div>
<div class="line">        std::size_t idx = completion_order[i];</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;socket &quot;</span> &lt;&lt; idx &lt;&lt; <span class="stringliteral">&quot; finished: &quot;</span>;</div>
<div class="line">        std::cout &lt;&lt; e[idx] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; n[idx] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  );</div>
<div class="ttc" id="aclassasio_1_1experimental_1_1wait__for__all_html"><div class="ttname"><a href="classasio_1_1experimental_1_1wait__for__all.html">asio::experimental::wait_for_all</a></div><div class="ttdoc">Wait for all operations to complete.</div><div class="ttdef"><b>Definition:</b> cancellation_condition.hpp:31</div></div>
<div class="ttc" id="anamespaceasio_1_1experimental_html_a22debae745bb0fa45a824d9b5e601498"><div class="ttname"><a href="namespaceasio_1_1experimental.html#a22debae745bb0fa45a824d9b5e601498">asio::experimental::make_parallel_group</a></div><div class="ttdeci">ASIO_NODISCARD parallel_group&lt; Ops... &gt; make_parallel_group(Ops... ops)</div><div class="ttdoc">Create a group of operations that may be launched in parallel.</div><div class="ttdef"><b>Definition:</b> parallel_group.hpp:244</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a22debae745bb0fa45a824d9b5e601498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22debae745bb0fa45a824d9b5e601498">&#9670;&nbsp;</a></span>make_parallel_group() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ops&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1parallel__group.html">parallel_group</a>&lt;Ops...&gt; asio::experimental::make_parallel_group </td>
          <td>(</td>
          <td class="paramtype">Ops...&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a group of operations that may be launched in parallel. </p>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="namespaceasio_1_1experimental.html#a22debae745bb0fa45a824d9b5e601498">asio::experimental::make_parallel_group</a>(</div>
<div class="line">  [&amp;](<span class="keyword">auto</span> <a class="code" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> in.async_read_some(<a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data), <a class="code" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>);</div>
<div class="line">  },</div>
<div class="line">  [&amp;](<span class="keyword">auto</span> <a class="code" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>.async_wait(<a class="code" href="namespaceasio_1_1experimental.html#a9975daab69c7b93e79ce807410ffb9d9">token</a>);</div>
<div class="line">  }</div>
<div class="line">).async_wait(</div>
<div class="line">  <a class="code" href="classasio_1_1experimental_1_1wait__for__all.html">asio::experimental::wait_for_all</a>(),</div>
<div class="line">  [](</div>
<div class="line">      std::array&lt;std::size_t, 2&gt; completion_order,</div>
<div class="line">      <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">std::error_code</a> ec1, std::size_t <a class="code" href="blocking_8cpp.html#a055ae01cc3681d2bed68e4a9ca84dd93">n1</a>,</div>
<div class="line">      <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">std::error_code</a> ec2</div>
<div class="line">  )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">switch</span> (completion_order[0])</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> 0:</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;descriptor finished: &quot;</span> &lt;&lt; ec1 &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code" href="blocking_8cpp.html#a055ae01cc3681d2bed68e4a9ca84dd93">n1</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 1:</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;timer finished: &quot;</span> &lt;&lt; ec2 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">);</div>
<div class="ttc" id="abind__allocator_8cpp_html_af1abddd6ed87a43a672d1f851b84a694"><div class="ttname"><a href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a></div><div class="ttdeci">steady_timer timer</div><div class="ttdef"><b>Definition:</b> bind_allocator.cpp:37</div></div>
<div class="ttc" id="ablocking_8cpp_html_a055ae01cc3681d2bed68e4a9ca84dd93"><div class="ttname"><a href="blocking_8cpp.html#a055ae01cc3681d2bed68e4a9ca84dd93">n1</a></div><div class="ttdeci">exec::blocking_t::possibly_t n1</div><div class="ttdef"><b>Definition:</b> blocking.cpp:27</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa01364ed6f4cb4ae67b63e43a0808e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01364ed6f4cb4ae67b63e43a0808e56">&#9670;&nbsp;</a></span>make_parallel_group() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1experimental_1_1ranged__parallel__group.html">ranged_parallel_group</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;Range&gt; &gt; asio::experimental::make_parallel_group </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1experimental_1_1is__async__operation__range.html">is_async_operation_range</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; Range &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a group of operations that may be launched in parallel. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>A range containing the operations to be launched.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> op_type = decltype(</div>
<div class="line">    socket1.async_read_some(</div>
<div class="line">      <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data1),</div>
<div class="line">      <a class="code" href="namespaceasio.html#a3a930211f940077a2cd1fb88532f9a9d">asio::deferred</a></div>
<div class="line">    )</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">std::vector&lt;op_type&gt; ops;</div>
<div class="line"> </div>
<div class="line">ops.push_back(</div>
<div class="line">    socket1.async_read_some(</div>
<div class="line">      <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data1),</div>
<div class="line">      <a class="code" href="namespaceasio.html#a3a930211f940077a2cd1fb88532f9a9d">asio::deferred</a></div>
<div class="line">    )</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">ops.push_back(</div>
<div class="line">    socket2.async_read_some(</div>
<div class="line">      <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data2),</div>
<div class="line">      <a class="code" href="namespaceasio.html#a3a930211f940077a2cd1fb88532f9a9d">asio::deferred</a></div>
<div class="line">    )</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceasio_1_1experimental.html#a22debae745bb0fa45a824d9b5e601498">asio::experimental::make_parallel_group</a>(ops).async_wait(</div>
<div class="line">    <a class="code" href="classasio_1_1experimental_1_1wait__for__all.html">asio::experimental::wait_for_all</a>(),</div>
<div class="line">    [](</div>
<div class="line">        std::vector&lt;std::size_t&gt; completion_order,</div>
<div class="line">        std::vector&lt;std::error_code&gt; e,</div>
<div class="line">        std::vector&lt;std::size_t&gt; n</div>
<div class="line">      )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; completion_order.size(); ++i)</div>
<div class="line">      {</div>
<div class="line">        std::size_t idx = completion_order[i];</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;socket &quot;</span> &lt;&lt; idx &lt;&lt; <span class="stringliteral">&quot; finished: &quot;</span>;</div>
<div class="line">        std::cout &lt;&lt; e[idx] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; n[idx] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  );</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a17de9a3a0372f2dad10fba4fe41d3194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17de9a3a0372f2dad10fba4fe41d3194">&#9670;&nbsp;</a></span>use_coro()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structasio_1_1experimental_1_1use__coro__t.html">use_coro_t</a> asio::experimental::use_coro </td>
          <td>(</td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A completion_token object that represents the currently executing resumable coroutine. See the documentation for asio::use_coro_t for a usage example. </p>

</div>
</div>
<h2 class="groupheader">Переменные</h2>
<a id="a4607a9754bf2707c054f0ff16b958b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4607a9754bf2707c054f0ff16b958b82">&#9670;&nbsp;</a></span>c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor asio::experimental::c</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b6a92f119223e8ce2c565c4c9fa5983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6a92f119223e8ce2c565c4c9fa5983">&#9670;&nbsp;</a></span>is_promise_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool asio::experimental::is_promise_v = <a class="el" href="structasio_1_1experimental_1_1is__promise.html">is_promise</a>&lt;<a class="el" href="namespaceasio_1_1experimental.html#a229bf7c85d1678e8808e8bc543af3d44">T</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a229bf7c85d1678e8808e8bc543af3d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229bf7c85d1678e8808e8bc543af3d44">&#9670;&nbsp;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9975daab69c7b93e79ce807410ffb9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9975daab69c7b93e79ce807410ffb9d9">&#9670;&nbsp;</a></span>token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor CompletionToken &amp;&amp; asio::experimental::token</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Инициализатор</b><div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> <a class="code" href="namespaceasio_1_1execution.html">exec</a> = <a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>.get_executor()</div>
<div class="ttc" id="anamespaceasio_1_1execution_html"><div class="ttname"><a href="namespaceasio_1_1execution.html">asio::execution</a></div><div class="ttdef"><b>Definition:</b> handler_work.hpp:46</div></div>
<div class="ttc" id="anamespaceasio_1_1experimental_html_a4607a9754bf2707c054f0ff16b958b82"><div class="ttname"><a href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">asio::experimental::c</a></div><div class="ttdeci">Executor c</div><div class="ttdef"><b>Definition:</b> co_spawn.hpp:66</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa827ba54c9e250e7bab4d1fb741cbb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa827ba54c9e250e7bab4d1fb741cbb94">&#9670;&nbsp;</a></span>use_promise</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structasio_1_1experimental_1_1use__promise__t.html">use_promise_t</a> asio::experimental::use_promise</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac04f505f291ec3b9eb3018fea6835fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04f505f291ec3b9eb3018fea6835fea">&#9670;&nbsp;</a></span>void</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::experimental::void</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
