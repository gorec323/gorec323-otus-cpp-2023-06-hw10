<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bulk_server: Пространство имен asio</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bulk_server
   &#160;<span id="projectnumber">0.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Пространства имен</a> &#124;
<a href="#nested-classes">Классы</a> &#124;
<a href="#typedef-members">Определения типов</a> &#124;
<a href="#enum-members">Перечисления</a> &#124;
<a href="#func-members">Функции</a> &#124;
<a href="#var-members">Переменные</a>  </div>
  <div class="headertitle">
<div class="title">Пространство имен asio</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Пространства имен</h2></td></tr>
<tr class="memitem:namespaceasio_1_1buffer__literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1buffer__literals.html">buffer_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1chrono"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1chrono.html">chrono</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1error"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1error.html">error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1execution"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1execution.html">execution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1generic"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1generic.html">generic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1ip"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1ip.html">ip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1placeholders"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1resolver__errc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1resolver__errc.html">resolver_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1socket__errc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1socket__errc.html">socket_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1ssl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1ssl.html">ssl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1stream__errc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1stream__errc.html">stream_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1this__coro"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1this__coro.html">this_coro</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1traits.html">traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Классы</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1any__completion__executor.html">any_completion_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic executor type for use with I/O objects.  <a href="classasio_1_1any__completion__executor.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1any__completion__handler.html">any_completion_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic wrapper for completion handlers.  <a href="classasio_1_1any__completion__handler.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1any__completion__handler__allocator.html">any_completion_handler_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1any__completion__handler__allocator_3_01void_00_01Signatures_8_8_8_01_4.html">any_completion_handler_allocator&lt; void, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01any__completion__handler_3_01Signatures_8_8_8_01_4_00_01Candidate_01_4.html">associated_executor&lt; any_completion_handler&lt; Signatures... &gt;, Candidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__immediate__executor_3_01any__completion__handler_3_01Signatures_8_8_8_01_4_00_01Candidate_01_4.html">associated_immediate_executor&lt; any_completion_handler&lt; Signatures... &gt;, Candidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1any__io__executor.html">any_io_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic executor type for use with I/O objects.  <a href="classasio_1_1any__io__executor.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1append__t.html">append_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1as__tuple__t.html">as_tuple_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the allocator associated with an object.  <a href="structasio_1_1associated__allocator.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01reference__wrapper_3_01T_01_4_00_01Allocator_01_4.html">associated_allocator&lt; reference_wrapper&lt; T &gt;, Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structasio_1_1associated__allocator.html" title="Traits type used to obtain the allocator associated with an object.">associated_allocator</a> for <code>std::reference_wrapper</code>.  <a href="structasio_1_1associated__allocator_3_01reference__wrapper_3_01T_01_4_00_01Allocator_01_4.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the <a class="el" href="classasio_1_1cancellation__slot.html" title="A slot associated with a cancellation signal.">cancellation_slot</a> associated with an object.  <a href="structasio_1_1associated__cancellation__slot.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__cancellation__slot_3_01reference__wrapper_3_01T_01_4_00_01CancellationSlot_01_4.html">associated_cancellation_slot&lt; reference_wrapper&lt; T &gt;, CancellationSlot &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the executor associated with an object.  <a href="structasio_1_1associated__executor.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01reference__wrapper_3_01T_01_4_00_01Executor_01_4.html">associated_executor&lt; reference_wrapper&lt; T &gt;, Executor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structasio_1_1associated__executor.html" title="Traits type used to obtain the executor associated with an object.">associated_executor</a> for <code>std::reference_wrapper</code>.  <a href="structasio_1_1associated__executor_3_01reference__wrapper_3_01T_01_4_00_01Executor_01_4.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the immediate executor associated with an object.  <a href="structasio_1_1associated__immediate__executor.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__immediate__executor_3_01reference__wrapper_3_01T_01_4_00_01Executor_01_4.html">associated_immediate_executor&lt; reference_wrapper&lt; T &gt;, Executor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator.html">associator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to generically specialise associators for a type.  <a href="structasio_1_1associator.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result.html">async_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01void_00_01Signatures_8_8_8_01_4.html">async_result&lt; void, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__completion.html">async_completion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1async__operation__probe_00_01Signatures_8_8_8_01_4.html">async_result&lt; detail::async_operation_probe, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__async__operation.html">is_async_operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1completion__signature__probe_00_01Signatures_8_8_8_01_4.html">async_result&lt; detail::completion_signature_probe, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1completion__signature__probe_00_01Signature_01_4.html">async_result&lt; detail::completion_signature_probe, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1completion__signature__of.html">completion_signature_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1default__completion__token.html">default_completion_token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__datagram__socket.html">basic_datagram_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides datagram-oriented socket functionality.  <a href="classasio_1_1basic__datagram__socket.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__io__object.html">basic_io_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all I/O objects.  <a href="classasio_1_1basic__io__object.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__io__object_3_01IoObjectService_00_01true_01_4.html">basic_io_object&lt; IoObjectService, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__raw__socket.html">basic_raw_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides raw-oriented socket functionality.  <a href="classasio_1_1basic__raw__socket.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__seq__packet__socket.html">basic_seq_packet_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides sequenced packet socket functionality.  <a href="classasio_1_1basic__seq__packet__socket.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides signal functionality.  <a href="classasio_1_1basic__signal__set.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides socket functionality.  <a href="classasio_1_1basic__socket.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the ability to accept new connections.  <a href="classasio_1_1basic__socket__acceptor.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__iostream.html">basic_socket_iostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iostream interface for a socket.  <a href="classasio_1_1basic__socket__iostream.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__streambuf.html">basic_socket_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iostream streambuf for a socket.  <a href="classasio_1_1basic__socket__streambuf.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__stream__socket.html">basic_stream_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides stream-oriented socket functionality.  <a href="classasio_1_1basic__stream__socket.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically resizable buffer class based on std::streambuf.  <a href="classasio_1_1basic__streambuf.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> to the dynamic buffer sequence type requirements.  <a href="classasio_1_1basic__streambuf__ref.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides waitable timer functionality.  <a href="classasio_1_1basic__waitable__timer.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1allocator__binder.html">allocator_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01allocator__binder_3_01T_00_01Allocator_01_4_00_01Signature_01_4.html">async_result&lt; allocator_binder&lt; T, Allocator &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01allocator__binder_3_01T_00_01Allocator_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, allocator_binder&lt; T, Allocator &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01allocator__binder_3_01T_00_01Allocator_01_4_00_01Allocator1_01_4.html">associated_allocator&lt; allocator_binder&lt; T, Allocator &gt;, Allocator1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancellation__slot__binder.html">cancellation_slot_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01cancellation__slot__binder_3_01T_00_01CancellationSlot_01_4_00_01Signature_01_4.html">async_result&lt; cancellation_slot_binder&lt; T, CancellationSlot &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01cancellation__slot__binder_3_01T_00_01CancellationS16ea2030429147662159ab5b8b8c10ce.html">associator&lt; Associator, cancellation_slot_binder&lt; T, CancellationSlot &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__cancellation__slot_3_01cancellation__slot__binder_3_01T_00_01Cancellatc4eed5d80dfb03900583a9d9e232507b.html">associated_cancellation_slot&lt; cancellation_slot_binder&lt; T, CancellationSlot &gt;, CancellationSlot1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1uses__executor_3_01executor__binder_3_01T_00_01Executor_01_4_00_01Executor_01_4.html">uses_executor&lt; executor_binder&lt; T, Executor &gt;, Executor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01executor__binder_3_01T_00_01Executor_01_4_00_01Signature_01_4.html">async_result&lt; executor_binder&lt; T, Executor &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01executor__binder_3_01T_00_01Executor_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, executor_binder&lt; T, Executor &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01executor__binder_3_01T_00_01Executor_01_4_00_01Executor1_01_4.html">associated_executor&lt; executor_binder&lt; T, Executor &gt;, Executor1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1immediate__executor__binder.html">immediate_executor_binder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01immediate__executor__binder_3_01T_00_01Executor_01_4_00_01Signature_01_4.html">async_result&lt; immediate_executor_binder&lt; T, Executor &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01immediate__executor__binder_3_01T_00_01Executor_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, immediate_executor_binder&lt; T, Executor &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__immediate__executor_3_01immediate__executor__binder_3_01T_00_01Executor_01_4_00_01Executor1_01_4.html">associated_immediate_executor&lt; immediate_executor_binder&lt; T, Executor &gt;, Executor1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a buffer that can be modified.  <a href="classasio_1_1mutable__buffer.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a buffer that cannot be modified.  <a href="classasio_1_1const__buffer.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1null__buffers.html">null_buffers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a basic_string to the DynamicBuffer requirements.  <a href="classasio_1_1dynamic__string__buffer.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a vector to the DynamicBuffer requirements.  <a href="classasio_1_1dynamic__vector__buffer.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to determine whether a type satisfies the DynamicBuffer requirements.  <a href="structasio_1_1is__dynamic__buffer.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically registers and unregistered buffers with an execution context.  <a href="classasio_1_1buffer__registration.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__read__stream.html">buffered_read_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the read-related operations of a stream.  <a href="classasio_1_1buffered__read__stream.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__stream.html">buffered_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the read- and write-related operations of a stream.  <a href="classasio_1_1buffered__stream.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__write__stream.html">buffered_write_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the write-related operations of a stream.  <a href="classasio_1_1buffered__write__stream.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random access iterator over the bytes in a buffer sequence.  <a href="classasio_1_1buffers__iterator.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancellation__signal.html">cancellation_signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cancellation signal with a single slot.  <a href="classasio_1_1cancellation__signal.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancellation__slot.html">cancellation_slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot associated with a cancellation signal.  <a href="classasio_1_1cancellation__slot.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple cancellation signal propagation filter.  <a href="structasio_1_1cancellation__filter.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1cancellation__state.html">cancellation_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cancellation state is used for chaining signals and slots in compositions.  <a href="classasio_1_1cancellation__state.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1composed__op_3_01Impl_00_01Work_00_01Handd2b60f25858fe2b2c8fde81f2d2191d6.html">associator&lt; Associator, detail::composed_op&lt; Impl, Work, Handler, Signature &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1consign__t.html">consign_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1coroutine.html">coroutine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides support for implementing stackless coroutines.  <a href="classasio_1_1coroutine.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred.html">is_deferred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait for detecting objects that are usable as deferred operations.  <a href="structasio_1_1is__deferred.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1deferred__signatures.html">deferred_signatures</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to wrap multiple completion signatures.  <a href="structasio_1_1deferred__signatures.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1deferred__noop.html">deferred_noop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to represent an empty deferred action.  <a href="structasio_1_1deferred__noop.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__noop_01_4.html">is_deferred&lt; deferred_noop &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1deferred__init__tag.html">deferred_init_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type to disambiguate deferred constructors.  <a href="structasio_1_1deferred__init__tag.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__function.html">deferred_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__function_3_01Function_01_4_01_4.html">is_deferred&lt; deferred_function&lt; Function &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__values.html">deferred_values</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates deferred values.  <a href="classasio_1_1deferred__values.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__values_3_01Values_8_8_8_01_4_01_4.html">is_deferred&lt; deferred_values&lt; Values... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__async__operation.html">deferred_async_operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a deferred asynchronous operation.  <a href="classasio_1_1deferred__async__operation.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__async__operation_3_01deferred__signatures_3_01Signatures_8_8_8_01_4_00_01d2f4f46bc21d724b8f906416eaee9202.html">deferred_async_operation&lt; deferred_signatures&lt; Signatures... &gt;, Initiation, InitArgs... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__async__operation_3_01Signature_00_01Initiation_00_01InitArgs_8_8_8_01_4_01_4.html">is_deferred&lt; deferred_async_operation&lt; Signature, Initiation, InitArgs... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__sequence.html">deferred_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a link between two consecutive operations in a sequence.  <a href="classasio_1_1deferred__sequence.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__sequence_3_01Head_00_01Tail_01_4_01_4.html">is_deferred&lt; deferred_sequence&lt; Head, Tail &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__conditional.html">deferred_conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to represent a deferred conditional branch.  <a href="classasio_1_1deferred__conditional.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__deferred_3_01deferred__conditional_3_01OnTrue_00_01OnFalse_01_4_01_4.html">is_deferred&lt; deferred_conditional&lt; OnTrue, OnFalse &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1deferred__t.html">deferred_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1detached__t.html">detached_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder0_3_01Handler_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::binder0&lt; Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder1_3_01Handler_00_01Arg1_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::binder1&lt; Handler, Arg1 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder2_3_01Handler_00_01Arg1_00_01Arg2_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::binder2&lt; Handler, Arg1, Arg2 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder3_3_01Handler_00_01Arg1_00_01Arg2_09bd080fd76ec8145f6601d8c51453d64.html">associator&lt; Associator, detail::binder3&lt; Handler, Arg1, Arg2, Arg3 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder4_3_01Handler_00_01Arg1_00_01Arg2_050a4bed10c672931b90c89a21fe59188.html">associator&lt; Associator, detail::binder4&lt; Handler, Arg1, Arg2, Arg3, Arg4 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1binder5_3_01Handler_00_01Arg1_00_01Arg2_04cb1e404b95af920a52ae3dbe213b42d.html">associator&lt; Associator, detail::binder5&lt; Handler, Arg1, Arg2, Arg3, Arg4, Arg5 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1move__binder1_3_01Handler_00_01Arg1_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::move_binder1&lt; Handler, Arg1 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1move__binder2_3_01Handler_00_01Arg1_00_0161eaa9a35134749d6d6c28bae505d8f5.html">associator&lt; Associator, detail::move_binder2&lt; Handler, Arg1, Arg2 &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1aligned__storage.html">aligned_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1void__type.html">void_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1conjunction.html">conjunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1conjunction_3_01T_01_4.html">conjunction&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1conjunction_3_01Head_00_01Tail_8_8_8_01_4.html">conjunction&lt; Head, Tail... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1constraint.html">constraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1type__identity.html">type_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1allocator__t_3_01ProtoAllocator_01_4_01_4.html">is_applicable_property&lt; T, execution::allocator_t&lt; ProtoAllocator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__t_01_4.html">is_applicable_property&lt; T, execution::blocking_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__t_1_1possibly__t_01_4.html">is_applicable_property&lt; T, execution::blocking_t::possibly_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__t_1_1always__t_01_4.html">is_applicable_property&lt; T, execution::blocking_t::always_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__t_1_1never__t_01_4.html">is_applicable_property&lt; T, execution::blocking_t::never_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__adaptation__t_01_4.html">is_applicable_property&lt; T, execution::blocking_adaptation_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__adaptation__t_1_1disallowed__t_01_4.html">is_applicable_property&lt; T, execution::blocking_adaptation_t::disallowed_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1blocking__adaptation__t_1_1allowed__t_01_4.html">is_applicable_property&lt; T, execution::blocking_adaptation_t::allowed_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1context__t_01_4.html">is_applicable_property&lt; T, execution::context_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1context__as__t_3_01U_01_4_01_4.html">is_applicable_property&lt; T, execution::context_as_t&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1mapping__t_01_4.html">is_applicable_property&lt; T, execution::mapping_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1mapping__t_1_1thread__t_01_4.html">is_applicable_property&lt; T, execution::mapping_t::thread_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1mapping__t_1_1new__thread__t_01_4.html">is_applicable_property&lt; T, execution::mapping_t::new_thread_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1mapping__t_1_1other__t_01_4.html">is_applicable_property&lt; T, execution::mapping_t::other_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1occupancy__t_01_4.html">is_applicable_property&lt; T, execution::occupancy_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1outstanding__work__t_01_4.html">is_applicable_property&lt; T, execution::outstanding_work_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1outstanding__work__t_1_1untracked__t_01_4.html">is_applicable_property&lt; T, execution::outstanding_work_t::untracked_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1outstanding__work__t_1_1tracked__t_01_4.html">is_applicable_property&lt; T, execution::outstanding_work_t::tracked_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1prefer__only_3_01InnerProperty_01_4_01_4.html">is_applicable_property&lt; T, execution::prefer_only&lt; InnerProperty &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1relationship__t_01_4.html">is_applicable_property&lt; T, execution::relationship_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1relationship__t_1_1fork__t_01_4.html">is_applicable_property&lt; T, execution::relationship_t::fork_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01T_00_01execution_1_1relationship__t_1_1continuation__t_01_4.html">is_applicable_property&lt; T, execution::relationship_t::continuation_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1execution__context.html">execution_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context for function object execution.  <a href="classasio_1_1execution__context.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1service__already__exists.html">service_already_exists</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1invalid__service__owner.html">invalid_service_owner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1bad__executor.html">bad_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when trying to access an empty polymorphic executor.  <a href="classasio_1_1bad__executor.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor.html">executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic wrapper for executors.  <a href="classasio_1_1executor.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__work__guard_3_01Executor_00_01enable__if__t_3_01is__executor_3_01Executor_01_4_1_1value_01_4_01_4.html">executor_work_guard&lt; Executor, enable_if_t&lt; is_executor&lt; Executor &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__work__guard_3_01Executor_00_01enable__if__t_3_01_9is__executor_3_01Execut25e5ea9994b9460d12280043f650d2a0.html">executor_work_guard&lt; Executor, enable_if_t&lt; !is_executor&lt; Executor &gt;::value &gt;, enable_if_t&lt; execution::is_executor&lt; Executor &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01experimental_1_1detail_1_1channel__handler_3_01Payl2b6772b0f1ebfef7cbcbdbd6b329de9b.html">associator&lt; Associator, experimental::detail::channel_handler&lt; Payload, Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1as__single__t_3_01CompletionToken_01_4_00_01Signature_01_4.html">async_result&lt; experimental::as_single_t&lt; CompletionToken &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01experimental_1_1detail_1_1as__single__handler_3_01H6c2fad8b25c05174c255b98fc93985b6.html">associator&lt; Associator, experimental::detail::as_single_handler&lt; Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01experimental_1_1detail_1_1co__composed__handler_3_0a338e5a6a8ccd00ac74b1b90a683b7ae.html">associator&lt; Associator, experimental::detail::co_composed_handler&lt; Executors, Handler, Return, Signature &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01experimental_1_1detail_1_1parallel__group__completi0ef89a80519f57ed7ecef86848b30d67.html">associator&lt; Associator, experimental::detail::parallel_group_completion_handler&lt; Handler, Ops... &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01experimental_1_1detail_1_1ranged__parallel__group__527bebfad597413b545f18618fcaed86.html">associator&lt; Associator, experimental::detail::ranged_parallel_group_completion_handler&lt; Handler, Op, Allocator &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__coro__t_3_01Allocator_01_4_00_01R_07asio_1_1error__code_08_4.html">async_result&lt; experimental::use_coro_t&lt; Allocator &gt;, R(asio::error_code)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__coro__t_3_01Allocator_01_4_00_01R_07std_1_1exception__ptr_08_4.html">async_result&lt; experimental::use_coro_t&lt; Allocator &gt;, R(std::exception_ptr)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__coro__t_3_01Allocator_01_4_00_01R_07T_08_4.html">async_result&lt; experimental::use_coro_t&lt; Allocator &gt;, R(T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__coro__t_3_01Allocator_01_4_00_01R_07asio_1_1error__code_00_01T_08_4.html">async_result&lt; experimental::use_coro_t&lt; Allocator &gt;, R(asio::error_code, T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__coro__t_3_01Allocator_01_4_00_01R_07std_1_1exception__ptr_00_01T_08_4.html">async_result&lt; experimental::use_coro_t&lt; Allocator &gt;, R(std::exception_ptr, T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01experimental_1_1use__promise__t_3_01Allocator_01_4_00_01R_07Args_8_8_8_08_4.html">async_result&lt; experimental::use_promise_t&lt; Allocator &gt;, R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01append__t_3_01CompletionToken_00_01Values_8_8_8_01_4_00_01Signature_01_4.html">async_result&lt; append_t&lt; CompletionToken, Values... &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1append__handler_3_01Handler_00_01Values_87e9d01edec3ae13439b7689dbbbc8f93.html">associator&lt; Associator, detail::append_handler&lt; Handler, Values... &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01as__tuple__t_3_01CompletionToken_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; as_tuple_t&lt; CompletionToken &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1as__tuple__handler_3_01Handler_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::as_tuple_handler&lt; Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1buffered__fill__handler_3_01ReadHandler_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::buffered_fill_handler&lt; ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1buffered__read__some__handler_3_01Mutableba928f90a91172ec6479f165f9f87b22.html">associator&lt; Associator, detail::buffered_read_some_handler&lt; MutableBufferSequence, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1buffered__flush__handler_3_01WriteHandlerd7dd930bacfe01efde8eec04549b422a.html">associator&lt; Associator, detail::buffered_flush_handler&lt; WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1buffered__write__some__handler_3_01ConstBdf8856a81aa37eac88005d61d2d05cd0.html">associator&lt; Associator, detail::buffered_write_some_handler&lt; ConstBufferSequence, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1range__connect__op_3_01Protocol_00_01Exec6610d253133b2f33c529aa6911687715.html">associator&lt; Associator, detail::range_connect_op&lt; Protocol, Executor, EndpointSequence, ConnectCondition, RangeConnectHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1iterator__connect__op_3_01Protocol_00_01Ed9e7e0bf65755c467a79770b2d60914f.html">associator&lt; Associator, detail::iterator_connect_op&lt; Protocol, Executor, Iterator, ConnectCondition, IteratorConnectHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01consign__t_3_01CompletionToken_00_01Values_8_8_8_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; consign_t&lt; CompletionToken, Values... &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1consign__handler_3_01Handler_00_01Values_ce7a72adc63608e4116ab6d39c342dd0.html">associator&lt; Associator, detail::consign_handler&lt; Handler, Values... &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01deferred__t_00_01Signature_01_4.html">async_result&lt; deferred_t, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01deferred__t_00_01Signatures_8_8_8_01_4.html">async_result&lt; deferred_t, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01deferred__function_3_01Function_01_4_00_01Signature_01_4.html">async_result&lt; deferred_function&lt; Function &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01deferred__function_3_01Function_01_4_00_01Signatures_8_8_8_01_4.html">async_result&lt; deferred_function&lt; Function &gt;, Signatures... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1deferred__sequence__handler_3_01Handler_09755d84f2556cfea0d01de4e9c435368.html">associator&lt; Associator, detail::deferred_sequence_handler&lt; Handler, Tail &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01detached__t_00_01Signature_01_4.html">async_result&lt; detached_t, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1io__context.html">io_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides core I/O functionality.  <a href="classasio_1_1io__context.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01prepend__t_3_01CompletionToken_00_01Values_8_8_8_01_4_00_01Signature_01_4.html">async_result&lt; prepend_t&lt; CompletionToken, Values... &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1prepend__handler_3_01Handler_00_01Values_b046c901742e13ade848eaa1fbf82d94.html">associator&lt; Associator, detail::prepend_handler&lt; Handler, Values... &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__op_3_01AsyncReadStream_00_01Mutable43249ffb3ae8e7023069da5aec3be814.html">associator&lt; Associator, detail::read_op&lt; AsyncReadStream, MutableBufferSequence, MutableBufferIterator, CompletionCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__dynbuf__v1__op_3_01AsyncReadStream_26756f839f25e64de26021382dd49ec3.html">associator&lt; Associator, detail::read_dynbuf_v1_op&lt; AsyncReadStream, DynamicBuffer_v1, CompletionCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__dynbuf__v2__op_3_01AsyncReadStream_6819db99172d8e4b09407e94635a6a19.html">associator&lt; Associator, detail::read_dynbuf_v2_op&lt; AsyncReadStream, DynamicBuffer_v2, CompletionCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__at__op_3_01AsyncRandomAccessReadDevcef155d55787c8da333a4ae885d8c727.html">associator&lt; Associator, detail::read_at_op&lt; AsyncRandomAccessReadDevice, MutableBufferSequence, MutableBufferIterator, CompletionCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__at__streambuf__op_3_01AsyncRandomAcecfa833cd2087a0c50e518c0c4625908.html">associator&lt; Associator, detail::read_at_streambuf_op&lt; AsyncRandomAccessReadDevice, Executor, CompletionCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__delim__op__v1_3_01AsyncReadSa7be94242e84ee491d0d4a039a7e0e3b.html">associator&lt; Associator, detail::read_until_delim_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__delim__string__op__v1_3_01As57d02d712a24211631cb0d0c67c501be.html">associator&lt; Associator, detail::read_until_delim_string_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__match__op__v1_3_01AsyncReadSb6f2f976d5232ce652ebe6841f0b066e.html">associator&lt; Associator, detail::read_until_match_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, MatchCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__delim__op__v2_3_01AsyncReadSaea4defad4ab6a119013ead28c062191.html">associator&lt; Associator, detail::read_until_delim_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__delim__string__op__v2_3_01As8f406661583e15aabe3248142c1de8af.html">associator&lt; Associator, detail::read_until_delim_string_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1read__until__match__op__v2_3_01AsyncReadScf5b8f0a27806f899ea1b5e1baa8231d.html">associator&lt; Associator, detail::read_until_match_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, MatchCondition, ReadHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01redirect__error__t_3_01CompletionToken_01_4_00_01Signature_01_4.html">async_result&lt; redirect_error_t&lt; CompletionToken &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1redirect__error__handler_3_01Handler_01_4_00_01DefaultCandidate_01_4.html">associator&lt; Associator, detail::redirect_error_handler&lt; Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01basic__yield__context_3_01Executor_01_4_00_01Signature_01_4.html">async_result&lt; basic_yield_context&lt; Executor &gt;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1thread__pool.html">thread_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple fixed-size thread pool.  <a href="classasio_1_1thread__pool.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01use__awaitable__t_3_01Executor_01_4_00_01R_07Args_8_8_8_08_4.html">async_result&lt; use_awaitable_t&lt; Executor &gt;, R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01use__future__t_3_01Allocator_01_4_00_01Result_07Args_8_8_8_08_4.html">async_result&lt; use_future_t&lt; Allocator &gt;, Result(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1packaged__token_3_01Function_00_01Allocator_01_4_00_01Result_07Args_8_8_8_08_4.html">async_result&lt; detail::packaged_token&lt; Function, Allocator &gt;, Result(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1write__op_3_01AsyncWriteStream_00_01Const945952beb6b88739ce3f365bd57fcec3.html">associator&lt; Associator, detail::write_op&lt; AsyncWriteStream, ConstBufferSequence, ConstBufferIterator, CompletionCondition, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1write__dynbuf__v1__op_3_01AsyncWriteStrea7a2bf910039707817c36e054d69697ee.html">associator&lt; Associator, detail::write_dynbuf_v1_op&lt; AsyncWriteStream, DynamicBuffer_v1, CompletionCondition, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1write__dynbuf__v2__op_3_01AsyncWriteStreaf7183f6b0e66364d2eedd774efa702ac.html">associator&lt; Associator, detail::write_dynbuf_v2_op&lt; AsyncWriteStream, DynamicBuffer_v2, CompletionCondition, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1write__at__op_3_01AsyncRandomAccessWriteD1734ea544f509b0655ab6176e1cfa3b7.html">associator&lt; Associator, detail::write_at_op&lt; AsyncRandomAccessWriteDevice, ConstBufferSequence, ConstBufferIterator, CompletionCondition, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01detail_1_1write__at__streambuf__op_3_01Executor_00_f2360bde8672b7510f9d41c58243048a.html">associator&lt; Associator, detail::write_at_streambuf_op&lt; Executor, WriteHandler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property.html">is_applicable_property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__executor.html">is_executor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1is__read__buffered.html">is_read_buffered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1is__write__buffered.html">is_write_buffered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1multiple__exceptions.html">multiple_exceptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when there are multiple pending exceptions to rethrow.  <a href="classasio_1_1multiple__exceptions.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1can__prefer.html">can_prefer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__nothrow__prefer.html">is_nothrow_prefer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1prefer__result.html">prefer_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1prepend__t.html">prepend_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1can__query.html">can_query</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__nothrow__query.html">is_nothrow_query</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1query__result.html">query_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1recycling__allocator.html">recycling_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator that caches memory blocks in thread-local storage for reuse.  <a href="classasio_1_1recycling__allocator.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1recycling__allocator_3_01void_01_4.html">recycling_allocator&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1redirect__error__t.html">redirect_error_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1registered__buffer__id.html">registered_buffer_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify a registered buffer.  <a href="classasio_1_1registered__buffer__id.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a registered buffer over modifiable data.  <a href="classasio_1_1mutable__registered__buffer.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a registered buffer over non-modifiable data.  <a href="classasio_1_1const__registered__buffer.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1can__require.html">can_require</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__nothrow__require.html">is_nothrow_require</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1require__result.html">require_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1can__require__concept.html">can_require_concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__nothrow__require__concept.html">is_nothrow_require_concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1require__concept__result.html">require_concept_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1signal__set__base.html">signal_set_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html">socket_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A completion_token that represents the currently executing coroutine.  <a href="classasio_1_1basic__yield__context.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associator_3_01Associator_00_01ssl_1_1detail_1_1io__op_3_01Stream_00_01Operation_0e7503c15a9b710dbdd4bfdefbd7cc155.html">associator&lt; Associator, ssl::detail::io_op&lt; Stream, Operation, Handler &gt;, DefaultCandidate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1strand.html">strand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides serialised function invocation for any executor type.  <a href="classasio_1_1strand.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__system__executor.html">basic_system_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An executor that uses arbitrary threads.  <a href="classasio_1_1basic__system__executor.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1system__context.html">system_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The executor context for the system executor.  <a href="classasio_1_1system__context.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1thread.html">thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple abstraction for starting threads.  <a href="classasio_1_1thread.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1wait__traits.html">wait_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait traits suitable for use with the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality.">basic_waitable_timer</a> class template.  <a href="structasio_1_1wait__traits.html#details">Подробнее...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1executor__arg__t.html">executor_arg_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1uses__executor.html">uses_executor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01close__after_00_01void_07asio_1_1error__code_00_01T_08_4.html">async_result&lt; close_after, void(asio::error_code, T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01close__after_00_01void_07std_1_1error__code_00_01T_08_4.html">async_result&lt; close_after, void(std::error_code, T)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01object_3_01N_01_4_00_01prop_3_01M_01_4_01_4.html">is_applicable_property&lt; object&lt; N &gt;, prop&lt; M &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__applicable__property_3_01object_00_01prop_01_4.html">is_applicable_property&lt; object, prop &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01archetypes_1_1immediate__handler_00_01Signature_01_4.html">async_result&lt; archetypes::immediate_handler, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01archetypes_1_1lazy__handler_00_01Signature_01_4.html">async_result&lt; archetypes::lazy_handler, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01incrementer__token__v1_00_01void_07asio_1_1error__code_08_4.html">async_result&lt; incrementer_token_v1, void(asio::error_code)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01incrementer__token__v2_00_01void_07asio_1_1error__code_08_4.html">async_result&lt; incrementer_token_v2, void(asio::error_code)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__match__condition_3_01match__char_01_4.html">is_match_condition&lt; match_char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Определения типов</h2></td></tr>
<tr class="memitem:a36a2efaadb823ea5daa2722235f03b79"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a36a2efaadb823ea5daa2722235f03b79"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a36a2efaadb823ea5daa2722235f03b79">associated_allocator_t</a> = typename <a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; T, Allocator &gt;::type</td></tr>
<tr class="separator:a36a2efaadb823ea5daa2722235f03b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abd10b459023e652684747584eaf567"><td class="memTemplParams" colspan="2">template&lt;typename T , typename CancellationSlot  = cancellation_slot&gt; </td></tr>
<tr class="memitem:a7abd10b459023e652684747584eaf567"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a7abd10b459023e652684747584eaf567">associated_cancellation_slot_t</a> = typename <a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a>&lt; T, CancellationSlot &gt;::type</td></tr>
<tr class="separator:a7abd10b459023e652684747584eaf567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947971ca8e87d2d9d7791b50b7fed58d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor  = system_executor&gt; </td></tr>
<tr class="memitem:a947971ca8e87d2d9d7791b50b7fed58d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a947971ca8e87d2d9d7791b50b7fed58d">associated_executor_t</a> = typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T, Executor &gt;::type</td></tr>
<tr class="separator:a947971ca8e87d2d9d7791b50b7fed58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5218562467927b84b03f687a29578f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor &gt; </td></tr>
<tr class="memitem:a8a5218562467927b84b03f687a29578f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8a5218562467927b84b03f687a29578f">associated_immediate_executor_t</a> = typename <a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a>&lt; T, Executor &gt;::type</td></tr>
<tr class="separator:a8a5218562467927b84b03f687a29578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7335867dac5c662e8386346c9669d710"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a7335867dac5c662e8386346c9669d710"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a7335867dac5c662e8386346c9669d710">completion_signature_of_t</a> = typename <a class="el" href="structasio_1_1completion__signature__of.html">completion_signature_of</a>&lt; T, Args... &gt;::type</td></tr>
<tr class="separator:a7335867dac5c662e8386346c9669d710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bbc083cf9153b28ce2d86c3ea16458"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84bbc083cf9153b28ce2d86c3ea16458"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a> = typename <a class="el" href="structasio_1_1default__completion__token.html">default_completion_token</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a84bbc083cf9153b28ce2d86c3ea16458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7be67c717fae6f2e1b186573b74b44"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a334c4a4c42fdb79d7ebc3e73b517e6f8">cancellation_type::none</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8c7be67c717fae6f2e1b186573b74b44">disable_cancellation</a></td></tr>
<tr class="memdesc:a8c7be67c717fae6f2e1b186573b74b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cancellation filter that disables cancellation.  <a href="namespaceasio.html#a8c7be67c717fae6f2e1b186573b74b44">Подробнее...</a><br /></td></tr>
<tr class="separator:a8c7be67c717fae6f2e1b186573b74b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbee6470702e960e05ea7d244173a53"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8bbee6470702e960e05ea7d244173a53">enable_terminal_cancellation</a></td></tr>
<tr class="memdesc:a8bbee6470702e960e05ea7d244173a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cancellation filter that enables terminal cancellation only.  <a href="namespaceasio.html#a8bbee6470702e960e05ea7d244173a53">Подробнее...</a><br /></td></tr>
<tr class="separator:a8bbee6470702e960e05ea7d244173a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d149df79dc30ac3e926e1ec85e5849"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; static_cast&lt; <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> &gt; static_cast&lt; unsigned int &gt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>)|static_cast&lt; unsigned int &gt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a>))&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a29d149df79dc30ac3e926e1ec85e5849">enable_partial_cancellation</a></td></tr>
<tr class="separator:a29d149df79dc30ac3e926e1ec85e5849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9b0c348b4e739128d5bf18fb87a0e3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; static_cast&lt; <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a> &gt; static_cast&lt; unsigned int &gt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>)|static_cast&lt; unsigned int &gt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a>)|static_cast&lt; unsigned int &gt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6afbb44b4487415b134bce9c790a27fe5e">cancellation_type::total</a>))&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aed9b0c348b4e739128d5bf18fb87a0e3">enable_total_cancellation</a></td></tr>
<tr class="separator:aed9b0c348b4e739128d5bf18fb87a0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d85a0e28424dfdf416a9a812841606b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5d85a0e28424dfdf416a9a812841606b">cancellation_type_t</a></td></tr>
<tr class="separator:a5d85a0e28424dfdf416a9a812841606b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f5a4bba64d7b519ebdf44fd19a491f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5f5a4bba64d7b519ebdf44fd19a491f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ab5f5a4bba64d7b519ebdf44fd19a491f">add_const_t</a> = typename std::add_const&lt; T &gt;::type</td></tr>
<tr class="separator:ab5f5a4bba64d7b519ebdf44fd19a491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8e6f159ea11c2c055614ef353a69fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e8e6f159ea11c2c055614ef353a69fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2e8e6f159ea11c2c055614ef353a69fd">add_lvalue_reference_t</a> = typename std::add_lvalue_reference&lt; T &gt;::type</td></tr>
<tr class="separator:a2e8e6f159ea11c2c055614ef353a69fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2428214df6ad5b92cba3999fc6d25e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, std::size_t A&gt; </td></tr>
<tr class="memitem:a6f2428214df6ad5b92cba3999fc6d25e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a6f2428214df6ad5b92cba3999fc6d25e">aligned_storage_t</a> = typename <a class="el" href="structasio_1_1aligned__storage.html">aligned_storage</a>&lt; N, A &gt;::type</td></tr>
<tr class="separator:a6f2428214df6ad5b92cba3999fc6d25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0332484df24f23affcc056f9085b8a92"><td class="memTemplParams" colspan="2">template&lt;bool C, typename T , typename U &gt; </td></tr>
<tr class="memitem:a0332484df24f23affcc056f9085b8a92"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0332484df24f23affcc056f9085b8a92">conditional_t</a> = typename std::conditional&lt; C, T, U &gt;::type</td></tr>
<tr class="separator:a0332484df24f23affcc056f9085b8a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d03dfdd5dd0ffa4aaf6832eda695664"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d03dfdd5dd0ffa4aaf6832eda695664"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a> = typename std::decay&lt; T &gt;::type</td></tr>
<tr class="separator:a1d03dfdd5dd0ffa4aaf6832eda695664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847109104af3016e3bb18a8ab5b2123c"><td class="memTemplParams" colspan="2">template&lt;bool C, typename T  = void&gt; </td></tr>
<tr class="memitem:a847109104af3016e3bb18a8ab5b2123c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a847109104af3016e3bb18a8ab5b2123c">enable_if_t</a> = typename std::enable_if&lt; C, T &gt;::type</td></tr>
<tr class="separator:a847109104af3016e3bb18a8ab5b2123c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f56d824eb0ac784f9040d69cb5c9b02"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f56d824eb0ac784f9040d69cb5c9b02"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4f56d824eb0ac784f9040d69cb5c9b02">remove_cv_t</a> = typename std::remove_cv&lt; T &gt;::type</td></tr>
<tr class="separator:a4f56d824eb0ac784f9040d69cb5c9b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce63a7f0a33f1ca68320eb2bca47fb4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afce63a7f0a33f1ca68320eb2bca47fb4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#afce63a7f0a33f1ca68320eb2bca47fb4">remove_cvref_t</a> = typename <a class="el" href="structasio_1_1remove__cvref.html">remove_cvref</a>&lt; T &gt;::type</td></tr>
<tr class="separator:afce63a7f0a33f1ca68320eb2bca47fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ed0be1096cd3f9ba4758a7ce1f3294"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7ed0be1096cd3f9ba4758a7ce1f3294"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad7ed0be1096cd3f9ba4758a7ce1f3294">remove_pointer_t</a> = typename std::remove_pointer&lt; T &gt;::type</td></tr>
<tr class="separator:ad7ed0be1096cd3f9ba4758a7ce1f3294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34192a90d4d961bbd9f1a5264be0e081"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34192a90d4d961bbd9f1a5264be0e081"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a> = typename std::remove_reference&lt; T &gt;::type</td></tr>
<tr class="separator:a34192a90d4d961bbd9f1a5264be0e081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03d27556f68768ced98d0eac4a06afd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae03d27556f68768ced98d0eac4a06afd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae03d27556f68768ced98d0eac4a06afd">result_of_t</a> = typename std::result_of&lt; T &gt;::type</td></tr>
<tr class="separator:ae03d27556f68768ced98d0eac4a06afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e34b80842ec318c893ca4eb6316c42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05e34b80842ec318c893ca4eb6316c42"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a05e34b80842ec318c893ca4eb6316c42">void_t</a> = typename <a class="el" href="structasio_1_1void__type.html">void_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a05e34b80842ec318c893ca4eb6316c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f73389553384e0af82754b8491f177"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename Type  = int&gt; </td></tr>
<tr class="memitem:ad8f73389553384e0af82754b8491f177"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a> = typename <a class="el" href="structasio_1_1constraint.html">constraint</a>&lt; Condition, Type &gt;::type</td></tr>
<tr class="separator:ad8f73389553384e0af82754b8491f177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad943bac379d214a815ababf78040b051"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad943bac379d214a815ababf78040b051"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad943bac379d214a815ababf78040b051">type_identity_t</a> = typename <a class="el" href="structasio_1_1type__identity.html">type_identity</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ad943bac379d214a815ababf78040b051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae434d49ea968ad09c18f44d08c98aaa4"><td class="memItemLeft" align="right" valign="top">typedef std::error_category&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae434d49ea968ad09c18f44d08c98aaa4">error_category</a></td></tr>
<tr class="separator:ae434d49ea968ad09c18f44d08c98aaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8914468bc40252ae5e5c666adb951cf"><td class="memItemLeft" align="right" valign="top">typedef std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">error_code</a></td></tr>
<tr class="separator:ac8914468bc40252ae5e5c666adb951cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62851a86dfa77e72fd80d2e6ccab76f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::high_resolution_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac62851a86dfa77e72fd80d2e6ccab76f">high_resolution_timer</a></td></tr>
<tr class="memdesc:ac62851a86dfa77e72fd80d2e6ccab76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a timer based on the high resolution clock.  <a href="namespaceasio.html#ac62851a86dfa77e72fd80d2e6ccab76f">Подробнее...</a><br /></td></tr>
<tr class="separator:ac62851a86dfa77e72fd80d2e6ccab76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8904bd25ca421af4140ab7ac95b0b956"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1io__context.html">io_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8904bd25ca421af4140ab7ac95b0b956">io_service</a></td></tr>
<tr class="memdesc:a8904bd25ca421af4140ab7ac95b0b956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for backwards compatibility.  <a href="namespaceasio.html#a8904bd25ca421af4140ab7ac95b0b956">Подробнее...</a><br /></td></tr>
<tr class="separator:a8904bd25ca421af4140ab7ac95b0b956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55201409b23036671550beeb6cc3b94e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio__prefer__fn_1_1impl.html">asio_prefer_fn::impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a55201409b23036671550beeb6cc3b94e">prefer_t</a></td></tr>
<tr class="separator:a55201409b23036671550beeb6cc3b94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5793dc026a52e88c629a8cb3fded0d26"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Properties&gt; </td></tr>
<tr class="memitem:a5793dc026a52e88c629a8cb3fded0d26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5793dc026a52e88c629a8cb3fded0d26">prefer_result_t</a> = typename <a class="el" href="structasio_1_1prefer__result.html">prefer_result</a>&lt; T, Properties... &gt;::type</td></tr>
<tr class="separator:a5793dc026a52e88c629a8cb3fded0d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecee0160ad9fd66180683316b4846d4b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio__query__fn_1_1impl.html">asio_query_fn::impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aecee0160ad9fd66180683316b4846d4b">query_t</a></td></tr>
<tr class="separator:aecee0160ad9fd66180683316b4846d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91495cbc0319a786cc883e78f1f463d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Property &gt; </td></tr>
<tr class="memitem:aa91495cbc0319a786cc883e78f1f463d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa91495cbc0319a786cc883e78f1f463d">query_result_t</a> = typename <a class="el" href="structasio_1_1query__result.html">query_result</a>&lt; T, Property &gt;::type</td></tr>
<tr class="separator:aa91495cbc0319a786cc883e78f1f463d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6bab0c8ad8c073a605675ec7232926"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio__require__fn_1_1impl.html">asio_require_fn::impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0f6bab0c8ad8c073a605675ec7232926">require_t</a></td></tr>
<tr class="separator:a0f6bab0c8ad8c073a605675ec7232926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663cc02e852bddcae88370910e172af1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Properties&gt; </td></tr>
<tr class="memitem:a663cc02e852bddcae88370910e172af1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a663cc02e852bddcae88370910e172af1">require_result_t</a> = typename <a class="el" href="structasio_1_1require__result.html">require_result</a>&lt; T, Properties... &gt;::type</td></tr>
<tr class="separator:a663cc02e852bddcae88370910e172af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23510e91b2cc59d7d19e64f6a0f0b64f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structasio__require__concept__fn_1_1impl.html">asio_require_concept_fn::impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a23510e91b2cc59d7d19e64f6a0f0b64f">require_concept_t</a></td></tr>
<tr class="separator:a23510e91b2cc59d7d19e64f6a0f0b64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb141fa42dd3edf2f777105b8d246988"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Property &gt; </td></tr>
<tr class="memitem:abb141fa42dd3edf2f777105b8d246988"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#abb141fa42dd3edf2f777105b8d246988">require_concept_result_t</a> = typename <a class="el" href="structasio_1_1require__concept__result.html">require_concept_result</a>&lt; T, Property &gt;::type</td></tr>
<tr class="separator:abb141fa42dd3edf2f777105b8d246988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f135fc124cc60e4e00dc2dbb309f354"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4f135fc124cc60e4e00dc2dbb309f354">signal_set</a></td></tr>
<tr class="memdesc:a4f135fc124cc60e4e00dc2dbb309f354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the typical usage of a signal set.  <a href="namespaceasio.html#a4f135fc124cc60e4e00dc2dbb309f354">Подробнее...</a><br /></td></tr>
<tr class="separator:a4f135fc124cc60e4e00dc2dbb309f354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b73624bafbe0c55f0da6b594cbc886"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; <a class="el" href="classasio_1_1any__io__executor.html">any_io_executor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a></td></tr>
<tr class="separator:a09b73624bafbe0c55f0da6b594cbc886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97767413ad2526e9941d17f112b5018"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1thread__pool.html">thread_pool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af97767413ad2526e9941d17f112b5018">static_thread_pool</a></td></tr>
<tr class="separator:af97767413ad2526e9941d17f112b5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627a7abd2bc87969838f17e46b8dc20d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::steady_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a627a7abd2bc87969838f17e46b8dc20d">steady_timer</a></td></tr>
<tr class="memdesc:a627a7abd2bc87969838f17e46b8dc20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a timer based on the steady clock.  <a href="namespaceasio.html#a627a7abd2bc87969838f17e46b8dc20d">Подробнее...</a><br /></td></tr>
<tr class="separator:a627a7abd2bc87969838f17e46b8dc20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7ba348943527312eeace3492bf32ee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a6a7ba348943527312eeace3492bf32ee">streambuf</a></td></tr>
<tr class="memdesc:a6a7ba348943527312eeace3492bf32ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the typical usage of <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a>.  <a href="namespaceasio.html#a6a7ba348943527312eeace3492bf32ee">Подробнее...</a><br /></td></tr>
<tr class="separator:a6a7ba348943527312eeace3492bf32ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e0b6db67d52eba50e168ae78c1a049"><td class="memItemLeft" align="right" valign="top">typedef std::system_error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">system_error</a></td></tr>
<tr class="separator:ac5e0b6db67d52eba50e168ae78c1a049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afc37336b3232b8b291ab23e98a9201"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__system__executor.html">basic_system_executor</a>&lt; <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#a0ee9cc739b3b11aa5a584a4310a47e22">execution::blocking_t::possibly_t</a>, <a class="el" href="structasio_1_1execution_1_1detail_1_1relationship__t.html#ad59f7aede6089578c4505b171e27369b">execution::relationship_t::fork_t</a>, std::allocator&lt; <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9afc37336b3232b8b291ab23e98a9201">system_executor</a></td></tr>
<tr class="memdesc:a9afc37336b3232b8b291ab23e98a9201"><td class="mdescLeft">&#160;</td><td class="mdescRight">An executor that uses arbitrary threads.  <a href="namespaceasio.html#a9afc37336b3232b8b291ab23e98a9201">Подробнее...</a><br /></td></tr>
<tr class="separator:a9afc37336b3232b8b291ab23e98a9201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d65c694154683a53496180854859975"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::system_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2d65c694154683a53496180854859975">system_timer</a></td></tr>
<tr class="memdesc:a2d65c694154683a53496180854859975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a timer based on the system clock.  <a href="namespaceasio.html#a2d65c694154683a53496180854859975">Подробнее...</a><br /></td></tr>
<tr class="separator:a2d65c694154683a53496180854859975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Перечисления</h2></td></tr>
<tr class="memitem:ae02aa651224af4b25dc476fc01ce29f6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type</a> : unsigned int { <br />
&#160;&#160;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a334c4a4c42fdb79d7ebc3e73b517e6f8">none</a> = 0
, <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">terminal</a> = 1
, <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">partial</a> = 2
, <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6afbb44b4487415b134bce9c790a27fe5e">total</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aa181a603769c1f98ad927e7367c7aa51">all</a> = 0xFFFFFFFF
<br />
 }</td></tr>
<tr class="separator:ae02aa651224af4b25dc476fc01ce29f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Функции</h2></td></tr>
<tr class="memitem:a09fd5a7dd30ae955ea23bab8217d9489"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename... Values&gt; </td></tr>
<tr class="memitem:a09fd5a7dd30ae955ea23bab8217d9489"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1append__t.html">append_t</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; CompletionToken &gt;, <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; Values &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a09fd5a7dd30ae955ea23bab8217d9489">append</a> (CompletionToken &amp;&amp;completion_token, Values &amp;&amp;... values)</td></tr>
<tr class="separator:a09fd5a7dd30ae955ea23bab8217d9489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea102f8b62f7d43a164036cfd504e56"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:a4ea102f8b62f7d43a164036cfd504e56"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1as__tuple__t.html">as_tuple_t</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; CompletionToken &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4ea102f8b62f7d43a164036cfd504e56">as_tuple</a> (CompletionToken &amp;&amp;completion_token)</td></tr>
<tr class="separator:a4ea102f8b62f7d43a164036cfd504e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713d72690f79a12548b3d3199b6d2a16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a713d72690f79a12548b3d3199b6d2a16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a713d72690f79a12548b3d3199b6d2a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated allocator.  <a href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">Подробнее...</a><br /></td></tr>
<tr class="separator:a713d72690f79a12548b3d3199b6d2a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c18a9b1d0d55eb89746a4c0e679345"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a82c18a9b1d0d55eb89746a4c0e679345"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a82c18a9b1d0d55eb89746a4c0e679345">get_associated_allocator</a> (const T &amp;t, const Allocator &amp;<a class="el" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>) noexcept -&gt; decltype(<a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; T, Allocator &gt;::get(t, <a class="el" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>))</td></tr>
<tr class="memdesc:a82c18a9b1d0d55eb89746a4c0e679345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated allocator.  <a href="namespaceasio.html#a82c18a9b1d0d55eb89746a4c0e679345">Подробнее...</a><br /></td></tr>
<tr class="separator:a82c18a9b1d0d55eb89746a4c0e679345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b51cb1d32c89024cf7768bcce6f649e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b51cb1d32c89024cf7768bcce6f649e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3b51cb1d32c89024cf7768bcce6f649e">get_associated_cancellation_slot</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a3b51cb1d32c89024cf7768bcce6f649e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated <a class="el" href="classasio_1_1cancellation__slot.html" title="A slot associated with a cancellation signal.">cancellation_slot</a>.  <a href="namespaceasio.html#a3b51cb1d32c89024cf7768bcce6f649e">Подробнее...</a><br /></td></tr>
<tr class="separator:a3b51cb1d32c89024cf7768bcce6f649e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ba7c6fbf3206e8f4fbc64bc69c5644"><td class="memTemplParams" colspan="2">template&lt;typename T , typename CancellationSlot &gt; </td></tr>
<tr class="memitem:a69ba7c6fbf3206e8f4fbc64bc69c5644"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a69ba7c6fbf3206e8f4fbc64bc69c5644">get_associated_cancellation_slot</a> (const T &amp;t, const CancellationSlot &amp;st) noexcept -&gt; decltype(<a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a>&lt; T, CancellationSlot &gt;::get(t, st))</td></tr>
<tr class="memdesc:a69ba7c6fbf3206e8f4fbc64bc69c5644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated <a class="el" href="classasio_1_1cancellation__slot.html" title="A slot associated with a cancellation signal.">cancellation_slot</a>.  <a href="namespaceasio.html#a69ba7c6fbf3206e8f4fbc64bc69c5644">Подробнее...</a><br /></td></tr>
<tr class="separator:a69ba7c6fbf3206e8f4fbc64bc69c5644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababee4f6241fcc45f5d49b89085e6a62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ababee4f6241fcc45f5d49b89085e6a62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ababee4f6241fcc45f5d49b89085e6a62">get_associated_executor</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:ababee4f6241fcc45f5d49b89085e6a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <a href="namespaceasio.html#ababee4f6241fcc45f5d49b89085e6a62">Подробнее...</a><br /></td></tr>
<tr class="separator:ababee4f6241fcc45f5d49b89085e6a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f3ac3ddba1f3274b26dcb8f4b8c6f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor &gt; </td></tr>
<tr class="memitem:ad0f3ac3ddba1f3274b26dcb8f4b8c6f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad0f3ac3ddba1f3274b26dcb8f4b8c6f6">get_associated_executor</a> (const T &amp;t, const Executor &amp;ex, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0) noexcept -&gt; decltype(<a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T, Executor &gt;::get(t, ex))</td></tr>
<tr class="memdesc:ad0f3ac3ddba1f3274b26dcb8f4b8c6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <a href="namespaceasio.html#ad0f3ac3ddba1f3274b26dcb8f4b8c6f6">Подробнее...</a><br /></td></tr>
<tr class="separator:ad0f3ac3ddba1f3274b26dcb8f4b8c6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0760a87f5f3fd90c84bd107449be00"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ExecutionContext &gt; </td></tr>
<tr class="memitem:afa0760a87f5f3fd90c84bd107449be00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T, typename ExecutionContext::executor_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#afa0760a87f5f3fd90c84bd107449be00">get_associated_executor</a> (const T &amp;t, ExecutionContext &amp;ctx, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:afa0760a87f5f3fd90c84bd107449be00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <a href="namespaceasio.html#afa0760a87f5f3fd90c84bd107449be00">Подробнее...</a><br /></td></tr>
<tr class="separator:afa0760a87f5f3fd90c84bd107449be00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754bcbf3e3c8b84637a949642a35e03b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor &gt; </td></tr>
<tr class="memitem:a754bcbf3e3c8b84637a949642a35e03b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a754bcbf3e3c8b84637a949642a35e03b">get_associated_immediate_executor</a> (const T &amp;t, const Executor &amp;ex, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0) noexcept -&gt; decltype(<a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a>&lt; T, Executor &gt;::get(t, ex))</td></tr>
<tr class="memdesc:a754bcbf3e3c8b84637a949642a35e03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <a href="namespaceasio.html#a754bcbf3e3c8b84637a949642a35e03b">Подробнее...</a><br /></td></tr>
<tr class="separator:a754bcbf3e3c8b84637a949642a35e03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf785ef6a588421ec1805478d13ce1d3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ExecutionContext &gt; </td></tr>
<tr class="memitem:acf785ef6a588421ec1805478d13ce1d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a>&lt; T, typename ExecutionContext::executor_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#acf785ef6a588421ec1805478d13ce1d3">get_associated_immediate_executor</a> (const T &amp;t, ExecutionContext &amp;ctx, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:acf785ef6a588421ec1805478d13ce1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <a href="namespaceasio.html#acf785ef6a588421ec1805478d13ce1d3">Подробнее...</a><br /></td></tr>
<tr class="separator:acf785ef6a588421ec1805478d13ce1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf600e256af39d8a0c65fb6e3eb988d"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , ASIO_COMPLETION_SIGNATURE... Signatures, typename Initiation , typename... Args&gt; </td></tr>
<tr class="memitem:acbf600e256af39d8a0c65fb6e3eb988d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a> (Initiation &amp;&amp;initiation, <a class="el" href="namespaceasio.html#ad943bac379d214a815ababf78040b051">type_identity_t</a>&lt; CompletionToken &gt; &amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, Args &amp;&amp;... args) -&gt; <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signatures... &gt;::value, decltype(<a class="el" href="classasio_1_1async__result.html">async_result</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; CompletionToken &gt;, Signatures... &gt;::initiate(static_cast&lt; Initiation &amp;&amp; &gt;(initiation), static_cast&lt; CompletionToken &amp;&amp; &gt;(<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>), static_cast&lt; Args &amp;&amp; &gt;(args)...))&gt;</td></tr>
<tr class="separator:acbf600e256af39d8a0c65fb6e3eb988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f784a1c5604d9cdb7ead506e6b7ebe"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , ASIO_COMPLETION_SIGNATURE... Signatures, typename Initiation , typename... Args&gt; </td></tr>
<tr class="memitem:a26f784a1c5604d9cdb7ead506e6b7ebe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signatures... &gt;::value, typename <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; CompletionToken &gt;, Signatures... &gt;::return_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a26f784a1c5604d9cdb7ead506e6b7ebe">async_initiate</a> (Initiation &amp;&amp;initiation, <a class="el" href="namespaceasio.html#ad943bac379d214a815ababf78040b051">type_identity_t</a>&lt; CompletionToken &gt; &amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a26f784a1c5604d9cdb7ead506e6b7ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc1edea36e4260b8f7c65d3dc4aa522"><td class="memTemplParams" colspan="2">template&lt;typename Allocator , typename T &gt; </td></tr>
<tr class="memitem:a6dc1edea36e4260b8f7c65d3dc4aa522"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1allocator__binder.html">allocator_binder</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; T &gt;, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a6dc1edea36e4260b8f7c65d3dc4aa522">bind_allocator</a> (const Allocator &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, T &amp;&amp;t)</td></tr>
<tr class="separator:a6dc1edea36e4260b8f7c65d3dc4aa522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de893a31b1037808c1c41311dd2860d"><td class="memTemplParams" colspan="2">template&lt;typename CancellationSlot , typename T &gt; </td></tr>
<tr class="memitem:a9de893a31b1037808c1c41311dd2860d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancellation__slot__binder.html">cancellation_slot_binder</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; T &gt;, CancellationSlot &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9de893a31b1037808c1c41311dd2860d">bind_cancellation_slot</a> (const CancellationSlot &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, T &amp;&amp;t)</td></tr>
<tr class="separator:a9de893a31b1037808c1c41311dd2860d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3861d399297bcd40766f133773ea88e7"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename T &gt; </td></tr>
<tr class="memitem:a3861d399297bcd40766f133773ea88e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; T &gt;, Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3861d399297bcd40766f133773ea88e7">bind_executor</a> (const Executor &amp;ex, T &amp;&amp;t, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a3861d399297bcd40766f133773ea88e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an object of type <code>T</code> with an executor of type <code>Executor</code>.  <a href="namespaceasio.html#a3861d399297bcd40766f133773ea88e7">Подробнее...</a><br /></td></tr>
<tr class="separator:a3861d399297bcd40766f133773ea88e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68f928d90d17a7a2ef7749ca06b92c1"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename T &gt; </td></tr>
<tr class="memitem:ac68f928d90d17a7a2ef7749ca06b92c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; T &gt;, typename ExecutionContext::executor_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac68f928d90d17a7a2ef7749ca06b92c1">bind_executor</a> (ExecutionContext &amp;ctx, T &amp;&amp;t, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ac68f928d90d17a7a2ef7749ca06b92c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an object of type <code>T</code> with an execution context's executor.  <a href="namespaceasio.html#ac68f928d90d17a7a2ef7749ca06b92c1">Подробнее...</a><br /></td></tr>
<tr class="separator:ac68f928d90d17a7a2ef7749ca06b92c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd91a512d2dfbc4faa108791856147a1"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename T &gt; </td></tr>
<tr class="memitem:afd91a512d2dfbc4faa108791856147a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1immediate__executor__binder.html">immediate_executor_binder</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; T &gt;, Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#afd91a512d2dfbc4faa108791856147a1">bind_immediate_executor</a> (const Executor &amp;e, T &amp;&amp;t)</td></tr>
<tr class="separator:afd91a512d2dfbc4faa108791856147a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4d8d749d450ac578b620e5c61250e5"><td class="memTemplParams" colspan="2">template&lt;typename MutableBuffer &gt; </td></tr>
<tr class="memitem:a5b4d8d749d450ac578b620e5c61250e5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5b4d8d749d450ac578b620e5c61250e5">buffer_sequence_begin</a> (const MutableBuffer &amp;b, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; const MutableBuffer *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:a5b4d8d749d450ac578b620e5c61250e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <a href="namespaceasio.html#a5b4d8d749d450ac578b620e5c61250e5">Подробнее...</a><br /></td></tr>
<tr class="separator:a5b4d8d749d450ac578b620e5c61250e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686f3b0e674a7bc5b10582960f5c7e6a"><td class="memTemplParams" colspan="2">template&lt;typename ConstBuffer &gt; </td></tr>
<tr class="memitem:a686f3b0e674a7bc5b10582960f5c7e6a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a686f3b0e674a7bc5b10582960f5c7e6a">buffer_sequence_begin</a> (const ConstBuffer &amp;b, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; const ConstBuffer *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:a686f3b0e674a7bc5b10582960f5c7e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <a href="namespaceasio.html#a686f3b0e674a7bc5b10582960f5c7e6a">Подробнее...</a><br /></td></tr>
<tr class="separator:a686f3b0e674a7bc5b10582960f5c7e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcd07567a0f9eeaacd8bd0b08689e80"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:afbcd07567a0f9eeaacd8bd0b08689e80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#afbcd07567a0f9eeaacd8bd0b08689e80">buffer_sequence_begin</a> (C &amp;c, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:afbcd07567a0f9eeaacd8bd0b08689e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <a href="namespaceasio.html#afbcd07567a0f9eeaacd8bd0b08689e80">Подробнее...</a><br /></td></tr>
<tr class="separator:afbcd07567a0f9eeaacd8bd0b08689e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1288ea04d255a07a8050e8016b554d0b"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a1288ea04d255a07a8050e8016b554d0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1288ea04d255a07a8050e8016b554d0b">buffer_sequence_begin</a> (const C &amp;c, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:a1288ea04d255a07a8050e8016b554d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <a href="namespaceasio.html#a1288ea04d255a07a8050e8016b554d0b">Подробнее...</a><br /></td></tr>
<tr class="separator:a1288ea04d255a07a8050e8016b554d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68ad2484cefa6ed9a53783912ae0cd1"><td class="memTemplParams" colspan="2">template&lt;typename MutableBuffer &gt; </td></tr>
<tr class="memitem:aa68ad2484cefa6ed9a53783912ae0cd1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa68ad2484cefa6ed9a53783912ae0cd1">buffer_sequence_end</a> (const MutableBuffer &amp;b, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; const MutableBuffer *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:aa68ad2484cefa6ed9a53783912ae0cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <a href="namespaceasio.html#aa68ad2484cefa6ed9a53783912ae0cd1">Подробнее...</a><br /></td></tr>
<tr class="separator:aa68ad2484cefa6ed9a53783912ae0cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290ddb5ce8b88216e2042f5c5db79694"><td class="memTemplParams" colspan="2">template&lt;typename ConstBuffer &gt; </td></tr>
<tr class="memitem:a290ddb5ce8b88216e2042f5c5db79694"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a290ddb5ce8b88216e2042f5c5db79694">buffer_sequence_end</a> (const ConstBuffer &amp;b, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; const ConstBuffer *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept</td></tr>
<tr class="memdesc:a290ddb5ce8b88216e2042f5c5db79694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <a href="namespaceasio.html#a290ddb5ce8b88216e2042f5c5db79694">Подробнее...</a><br /></td></tr>
<tr class="separator:a290ddb5ce8b88216e2042f5c5db79694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe41182ab29c34a81752396b25ba0d1a"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:afe41182ab29c34a81752396b25ba0d1a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#afe41182ab29c34a81752396b25ba0d1a">buffer_sequence_end</a> (C &amp;c, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:afe41182ab29c34a81752396b25ba0d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <a href="namespaceasio.html#afe41182ab29c34a81752396b25ba0d1a">Подробнее...</a><br /></td></tr>
<tr class="separator:afe41182ab29c34a81752396b25ba0d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a057966e62697d09cafab0009eda0e"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ab7a057966e62697d09cafab0009eda0e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ab7a057966e62697d09cafab0009eda0e">buffer_sequence_end</a> (const C &amp;c, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;=0) noexcept -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:ab7a057966e62697d09cafab0009eda0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <a href="namespaceasio.html#ab7a057966e62697d09cafab0009eda0e">Подробнее...</a><br /></td></tr>
<tr class="separator:ab7a057966e62697d09cafab0009eda0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a32ffb00a82a2cb0dcbb976e02d82cc79">buffer_size</a> (const BufferSequence &amp;b) noexcept</td></tr>
<tr class="memdesc:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of bytes in a buffer sequence.  <a href="namespaceasio.html#a32ffb00a82a2cb0dcbb976e02d82cc79">Подробнее...</a><br /></td></tr>
<tr class="separator:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8365a4bf9ba53918c758263fd3b0fb36"><td class="memTemplParams" colspan="2">template&lt;typename PointerToPodType &gt; </td></tr>
<tr class="memitem:a8365a4bf9ba53918c758263fd3b0fb36"><td class="memTemplItemLeft" align="right" valign="top">PointerToPodType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8365a4bf9ba53918c758263fd3b0fb36">buffer_cast</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a8365a4bf9ba53918c758263fd3b0fb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a non-modifiable buffer to a specified pointer to POD type.  <a href="namespaceasio.html#a8365a4bf9ba53918c758263fd3b0fb36">Подробнее...</a><br /></td></tr>
<tr class="separator:a8365a4bf9ba53918c758263fd3b0fb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240b9552e7e1deb855c98e11583b88a5"><td class="memTemplParams" colspan="2">template&lt;typename PointerToPodType &gt; </td></tr>
<tr class="memitem:a240b9552e7e1deb855c98e11583b88a5"><td class="memTemplItemLeft" align="right" valign="top">PointerToPodType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a240b9552e7e1deb855c98e11583b88a5">buffer_cast</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a240b9552e7e1deb855c98e11583b88a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a non-modifiable buffer to a specified pointer to POD type.  <a href="namespaceasio.html#a240b9552e7e1deb855c98e11583b88a5">Подробнее...</a><br /></td></tr>
<tr class="separator:a240b9552e7e1deb855c98e11583b88a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af691d016b23fd6c2da9ac91ce00c2e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">buffer</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:af691d016b23fd6c2da9ac91ce00c2e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">Подробнее...</a><br /></td></tr>
<tr class="separator:af691d016b23fd6c2da9ac91ce00c2e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4a73cd878cb3ce83da935fb9932f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2b4a73cd878cb3ce83da935fb9932f23">buffer</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a2b4a73cd878cb3ce83da935fb9932f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="namespaceasio.html#a2b4a73cd878cb3ce83da935fb9932f23">Подробнее...</a><br /></td></tr>
<tr class="separator:a2b4a73cd878cb3ce83da935fb9932f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2c9f5266bd40548109072a006bd4db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3e2c9f5266bd40548109072a006bd4db">buffer</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a3e2c9f5266bd40548109072a006bd4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="namespaceasio.html#a3e2c9f5266bd40548109072a006bd4db">Подробнее...</a><br /></td></tr>
<tr class="separator:a3e2c9f5266bd40548109072a006bd4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e22c4da973f9cec891970c007ea8a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8e22c4da973f9cec891970c007ea8a7b">buffer</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a8e22c4da973f9cec891970c007ea8a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="namespaceasio.html#a8e22c4da973f9cec891970c007ea8a7b">Подробнее...</a><br /></td></tr>
<tr class="separator:a8e22c4da973f9cec891970c007ea8a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390401d56dbdf838be8a09ec7ce4d4d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a390401d56dbdf838be8a09ec7ce4d4d4">buffer</a> (<a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> *data, std::size_t size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a390401d56dbdf838be8a09ec7ce4d4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given memory range.  <a href="namespaceasio.html#a390401d56dbdf838be8a09ec7ce4d4d4">Подробнее...</a><br /></td></tr>
<tr class="separator:a390401d56dbdf838be8a09ec7ce4d4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609e222330f06ff048c78d40431953e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a609e222330f06ff048c78d40431953e5">buffer</a> (const <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> *data, std::size_t size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a609e222330f06ff048c78d40431953e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given memory range.  <a href="namespaceasio.html#a609e222330f06ff048c78d40431953e5">Подробнее...</a><br /></td></tr>
<tr class="separator:a609e222330f06ff048c78d40431953e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddf466e8044ce08813fc66d4097d213"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a4ddf466e8044ce08813fc66d4097d213"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4ddf466e8044ce08813fc66d4097d213">buffer</a> (PodType(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:a4ddf466e8044ce08813fc66d4097d213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#a4ddf466e8044ce08813fc66d4097d213">Подробнее...</a><br /></td></tr>
<tr class="separator:a4ddf466e8044ce08813fc66d4097d213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a0a6ae44a23ca25b1836da782cd616"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a56a0a6ae44a23ca25b1836da782cd616"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a56a0a6ae44a23ca25b1836da782cd616">buffer</a> (PodType(&amp;data)[N], std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a56a0a6ae44a23ca25b1836da782cd616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#a56a0a6ae44a23ca25b1836da782cd616">Подробнее...</a><br /></td></tr>
<tr class="separator:a56a0a6ae44a23ca25b1836da782cd616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2b1693298fb564b28c7440eff1774e"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a1f2b1693298fb564b28c7440eff1774e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1f2b1693298fb564b28c7440eff1774e">buffer</a> (const PodType(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:a1f2b1693298fb564b28c7440eff1774e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#a1f2b1693298fb564b28c7440eff1774e">Подробнее...</a><br /></td></tr>
<tr class="separator:a1f2b1693298fb564b28c7440eff1774e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b5df59bccdd5b06f8d93416472105c"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a66b5df59bccdd5b06f8d93416472105c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a66b5df59bccdd5b06f8d93416472105c">buffer</a> (const PodType(&amp;data)[N], std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a66b5df59bccdd5b06f8d93416472105c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#a66b5df59bccdd5b06f8d93416472105c">Подробнее...</a><br /></td></tr>
<tr class="separator:a66b5df59bccdd5b06f8d93416472105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6a0ab72797048aa4629781e650d65e"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a8e6a0ab72797048aa4629781e650d65e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8e6a0ab72797048aa4629781e650d65e">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a8e6a0ab72797048aa4629781e650d65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#a8e6a0ab72797048aa4629781e650d65e">Подробнее...</a><br /></td></tr>
<tr class="separator:a8e6a0ab72797048aa4629781e650d65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92b80f670c5f74b5402342f87fd9d28"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:af92b80f670c5f74b5402342f87fd9d28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af92b80f670c5f74b5402342f87fd9d28">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:af92b80f670c5f74b5402342f87fd9d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#af92b80f670c5f74b5402342f87fd9d28">Подробнее...</a><br /></td></tr>
<tr class="separator:af92b80f670c5f74b5402342f87fd9d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2e76bbc8d686f8c816fe49873a4666"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a0a2e76bbc8d686f8c816fe49873a4666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0a2e76bbc8d686f8c816fe49873a4666">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a0a2e76bbc8d686f8c816fe49873a4666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#a0a2e76bbc8d686f8c816fe49873a4666">Подробнее...</a><br /></td></tr>
<tr class="separator:a0a2e76bbc8d686f8c816fe49873a4666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c6a9bbe7e9cba49430d37caae476cd"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a00c6a9bbe7e9cba49430d37caae476cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a00c6a9bbe7e9cba49430d37caae476cd">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a00c6a9bbe7e9cba49430d37caae476cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#a00c6a9bbe7e9cba49430d37caae476cd">Подробнее...</a><br /></td></tr>
<tr class="separator:a00c6a9bbe7e9cba49430d37caae476cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da2efeb42c04e368055e1b5f7780132"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:a5da2efeb42c04e368055e1b5f7780132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5da2efeb42c04e368055e1b5f7780132">buffer</a> (std::array&lt; PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a5da2efeb42c04e368055e1b5f7780132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#a5da2efeb42c04e368055e1b5f7780132">Подробнее...</a><br /></td></tr>
<tr class="separator:a5da2efeb42c04e368055e1b5f7780132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff494b6b08d0ae82723ec370cd91d39a"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:aff494b6b08d0ae82723ec370cd91d39a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aff494b6b08d0ae82723ec370cd91d39a">buffer</a> (std::array&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:aff494b6b08d0ae82723ec370cd91d39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#aff494b6b08d0ae82723ec370cd91d39a">Подробнее...</a><br /></td></tr>
<tr class="separator:aff494b6b08d0ae82723ec370cd91d39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa3e7d25d0f90000eebc400c02dfbf0"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:adfa3e7d25d0f90000eebc400c02dfbf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#adfa3e7d25d0f90000eebc400c02dfbf0">buffer</a> (std::array&lt; const PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:adfa3e7d25d0f90000eebc400c02dfbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#adfa3e7d25d0f90000eebc400c02dfbf0">Подробнее...</a><br /></td></tr>
<tr class="separator:adfa3e7d25d0f90000eebc400c02dfbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f602fab6a887916ee3aac0769dc46a"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ae1f602fab6a887916ee3aac0769dc46a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae1f602fab6a887916ee3aac0769dc46a">buffer</a> (std::array&lt; const PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ae1f602fab6a887916ee3aac0769dc46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="namespaceasio.html#ae1f602fab6a887916ee3aac0769dc46a">Подробнее...</a><br /></td></tr>
<tr class="separator:ae1f602fab6a887916ee3aac0769dc46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84688fa20c384874e1eddf5c81d8c331"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:a84688fa20c384874e1eddf5c81d8c331"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a84688fa20c384874e1eddf5c81d8c331">buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a84688fa20c384874e1eddf5c81d8c331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="namespaceasio.html#a84688fa20c384874e1eddf5c81d8c331">Подробнее...</a><br /></td></tr>
<tr class="separator:a84688fa20c384874e1eddf5c81d8c331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af717cc04e6415768402160b063ec6202"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:af717cc04e6415768402160b063ec6202"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af717cc04e6415768402160b063ec6202">buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:af717cc04e6415768402160b063ec6202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="namespaceasio.html#af717cc04e6415768402160b063ec6202">Подробнее...</a><br /></td></tr>
<tr class="separator:af717cc04e6415768402160b063ec6202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d16f55d0457afe5971519eafa4f2b2"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:a32d16f55d0457afe5971519eafa4f2b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a32d16f55d0457afe5971519eafa4f2b2">buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a32d16f55d0457afe5971519eafa4f2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="namespaceasio.html#a32d16f55d0457afe5971519eafa4f2b2">Подробнее...</a><br /></td></tr>
<tr class="separator:a32d16f55d0457afe5971519eafa4f2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8958d330420418a8ca049279026dc3f"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:aa8958d330420418a8ca049279026dc3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa8958d330420418a8ca049279026dc3f">buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:aa8958d330420418a8ca049279026dc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="namespaceasio.html#aa8958d330420418a8ca049279026dc3f">Подробнее...</a><br /></td></tr>
<tr class="separator:aa8958d330420418a8ca049279026dc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691ba65873879c5541119faff29aa0f4"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a691ba65873879c5541119faff29aa0f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a691ba65873879c5541119faff29aa0f4">buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a691ba65873879c5541119faff29aa0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given string.  <a href="namespaceasio.html#a691ba65873879c5541119faff29aa0f4">Подробнее...</a><br /></td></tr>
<tr class="separator:a691ba65873879c5541119faff29aa0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc4d596625f545097450584d532a71e"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a1dc4d596625f545097450584d532a71e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1dc4d596625f545097450584d532a71e">buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:a1dc4d596625f545097450584d532a71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given string.  <a href="namespaceasio.html#a1dc4d596625f545097450584d532a71e">Подробнее...</a><br /></td></tr>
<tr class="separator:a1dc4d596625f545097450584d532a71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28b3f525cd9132dde4eceff0d1c8611"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ac28b3f525cd9132dde4eceff0d1c8611"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac28b3f525cd9132dde4eceff0d1c8611">buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ac28b3f525cd9132dde4eceff0d1c8611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="namespaceasio.html#ac28b3f525cd9132dde4eceff0d1c8611">Подробнее...</a><br /></td></tr>
<tr class="separator:ac28b3f525cd9132dde4eceff0d1c8611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8ad05e2147e00fe0019da3b12caac1"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aca8ad05e2147e00fe0019da3b12caac1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aca8ad05e2147e00fe0019da3b12caac1">buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:aca8ad05e2147e00fe0019da3b12caac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="namespaceasio.html#aca8ad05e2147e00fe0019da3b12caac1">Подробнее...</a><br /></td></tr>
<tr class="separator:aca8ad05e2147e00fe0019da3b12caac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3bc2e4b9e6bf8ff64eab08344002aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb3bc2e4b9e6bf8ff64eab08344002aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aeb3bc2e4b9e6bf8ff64eab08344002aa">buffer</a> (T &amp;data, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_const&lt; <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:aeb3bc2e4b9e6bf8ff64eab08344002aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from a contiguous container.  <a href="namespaceasio.html#aeb3bc2e4b9e6bf8ff64eab08344002aa">Подробнее...</a><br /></td></tr>
<tr class="separator:aeb3bc2e4b9e6bf8ff64eab08344002aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230a757727dfa8eac34c54df06cf6fa0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a230a757727dfa8eac34c54df06cf6fa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a230a757727dfa8eac34c54df06cf6fa0">buffer</a> (T &amp;data, std::size_t max_size_in_bytes, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_const&lt; <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:a230a757727dfa8eac34c54df06cf6fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from a contiguous container.  <a href="namespaceasio.html#a230a757727dfa8eac34c54df06cf6fa0">Подробнее...</a><br /></td></tr>
<tr class="separator:a230a757727dfa8eac34c54df06cf6fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9025af2d8c7f20168a21c860ce06d2fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9025af2d8c7f20168a21c860ce06d2fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9025af2d8c7f20168a21c860ce06d2fd">buffer</a> (T &amp;data, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_const&lt; <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:a9025af2d8c7f20168a21c860ce06d2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from a contiguous container.  <a href="namespaceasio.html#a9025af2d8c7f20168a21c860ce06d2fd">Подробнее...</a><br /></td></tr>
<tr class="separator:a9025af2d8c7f20168a21c860ce06d2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52644e5a827859367e71ebeafe1a9fca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52644e5a827859367e71ebeafe1a9fca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a52644e5a827859367e71ebeafe1a9fca">buffer</a> (T &amp;data, std::size_t max_size_in_bytes, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_const&lt; <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:a52644e5a827859367e71ebeafe1a9fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from a contiguous container.  <a href="namespaceasio.html#a52644e5a827859367e71ebeafe1a9fca">Подробнее...</a><br /></td></tr>
<tr class="separator:a52644e5a827859367e71ebeafe1a9fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df15a068b182e5dbc67e7a9831ac663"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7df15a068b182e5dbc67e7a9831ac663"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a7df15a068b182e5dbc67e7a9831ac663">buffer</a> (const T &amp;data, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::const_iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:a7df15a068b182e5dbc67e7a9831ac663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from a contiguous container.  <a href="namespaceasio.html#a7df15a068b182e5dbc67e7a9831ac663">Подробнее...</a><br /></td></tr>
<tr class="separator:a7df15a068b182e5dbc67e7a9831ac663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1725cb81df773d48f415111dc9d66d07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1725cb81df773d48f415111dc9d66d07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1725cb81df773d48f415111dc9d66d07">buffer</a> (const T &amp;data, std::size_t max_size_in_bytes, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::const_iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;=<a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()) noexcept</td></tr>
<tr class="memdesc:a1725cb81df773d48f415111dc9d66d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from a contiguous container.  <a href="namespaceasio.html#a1725cb81df773d48f415111dc9d66d07">Подробнее...</a><br /></td></tr>
<tr class="separator:a1725cb81df773d48f415111dc9d66d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6f6adc11c370728371137c6b88fded"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ace6f6adc11c370728371137c6b88fded"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ace6f6adc11c370728371137c6b88fded">dynamic_buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ace6f6adc11c370728371137c6b88fded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given string.  <a href="namespaceasio.html#ace6f6adc11c370728371137c6b88fded">Подробнее...</a><br /></td></tr>
<tr class="separator:ace6f6adc11c370728371137c6b88fded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaddfeb029fa95e3f6470d258ebe36f3"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:acaddfeb029fa95e3f6470d258ebe36f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#acaddfeb029fa95e3f6470d258ebe36f3">dynamic_buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size) noexcept</td></tr>
<tr class="memdesc:acaddfeb029fa95e3f6470d258ebe36f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given string.  <a href="namespaceasio.html#acaddfeb029fa95e3f6470d258ebe36f3">Подробнее...</a><br /></td></tr>
<tr class="separator:acaddfeb029fa95e3f6470d258ebe36f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a694b7ecee8746dafc8c99d194aeb68"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Allocator &gt; </td></tr>
<tr class="memitem:a8a694b7ecee8746dafc8c99d194aeb68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8a694b7ecee8746dafc8c99d194aeb68">dynamic_buffer</a> (std::vector&lt; Elem, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:a8a694b7ecee8746dafc8c99d194aeb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given vector.  <a href="namespaceasio.html#a8a694b7ecee8746dafc8c99d194aeb68">Подробнее...</a><br /></td></tr>
<tr class="separator:a8a694b7ecee8746dafc8c99d194aeb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae141ff85742cdbc7e1080a3a3af80d62"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Allocator &gt; </td></tr>
<tr class="memitem:ae141ff85742cdbc7e1080a3a3af80d62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae141ff85742cdbc7e1080a3a3af80d62">dynamic_buffer</a> (std::vector&lt; Elem, Allocator &gt; &amp;data, std::size_t max_size) noexcept</td></tr>
<tr class="memdesc:ae141ff85742cdbc7e1080a3a3af80d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given vector.  <a href="namespaceasio.html#ae141ff85742cdbc7e1080a3a3af80d62">Подробнее...</a><br /></td></tr>
<tr class="separator:ae141ff85742cdbc7e1080a3a3af80d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab876ca15e1fd4f5f12caa8e0cac327"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a9ab876ca15e1fd4f5f12caa8e0cac327"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9ab876ca15e1fd4f5f12caa8e0cac327">buffer_copy</a> (const MutableBufferSequence &amp;target, const ConstBufferSequence &amp;source) noexcept</td></tr>
<tr class="memdesc:a9ab876ca15e1fd4f5f12caa8e0cac327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer sequence to a target buffer sequence.  <a href="namespaceasio.html#a9ab876ca15e1fd4f5f12caa8e0cac327">Подробнее...</a><br /></td></tr>
<tr class="separator:a9ab876ca15e1fd4f5f12caa8e0cac327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f84f2c9b443140a1b8693c5491ffde4"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a4f84f2c9b443140a1b8693c5491ffde4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4f84f2c9b443140a1b8693c5491ffde4">buffer_copy</a> (const MutableBufferSequence &amp;target, const ConstBufferSequence &amp;source, std::size_t max_bytes_to_copy) noexcept</td></tr>
<tr class="separator:a4f84f2c9b443140a1b8693c5491ffde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479d7fa3ac4a25ebe9fef9fa40f88bb2"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a479d7fa3ac4a25ebe9fef9fa40f88bb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a479d7fa3ac4a25ebe9fef9fa40f88bb2">register_buffers</a> (const Executor &amp;ex, const MutableBufferSequence &amp;buffer_sequence, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a479d7fa3ac4a25ebe9fef9fa40f88bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register buffers with an execution context.  <a href="namespaceasio.html#a479d7fa3ac4a25ebe9fef9fa40f88bb2">Подробнее...</a><br /></td></tr>
<tr class="separator:a479d7fa3ac4a25ebe9fef9fa40f88bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae7adcb674ad70e29f093845916e620"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename MutableBufferSequence , typename Allocator &gt; </td></tr>
<tr class="memitem:a0ae7adcb674ad70e29f093845916e620"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0ae7adcb674ad70e29f093845916e620">register_buffers</a> (const Executor &amp;ex, const MutableBufferSequence &amp;buffer_sequence, const Allocator &amp;alloc, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a0ae7adcb674ad70e29f093845916e620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register buffers with an execution context.  <a href="namespaceasio.html#a0ae7adcb674ad70e29f093845916e620">Подробнее...</a><br /></td></tr>
<tr class="separator:a0ae7adcb674ad70e29f093845916e620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cc2487dc0e99f671d1fc545137f1a4"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ad2cc2487dc0e99f671d1fc545137f1a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad2cc2487dc0e99f671d1fc545137f1a4">register_buffers</a> (ExecutionContext &amp;ctx, const MutableBufferSequence &amp;buffer_sequence, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ad2cc2487dc0e99f671d1fc545137f1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register buffers with an execution context.  <a href="namespaceasio.html#ad2cc2487dc0e99f671d1fc545137f1a4">Подробнее...</a><br /></td></tr>
<tr class="separator:ad2cc2487dc0e99f671d1fc545137f1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bc5eecc15ae7f97b76bb4d1c80b983"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename MutableBufferSequence , typename Allocator &gt; </td></tr>
<tr class="memitem:ab1bc5eecc15ae7f97b76bb4d1c80b983"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt; MutableBufferSequence, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ab1bc5eecc15ae7f97b76bb4d1c80b983">register_buffers</a> (ExecutionContext &amp;ctx, const MutableBufferSequence &amp;buffer_sequence, const Allocator &amp;alloc, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ab1bc5eecc15ae7f97b76bb4d1c80b983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register buffers with an execution context.  <a href="namespaceasio.html#ab1bc5eecc15ae7f97b76bb4d1c80b983">Подробнее...</a><br /></td></tr>
<tr class="separator:ab1bc5eecc15ae7f97b76bb4d1c80b983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9d6099d23e9bf78b2b1ad82d164d3d7e">buffers_begin</a> (const BufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator representing the beginning of the buffers' data.  <a href="namespaceasio.html#a9d6099d23e9bf78b2b1ad82d164d3d7e">Подробнее...</a><br /></td></tr>
<tr class="separator:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef4b181d4561848de38fac7907d4a0b"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a2ef4b181d4561848de38fac7907d4a0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2ef4b181d4561848de38fac7907d4a0b">buffers_end</a> (const BufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:a2ef4b181d4561848de38fac7907d4a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator representing the end of the buffers' data.  <a href="namespaceasio.html#a2ef4b181d4561848de38fac7907d4a0b">Подробнее...</a><br /></td></tr>
<tr class="separator:a2ef4b181d4561848de38fac7907d4a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a82e92df79aa8401a8bc2117d4cf900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__all__t.html">detail::transfer_all_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">transfer_all</a> ()</td></tr>
<tr class="separator:a4a82e92df79aa8401a8bc2117d4cf900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b10af704afcd6c7ed7f0d3b740033ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__at__least__t.html">detail::transfer_at_least_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">transfer_at_least</a> (std::size_t minimum)</td></tr>
<tr class="separator:a2b10af704afcd6c7ed7f0d3b740033ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2ada9400d78a5df0e5f65dd2b9967e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__exactly__t.html">detail::transfer_exactly_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#adb2ada9400d78a5df0e5f65dd2b9967e">transfer_exactly</a> (std::size_t size)</td></tr>
<tr class="separator:adb2ada9400d78a5df0e5f65dd2b9967e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ea5e73f74a6dfa4cc01889fbacfc99"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename Signature , typename Implementation , typename... IoObjectsOrExecutors&gt; </td></tr>
<tr class="memitem:ae6ea5e73f74a6dfa4cc01889fbacfc99"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae6ea5e73f74a6dfa4cc01889fbacfc99">async_compose</a> (Implementation &amp;&amp;implementation, <a class="el" href="namespaceasio.html#ad943bac379d214a815ababf78040b051">type_identity_t</a>&lt; CompletionToken &gt; &amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, IoObjectsOrExecutors &amp;&amp;... io_objects_or_executors) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; CompletionToken, Signature &gt;(<a class="el" href="namespaceasio_1_1detail.html#afe104b4cace61ff8b235ddd3ffadcea9">detail::make_initiate_composed_op</a>&lt; Signature &gt;(<a class="el" href="namespaceasio_1_1detail.html#a908951adb6fcd5849b0fa9ddc0d297e5">detail::make_composed_io_executors</a>(<a class="el" href="namespaceasio_1_1detail.html#a390920449946d0e5b743593f9fa8ac27">detail::get_composed_io_executor</a>(static_cast&lt; IoObjectsOrExecutors &amp;&amp; &gt;(io_objects_or_executors))...)), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; Implementation &amp;&amp; &gt;(implementation)))</td></tr>
<tr class="memdesc:ae6ea5e73f74a6dfa4cc01889fbacfc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch an asynchronous operation with a stateful implementation.  <a href="namespaceasio.html#ae6ea5e73f74a6dfa4cc01889fbacfc99">Подробнее...</a><br /></td></tr>
<tr class="separator:ae6ea5e73f74a6dfa4cc01889fbacfc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9722498362a99a18c1daabb554ac3f7"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence &gt; </td></tr>
<tr class="memitem:ad9722498362a99a18c1daabb554ac3f7"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ad9722498362a99a18c1daabb554ac3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">Подробнее...</a><br /></td></tr>
<tr class="separator:ad9722498362a99a18c1daabb554ac3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abd764e6b852835571e5cb4c930bd7e"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence &gt; </td></tr>
<tr class="memitem:a5abd764e6b852835571e5cb4c930bd7e"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5abd764e6b852835571e5cb4c930bd7e">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a5abd764e6b852835571e5cb4c930bd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="namespaceasio.html#a5abd764e6b852835571e5cb4c930bd7e">Подробнее...</a><br /></td></tr>
<tr class="separator:a5abd764e6b852835571e5cb4c930bd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9236388f7582169e3db3ff52e8a38a11"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator &gt; </td></tr>
<tr class="memitem:a9236388f7582169e3db3ff52e8a38a11"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9236388f7582169e3db3ff52e8a38a11">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0)</td></tr>
<tr class="separator:a9236388f7582169e3db3ff52e8a38a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca5902654f85cf76894c70a5b6dff8c"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator &gt; </td></tr>
<tr class="memitem:a2ca5902654f85cf76894c70a5b6dff8c"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2ca5902654f85cf76894c70a5b6dff8c">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0)</td></tr>
<tr class="separator:a2ca5902654f85cf76894c70a5b6dff8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c58255744686dfcd930523d98bc0c2"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator &gt; </td></tr>
<tr class="memitem:aa8c58255744686dfcd930523d98bc0c2"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa8c58255744686dfcd930523d98bc0c2">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:aa8c58255744686dfcd930523d98bc0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="namespaceasio.html#aa8c58255744686dfcd930523d98bc0c2">Подробнее...</a><br /></td></tr>
<tr class="separator:aa8c58255744686dfcd930523d98bc0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be799cfeb2dc75e371ffba20d2e62db"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator &gt; </td></tr>
<tr class="memitem:a5be799cfeb2dc75e371ffba20d2e62db"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5be799cfeb2dc75e371ffba20d2e62db">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a5be799cfeb2dc75e371ffba20d2e62db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="namespaceasio.html#a5be799cfeb2dc75e371ffba20d2e62db">Подробнее...</a><br /></td></tr>
<tr class="separator:a5be799cfeb2dc75e371ffba20d2e62db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031d5e27ec81047da231bde839fb85bb"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:a031d5e27ec81047da231bde839fb85bb"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a031d5e27ec81047da231bde839fb85bb">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a031d5e27ec81047da231bde839fb85bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="namespaceasio.html#a031d5e27ec81047da231bde839fb85bb">Подробнее...</a><br /></td></tr>
<tr class="separator:a031d5e27ec81047da231bde839fb85bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade06be9648ccde981018a338c7632e45"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ade06be9648ccde981018a338c7632e45"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ade06be9648ccde981018a338c7632e45">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ade06be9648ccde981018a338c7632e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="namespaceasio.html#ade06be9648ccde981018a338c7632e45">Подробнее...</a><br /></td></tr>
<tr class="separator:ade06be9648ccde981018a338c7632e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5d277d4becd28d1ce842b06dd49fc3"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:a9e5d277d4becd28d1ce842b06dd49fc3"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9e5d277d4becd28d1ce842b06dd49fc3">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, ConnectCondition connect_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0)</td></tr>
<tr class="separator:a9e5d277d4becd28d1ce842b06dd49fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbda2bad32196cba1acb1c55e8de48c"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:acdbda2bad32196cba1acb1c55e8de48c"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#acdbda2bad32196cba1acb1c55e8de48c">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, ConnectCondition connect_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0)</td></tr>
<tr class="separator:acdbda2bad32196cba1acb1c55e8de48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f94719f8fa630e293df94e5819e4ba"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ad2f94719f8fa630e293df94e5819e4ba"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad2f94719f8fa630e293df94e5819e4ba">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end, ConnectCondition connect_condition)</td></tr>
<tr class="memdesc:ad2f94719f8fa630e293df94e5819e4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="namespaceasio.html#ad2f94719f8fa630e293df94e5819e4ba">Подробнее...</a><br /></td></tr>
<tr class="separator:ad2f94719f8fa630e293df94e5819e4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7be5e72ae43d07fced121d88f7b1e2"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:aec7be5e72ae43d07fced121d88f7b1e2"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aec7be5e72ae43d07fced121d88f7b1e2">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end, ConnectCondition connect_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aec7be5e72ae43d07fced121d88f7b1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="namespaceasio.html#aec7be5e72ae43d07fced121d88f7b1e2">Подробнее...</a><br /></td></tr>
<tr class="separator:aec7be5e72ae43d07fced121d88f7b1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebeb13d868fe4894497e23cff8a8f586"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, typename Protocol::endpoint)) RangeConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:aebeb13d868fe4894497e23cff8a8f586"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aebeb13d868fe4894497e23cff8a8f586">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, RangeConnectToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; RangeConnectToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__range__connect.html">detail::initiate_async_range_connect</a>&lt; Protocol, Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, endpoints, declval&lt; <a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a> &gt;()))</td></tr>
<tr class="separator:aebeb13d868fe4894497e23cff8a8f586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81058f1cca8a51244c6e48f192156cce"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a81058f1cca8a51244c6e48f192156cce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a81058f1cca8a51244c6e48f192156cce">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, IteratorConnectToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; IteratorConnectToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt; Protocol, Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, Iterator(), declval&lt; <a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a> &gt;()))</td></tr>
<tr class="separator:a81058f1cca8a51244c6e48f192156cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51be8c5a5131d75a429dd48571568fe"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:af51be8c5a5131d75a429dd48571568fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af51be8c5a5131d75a429dd48571568fe">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end, IteratorConnectToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;()) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; IteratorConnectToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt; Protocol, Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, end, declval&lt; <a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a> &gt;()))</td></tr>
<tr class="separator:af51be8c5a5131d75a429dd48571568fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779f9e4d80bfe1a45a60aff146f909b0"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, typename Protocol::endpoint)) RangeConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a779f9e4d80bfe1a45a60aff146f909b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a779f9e4d80bfe1a45a60aff146f909b0">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, RangeConnectToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; RangeConnectToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__range__connect.html">detail::initiate_async_range_connect</a>&lt; Protocol, Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, endpoints, connect_condition))</td></tr>
<tr class="separator:a779f9e4d80bfe1a45a60aff146f909b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731f44690527def78bf8a7f70c9c030e"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a731f44690527def78bf8a7f70c9c030e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a731f44690527def78bf8a7f70c9c030e">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, ConnectCondition connect_condition, IteratorConnectToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; IteratorConnectToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt; Protocol, Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, Iterator(), connect_condition))</td></tr>
<tr class="separator:a731f44690527def78bf8a7f70c9c030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6552bd57c7d027bf01cd226401d206"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:aab6552bd57c7d027bf01cd226401d206"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aab6552bd57c7d027bf01cd226401d206">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, Iterator begin, Iterator end, ConnectCondition connect_condition, IteratorConnectToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;()) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; IteratorConnectToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt; Protocol, Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, end, connect_condition))</td></tr>
<tr class="separator:aab6552bd57c7d027bf01cd226401d206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098a6ff85aafb5dde83726487338ad0b"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename... Values&gt; </td></tr>
<tr class="memitem:a098a6ff85aafb5dde83726487338ad0b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1consign__t.html">consign_t</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; CompletionToken &gt;, <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; Values &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a098a6ff85aafb5dde83726487338ad0b">consign</a> (CompletionToken &amp;&amp;completion_token, Values &amp;&amp;... values)</td></tr>
<tr class="separator:a098a6ff85aafb5dde83726487338ad0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22593523345cc52158f906f33a38cb15"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken&gt; </td></tr>
<tr class="memitem:a22593523345cc52158f906f33a38cb15"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a22593523345cc52158f906f33a38cb15">defer</a> (NullaryToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__defer.html">detail::initiate_defer</a> &gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a22593523345cc52158f906f33a38cb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="namespaceasio.html#a22593523345cc52158f906f33a38cb15">Подробнее...</a><br /></td></tr>
<tr class="separator:a22593523345cc52158f906f33a38cb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3804553f7845ac3c1adf58c5e872be92"><td class="memTemplParams" colspan="2">template&lt;typename Executor , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a3804553f7845ac3c1adf58c5e872be92"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3804553f7845ac3c1adf58c5e872be92">defer</a> (const Executor &amp;ex, NullaryToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;(<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &amp;&amp;<a class="el" href="structasio_1_1can__require.html">can_require</a>&lt; Executor, <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#ae363485c4c68b7d6dee9f9bb863e3877">execution::blocking_t::never_t</a> &gt;::value)||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__defer__with__executor.html">detail::initiate_defer_with_executor</a>&lt; Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a3804553f7845ac3c1adf58c5e872be92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="namespaceasio.html#a3804553f7845ac3c1adf58c5e872be92">Подробнее...</a><br /></td></tr>
<tr class="separator:a3804553f7845ac3c1adf58c5e872be92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771cc8268158afdb68d73c52398d4817"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a771cc8268158afdb68d73c52398d4817"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a771cc8268158afdb68d73c52398d4817">defer</a> (ExecutionContext &amp;ctx, NullaryToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; typename ExecutionContext::executor_type &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__defer__with__executor.html">detail::initiate_defer_with_executor</a>&lt; typename ExecutionContext::executor_type &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a771cc8268158afdb68d73c52398d4817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="namespaceasio.html#a771cc8268158afdb68d73c52398d4817">Подробнее...</a><br /></td></tr>
<tr class="separator:a771cc8268158afdb68d73c52398d4817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1502dd4243e9745eaad2753e5ee24c"><td class="memTemplParams" colspan="2">template&lt;typename Head , typename Tail &gt; </td></tr>
<tr class="memitem:acb1502dd4243e9745eaad2753e5ee24c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#acb1502dd4243e9745eaad2753e5ee24c">operator|</a> (Head head, Tail &amp;&amp;tail) -&gt; <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__deferred.html">is_deferred</a>&lt; Head &gt;::value, decltype(static_cast&lt; Head &amp;&amp; &gt;(head)(static_cast&lt; Tail &amp;&amp; &gt;(tail))) &gt;</td></tr>
<tr class="memdesc:acb1502dd4243e9745eaad2753e5ee24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe operator used to chain deferred operations.  <a href="namespaceasio.html#acb1502dd4243e9745eaad2753e5ee24c">Подробнее...</a><br /></td></tr>
<tr class="separator:acb1502dd4243e9745eaad2753e5ee24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f47493124a84c4bd4fd59c07e006a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a05f47493124a84c4bd4fd59c07e006a4">aligned_new</a> (std::size_t align, std::size_t size)</td></tr>
<tr class="separator:a05f47493124a84c4bd4fd59c07e006a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9671ab1d43c6f6ec3daff4f3416b8afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9671ab1d43c6f6ec3daff4f3416b8afc">aligned_delete</a> (<a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> *ptr)</td></tr>
<tr class="separator:a9671ab1d43c6f6ec3daff4f3416b8afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b53f4ff238fefdfbaf52153b89e6abd"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken&gt; </td></tr>
<tr class="memitem:a0b53f4ff238fefdfbaf52153b89e6abd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0b53f4ff238fefdfbaf52153b89e6abd">dispatch</a> (NullaryToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__dispatch.html">detail::initiate_dispatch</a> &gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a0b53f4ff238fefdfbaf52153b89e6abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="namespaceasio.html#a0b53f4ff238fefdfbaf52153b89e6abd">Подробнее...</a><br /></td></tr>
<tr class="separator:a0b53f4ff238fefdfbaf52153b89e6abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80db88672c1158f8662ac040ad6cb975"><td class="memTemplParams" colspan="2">template&lt;typename Executor , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a80db88672c1158f8662ac040ad6cb975"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a80db88672c1158f8662ac040ad6cb975">dispatch</a> (const Executor &amp;ex, NullaryToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__dispatch__with__executor.html">detail::initiate_dispatch_with_executor</a>&lt; Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a80db88672c1158f8662ac040ad6cb975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="namespaceasio.html#a80db88672c1158f8662ac040ad6cb975">Подробнее...</a><br /></td></tr>
<tr class="separator:a80db88672c1158f8662ac040ad6cb975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61872a90ad6c43350f9c0f0d4d1bcff7"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a61872a90ad6c43350f9c0f0d4d1bcff7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a61872a90ad6c43350f9c0f0d4d1bcff7">dispatch</a> (ExecutionContext &amp;ctx, NullaryToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; typename ExecutionContext::executor_type &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__dispatch__with__executor.html">detail::initiate_dispatch_with_executor</a>&lt; typename ExecutionContext::executor_type &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a61872a90ad6c43350f9c0f0d4d1bcff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="namespaceasio.html#a61872a90ad6c43350f9c0f0d4d1bcff7">Подробнее...</a><br /></td></tr>
<tr class="separator:a61872a90ad6c43350f9c0f0d4d1bcff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1776aa9a745f4da041978ce17abc44ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> const <a class="el" href="namespaceasio.html#ae434d49ea968ad09c18f44d08c98aaa4">error_category</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1776aa9a745f4da041978ce17abc44ff">system_category</a> ()</td></tr>
<tr class="memdesc:a1776aa9a745f4da041978ce17abc44ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error category used for the system errors produced by asio.  <a href="namespaceasio.html#a1776aa9a745f4da041978ce17abc44ff">Подробнее...</a><br /></td></tr>
<tr class="separator:a1776aa9a745f4da041978ce17abc44ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1810b2cc34a2ed373b761420a3d3a729"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a1810b2cc34a2ed373b761420a3d3a729"><td class="memTemplItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1810b2cc34a2ed373b761420a3d3a729">use_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;)</td></tr>
<tr class="separator:a1810b2cc34a2ed373b761420a3d3a729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d34f8c7897fc264ad87590429a7429a"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a0d34f8c7897fc264ad87590429a7429a"><td class="memTemplItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0d34f8c7897fc264ad87590429a7429a">use_service</a> (<a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;)</td></tr>
<tr class="separator:a0d34f8c7897fc264ad87590429a7429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf08702b1a8a7a6af573ca3ff6c402be"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:adf08702b1a8a7a6af573ca3ff6c402be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#adf08702b1a8a7a6af573ca3ff6c402be">add_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;, Service *)</td></tr>
<tr class="separator:adf08702b1a8a7a6af573ca3ff6c402be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e34e09c0ef0fc9a740fc96a62c4d2d5"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a2e34e09c0ef0fc9a740fc96a62c4d2d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2e34e09c0ef0fc9a740fc96a62c4d2d5">has_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;)</td></tr>
<tr class="separator:a2e34e09c0ef0fc9a740fc96a62c4d2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e1859adad251134e5c146b263fac5a"><td class="memTemplParams" colspan="2">template&lt;typename Executor &gt; </td></tr>
<tr class="memitem:a09e1859adad251134e5c146b263fac5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a09e1859adad251134e5c146b263fac5a">make_work_guard</a> (const Executor &amp;ex, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a09e1859adad251134e5c146b263fac5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <a href="namespaceasio.html#a09e1859adad251134e5c146b263fac5a">Подробнее...</a><br /></td></tr>
<tr class="separator:a09e1859adad251134e5c146b263fac5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38be2110c5123ceebc94f91971b93f31"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a38be2110c5123ceebc94f91971b93f31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename ExecutionContext::executor_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a38be2110c5123ceebc94f91971b93f31">make_work_guard</a> (ExecutionContext &amp;ctx, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a38be2110c5123ceebc94f91971b93f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <a href="namespaceasio.html#a38be2110c5123ceebc94f91971b93f31">Подробнее...</a><br /></td></tr>
<tr class="separator:a38be2110c5123ceebc94f91971b93f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274b320676965e3bd10bdcc8a2c24336"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a274b320676965e3bd10bdcc8a2c24336"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; T &gt;::value &amp;&amp;!is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value, <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a274b320676965e3bd10bdcc8a2c24336">make_work_guard</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a274b320676965e3bd10bdcc8a2c24336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <a href="namespaceasio.html#a274b320676965e3bd10bdcc8a2c24336">Подробнее...</a><br /></td></tr>
<tr class="separator:a274b320676965e3bd10bdcc8a2c24336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66586166967838d0924298cee3b042d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor &gt; </td></tr>
<tr class="memitem:a66586166967838d0924298cee3b042d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; <a class="el" href="namespaceasio.html#a947971ca8e87d2d9d7791b50b7fed58d">associated_executor_t</a>&lt; T, Executor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a66586166967838d0924298cee3b042d4">make_work_guard</a> (const T &amp;t, const Executor &amp;ex, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a66586166967838d0924298cee3b042d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <a href="namespaceasio.html#a66586166967838d0924298cee3b042d4">Подробнее...</a><br /></td></tr>
<tr class="separator:a66586166967838d0924298cee3b042d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34b7d3ea8eab4f3a308422c2772c62e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ad34b7d3ea8eab4f3a308422c2772c62e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; <a class="el" href="namespaceasio.html#a947971ca8e87d2d9d7791b50b7fed58d">associated_executor_t</a>&lt; T, typename ExecutionContext::executor_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad34b7d3ea8eab4f3a308422c2772c62e">make_work_guard</a> (const T &amp;t, ExecutionContext &amp;ctx, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; T &gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ad34b7d3ea8eab4f3a308422c2772c62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <a href="namespaceasio.html#ad34b7d3ea8eab4f3a308422c2772c62e">Подробнее...</a><br /></td></tr>
<tr class="separator:ad34b7d3ea8eab4f3a308422c2772c62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7613e3b437b2491c154e056f1a26668f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a7613e3b437b2491c154e056f1a26668f">asio_handler_is_continuation</a> (...)</td></tr>
<tr class="memdesc:a7613e3b437b2491c154e056f1a26668f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default continuation function for handlers.  <a href="namespaceasio.html#a7613e3b437b2491c154e056f1a26668f">Подробнее...</a><br /></td></tr>
<tr class="separator:a7613e3b437b2491c154e056f1a26668f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0d72619732becbd6a8aa9a1a831ca2"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename T , typename AwaitableExecutor , ASIO_COMPLETION_TOKEN_FOR(void(std::exception_ptr, T)) CompletionToken&gt; </td></tr>
<tr class="memitem:a7c0d72619732becbd6a8aa9a1a831ca2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a7c0d72619732becbd6a8aa9a1a831ca2">ASIO_INITFN_AUTO_RESULT_TYPE</a> (CompletionToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(std::exception_ptr, T)) co_spawn(const Executor &amp;ex</td></tr>
<tr class="separator:a7c0d72619732becbd6a8aa9a1a831ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcd6e783eb9d5fd4691c2cfa3e40f43"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename AwaitableExecutor , ASIO_COMPLETION_TOKEN_FOR(void(std::exception_ptr)) CompletionToken&gt; </td></tr>
<tr class="memitem:a5bcd6e783eb9d5fd4691c2cfa3e40f43"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5bcd6e783eb9d5fd4691c2cfa3e40f43">ASIO_INITFN_AUTO_RESULT_TYPE</a> (CompletionToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(std::exception_ptr)) co_spawn(const Executor &amp;ex</td></tr>
<tr class="separator:a5bcd6e783eb9d5fd4691c2cfa3e40f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280ea30802ca4f92b837d51ef9c60ee5"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename F , ASIO_COMPLETION_TOKEN_FOR(typename detail::awaitable_signature&lt; result_of_t&lt; F()&gt;&gt;::type) CompletionToken&gt; </td></tr>
<tr class="memitem:a280ea30802ca4f92b837d51ef9c60ee5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a280ea30802ca4f92b837d51ef9c60ee5">ASIO_INITFN_AUTO_RESULT_TYPE</a> (CompletionToken, typename detail::awaitable_signature&lt; <a class="el" href="namespaceasio.html#ae03d27556f68768ced98d0eac4a06afd">result_of_t</a>&lt; F()&gt;&gt;::type) co_spawn(const Executor &amp;ex</td></tr>
<tr class="separator:a280ea30802ca4f92b837d51ef9c60ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e72dd23c9362d084e639acace1d23c7"><td class="memTemplParams" colspan="2">template&lt;typename Service , typename... Args&gt; </td></tr>
<tr class="memitem:a9e72dd23c9362d084e639acace1d23c7"><td class="memTemplItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9e72dd23c9362d084e639acace1d23c7">make_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;e, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a9e72dd23c9362d084e639acace1d23c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac93adef3e5af6c68d5a0ce36a31ac6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2ac93adef3e5af6c68d5a0ce36a31ac6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceasio_1_1detail.html#a31c14df804409e01448213346a224e80">detail::io_context_impl</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2ac93adef3e5af6c68d5a0ce36a31ac6">use_service&lt; detail::io_context_impl &gt;</a> (<a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;ioc)</td></tr>
<tr class="separator:a2ac93adef3e5af6c68d5a0ce36a31ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631b112099009564a8489b63a33e32b5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a631b112099009564a8489b63a33e32b5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a631b112099009564a8489b63a33e32b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">Подробнее...</a><br /></td></tr>
<tr class="separator:a631b112099009564a8489b63a33e32b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1b66b2a02d69ef013a6c4624ac1b33"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a5a1b66b2a02d69ef013a6c4624ac1b33"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5a1b66b2a02d69ef013a6c4624ac1b33">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a5a1b66b2a02d69ef013a6c4624ac1b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a5a1b66b2a02d69ef013a6c4624ac1b33">Подробнее...</a><br /></td></tr>
<tr class="separator:a5a1b66b2a02d69ef013a6c4624ac1b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d5cec2634f5f444db542d796627711"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a32d5cec2634f5f444db542d796627711"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a32d5cec2634f5f444db542d796627711">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a32d5cec2634f5f444db542d796627711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a32d5cec2634f5f444db542d796627711">Подробнее...</a><br /></td></tr>
<tr class="separator:a32d5cec2634f5f444db542d796627711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022c8748d9ecfadccd38327387244ab7"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a022c8748d9ecfadccd38327387244ab7"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a022c8748d9ecfadccd38327387244ab7">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a022c8748d9ecfadccd38327387244ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a022c8748d9ecfadccd38327387244ab7">Подробнее...</a><br /></td></tr>
<tr class="separator:a022c8748d9ecfadccd38327387244ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c411da158a7ef94ed6e304beffae6"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a0e1c411da158a7ef94ed6e304beffae6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0e1c411da158a7ef94ed6e304beffae6">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a0e1c411da158a7ef94ed6e304beffae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a0e1c411da158a7ef94ed6e304beffae6">Подробнее...</a><br /></td></tr>
<tr class="separator:a0e1c411da158a7ef94ed6e304beffae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a58f94b6f250650e0e9dcdf4efdf72a"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:a3a58f94b6f250650e0e9dcdf4efdf72a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3a58f94b6f250650e0e9dcdf4efdf72a">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a3a58f94b6f250650e0e9dcdf4efdf72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a3a58f94b6f250650e0e9dcdf4efdf72a">Подробнее...</a><br /></td></tr>
<tr class="separator:a3a58f94b6f250650e0e9dcdf4efdf72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab546d1db1f4826ad961bbf51babd74f4"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:ab546d1db1f4826ad961bbf51babd74f4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ab546d1db1f4826ad961bbf51babd74f4">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ab546d1db1f4826ad961bbf51babd74f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#ab546d1db1f4826ad961bbf51babd74f4">Подробнее...</a><br /></td></tr>
<tr class="separator:ab546d1db1f4826ad961bbf51babd74f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a42b8438aa955e5bbf53a06586fe8fd"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a5a42b8438aa955e5bbf53a06586fe8fd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5a42b8438aa955e5bbf53a06586fe8fd">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a5a42b8438aa955e5bbf53a06586fe8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a5a42b8438aa955e5bbf53a06586fe8fd">Подробнее...</a><br /></td></tr>
<tr class="separator:a5a42b8438aa955e5bbf53a06586fe8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6038b695e95ef357b104f35a28edfe3d"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a6038b695e95ef357b104f35a28edfe3d"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a6038b695e95ef357b104f35a28edfe3d">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a6038b695e95ef357b104f35a28edfe3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a6038b695e95ef357b104f35a28edfe3d">Подробнее...</a><br /></td></tr>
<tr class="separator:a6038b695e95ef357b104f35a28edfe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeda9d140628ff399cbe4a076cb15cee"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:aaeda9d140628ff399cbe4a076cb15cee"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aaeda9d140628ff399cbe4a076cb15cee">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="memdesc:aaeda9d140628ff399cbe4a076cb15cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#aaeda9d140628ff399cbe4a076cb15cee">Подробнее...</a><br /></td></tr>
<tr class="separator:aaeda9d140628ff399cbe4a076cb15cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0bc3183df1291c7b2a35ec30d5428c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:abc0bc3183df1291c7b2a35ec30d5428c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#abc0bc3183df1291c7b2a35ec30d5428c">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:abc0bc3183df1291c7b2a35ec30d5428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#abc0bc3183df1291c7b2a35ec30d5428c">Подробнее...</a><br /></td></tr>
<tr class="separator:abc0bc3183df1291c7b2a35ec30d5428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadfb55ae835155abb8b6dc11a063b54"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:aeadfb55ae835155abb8b6dc11a063b54"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aeadfb55ae835155abb8b6dc11a063b54">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition)</td></tr>
<tr class="memdesc:aeadfb55ae835155abb8b6dc11a063b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#aeadfb55ae835155abb8b6dc11a063b54">Подробнее...</a><br /></td></tr>
<tr class="separator:aeadfb55ae835155abb8b6dc11a063b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e0fa9049de9257c2fd7f2911ffa3fd"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a06e0fa9049de9257c2fd7f2911ffa3fd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a06e0fa9049de9257c2fd7f2911ffa3fd">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a06e0fa9049de9257c2fd7f2911ffa3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a06e0fa9049de9257c2fd7f2911ffa3fd">Подробнее...</a><br /></td></tr>
<tr class="separator:a06e0fa9049de9257c2fd7f2911ffa3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e9ea0f6b103926654caf7acf87578"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:ae71e9ea0f6b103926654caf7acf87578"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae71e9ea0f6b103926654caf7acf87578">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ae71e9ea0f6b103926654caf7acf87578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#ae71e9ea0f6b103926654caf7acf87578">Подробнее...</a><br /></td></tr>
<tr class="separator:ae71e9ea0f6b103926654caf7acf87578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc36adb5f0d169ee071a8b975f31a91"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:a6cc36adb5f0d169ee071a8b975f31a91"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a6cc36adb5f0d169ee071a8b975f31a91">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a6cc36adb5f0d169ee071a8b975f31a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a6cc36adb5f0d169ee071a8b975f31a91">Подробнее...</a><br /></td></tr>
<tr class="separator:a6cc36adb5f0d169ee071a8b975f31a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b1028b8db552014dd3a038f46075ea"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a35b1028b8db552014dd3a038f46075ea"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a35b1028b8db552014dd3a038f46075ea">read</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a35b1028b8db552014dd3a038f46075ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="namespaceasio.html#a35b1028b8db552014dd3a038f46075ea">Подробнее...</a><br /></td></tr>
<tr class="separator:a35b1028b8db552014dd3a038f46075ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad686d881d915fd25eb761add24af9e75"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:ad686d881d915fd25eb761add24af9e75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad686d881d915fd25eb761add24af9e75">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read.html">detail::initiate_async_read</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:ad686d881d915fd25eb761add24af9e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062769b089b146e06a644df48c4e32aa"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a062769b089b146e06a644df48c4e32aa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a062769b089b146e06a644df48c4e32aa">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const MutableBufferSequence &amp;buffers, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read.html">detail::initiate_async_read</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a062769b089b146e06a644df48c4e32aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fe6ab0939cad6da2190818ffa4b8d1"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:ae3fe6ab0939cad6da2190818ffa4b8d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae3fe6ab0939cad6da2190818ffa4b8d1">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:ae3fe6ab0939cad6da2190818ffa4b8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23260781ee8346a7872eff0e51b037a5"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a23260781ee8346a7872eff0e51b037a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a23260781ee8346a7872eff0e51b037a5">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a23260781ee8346a7872eff0e51b037a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdedc8e67bdad64c8ef83dac8021b52"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:aebdedc8e67bdad64c8ef83dac8021b52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aebdedc8e67bdad64c8ef83dac8021b52">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:aebdedc8e67bdad64c8ef83dac8021b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6926d1f699f1b1fda72aa7c4d3125741"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a6926d1f699f1b1fda72aa7c4d3125741"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a6926d1f699f1b1fda72aa7c4d3125741">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a6926d1f699f1b1fda72aa7c4d3125741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d6d25d6a7f40eee7cf38634549f695"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a10d6d25d6a7f40eee7cf38634549f695"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a10d6d25d6a7f40eee7cf38634549f695">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v2.html">detail::initiate_async_read_dynbuf_v2</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a10d6d25d6a7f40eee7cf38634549f695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53897322b95c74daeb021d39edfd6cd0"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a53897322b95c74daeb021d39edfd6cd0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a53897322b95c74daeb021d39edfd6cd0">async_read</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v2.html">detail::initiate_async_read_dynbuf_v2</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a53897322b95c74daeb021d39edfd6cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88604242259da9fb0bacf3c4f0cc0002"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a88604242259da9fb0bacf3c4f0cc0002"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a88604242259da9fb0bacf3c4f0cc0002">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a88604242259da9fb0bacf3c4f0cc0002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef7a26ff401494d673ad462a3f3f5c0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a4ef7a26ff401494d673ad462a3f3f5c0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4ef7a26ff401494d673ad462a3f3f5c0">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers)</td></tr>
<tr class="separator:a4ef7a26ff401494d673ad462a3f3f5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6587e766e26325457154a5dac2a0b785"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a6587e766e26325457154a5dac2a0b785"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a6587e766e26325457154a5dac2a0b785">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a6587e766e26325457154a5dac2a0b785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16ebd52ad98e521ea4b75676d4db9fd"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:aa16ebd52ad98e521ea4b75676d4db9fd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa16ebd52ad98e521ea4b75676d4db9fd">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition)</td></tr>
<tr class="separator:aa16ebd52ad98e521ea4b75676d4db9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926222f6d0bb8a716a17161a1eb725aa"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a926222f6d0bb8a716a17161a1eb725aa"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a926222f6d0bb8a716a17161a1eb725aa">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a926222f6d0bb8a716a17161a1eb725aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301406c670bc22190df6e8628cbf0037"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:a301406c670bc22190df6e8628cbf0037"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a301406c670bc22190df6e8628cbf0037">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="separator:a301406c670bc22190df6e8628cbf0037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4511bad893697fc58d379d6e00aa84ff"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:a4511bad893697fc58d379d6e00aa84ff"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4511bad893697fc58d379d6e00aa84ff">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a4511bad893697fc58d379d6e00aa84ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0126c00568f324b47c24b494c97ece14"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a0126c00568f324b47c24b494c97ece14"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0126c00568f324b47c24b494c97ece14">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition)</td></tr>
<tr class="separator:a0126c00568f324b47c24b494c97ece14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3e2f9690fef3e01df80513906c4658"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:afb3e2f9690fef3e01df80513906c4658"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#afb3e2f9690fef3e01df80513906c4658">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at.html">detail::initiate_async_read_at</a>&lt; AsyncRandomAccessReadDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:afb3e2f9690fef3e01df80513906c4658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2da6a1b552029a80b606dfb58ad80a"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename MutableBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a7e2da6a1b552029a80b606dfb58ad80a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a7e2da6a1b552029a80b606dfb58ad80a">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at.html">detail::initiate_async_read_at</a>&lt; AsyncRandomAccessReadDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a7e2da6a1b552029a80b606dfb58ad80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d52e0bb20d0e0ccf2d948906c7409b0"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a1d52e0bb20d0e0ccf2d948906c7409b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1d52e0bb20d0e0ccf2d948906c7409b0">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at__streambuf.html">detail::initiate_async_read_at_streambuf</a>&lt; AsyncRandomAccessReadDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a1d52e0bb20d0e0ccf2d948906c7409b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289ecb2e4aad891c8367133b14c11134"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a289ecb2e4aad891c8367133b14c11134"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a289ecb2e4aad891c8367133b14c11134">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at__streambuf.html">detail::initiate_async_read_at_streambuf</a>&lt; AsyncRandomAccessReadDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a289ecb2e4aad891c8367133b14c11134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2910ba892099b5f30c18e346a5cc6c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:adf2910ba892099b5f30c18e346a5cc6c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, char delim, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;)</td></tr>
<tr class="separator:adf2910ba892099b5f30c18e346a5cc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6605f31a2f18ae729ba0a19324e632"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:a0e6605f31a2f18ae729ba0a19324e632"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0e6605f31a2f18ae729ba0a19324e632">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, char delim, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;)</td></tr>
<tr class="separator:a0e6605f31a2f18ae729ba0a19324e632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2980433deecca66ed3e8337d33abdfd8"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:a2980433deecca66ed3e8337d33abdfd8"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2980433deecca66ed3e8337d33abdfd8">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;)</td></tr>
<tr class="separator:a2980433deecca66ed3e8337d33abdfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52ffc4323125340012557d3f755b6f7"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:ae52ffc4323125340012557d3f755b6f7"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae52ffc4323125340012557d3f755b6f7">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;)</td></tr>
<tr class="separator:ae52ffc4323125340012557d3f755b6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d3fafe135ad976654c7278ce009775"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition &gt; </td></tr>
<tr class="memitem:a44d3fafe135ad976654c7278ce009775"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a44d3fafe135ad976654c7278ce009775">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, MatchCondition match_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;)</td></tr>
<tr class="separator:a44d3fafe135ad976654c7278ce009775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fdf1b135435f7ed959c61a89dfa260"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition &gt; </td></tr>
<tr class="memitem:af4fdf1b135435f7ed959c61a89dfa260"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af4fdf1b135435f7ed959c61a89dfa260">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, MatchCondition match_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;)</td></tr>
<tr class="separator:af4fdf1b135435f7ed959c61a89dfa260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aae2baa82596a6a9ad320e80b016006"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:a1aae2baa82596a6a9ad320e80b016006"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1aae2baa82596a6a9ad320e80b016006">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim)</td></tr>
<tr class="memdesc:a1aae2baa82596a6a9ad320e80b016006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="namespaceasio.html#a1aae2baa82596a6a9ad320e80b016006">Подробнее...</a><br /></td></tr>
<tr class="separator:a1aae2baa82596a6a9ad320e80b016006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ab9d265cc5b757caf9c9a602da2d6a3e5">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ab9d265cc5b757caf9c9a602da2d6a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="namespaceasio.html#ab9d265cc5b757caf9c9a602da2d6a3e5">Подробнее...</a><br /></td></tr>
<tr class="separator:ab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a433d903eae4dd097bc2c55efbf1ee"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:a03a433d903eae4dd097bc2c55efbf1ee"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a03a433d903eae4dd097bc2c55efbf1ee">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim)</td></tr>
<tr class="memdesc:a03a433d903eae4dd097bc2c55efbf1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="namespaceasio.html#a03a433d903eae4dd097bc2c55efbf1ee">Подробнее...</a><br /></td></tr>
<tr class="separator:a03a433d903eae4dd097bc2c55efbf1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78faf8cf08d47515162de95b18b0a860"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:a78faf8cf08d47515162de95b18b0a860"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a78faf8cf08d47515162de95b18b0a860">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a78faf8cf08d47515162de95b18b0a860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="namespaceasio.html#a78faf8cf08d47515162de95b18b0a860">Подробнее...</a><br /></td></tr>
<tr class="separator:a78faf8cf08d47515162de95b18b0a860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8372fc4edf57763c49ed1f8cf42e6a4f"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:a8372fc4edf57763c49ed1f8cf42e6a4f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8372fc4edf57763c49ed1f8cf42e6a4f">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a8372fc4edf57763c49ed1f8cf42e6a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <a href="namespaceasio.html#a8372fc4edf57763c49ed1f8cf42e6a4f">Подробнее...</a><br /></td></tr>
<tr class="separator:a8372fc4edf57763c49ed1f8cf42e6a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02f689946ae31e0c60cdaa926419f43"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:ab02f689946ae31e0c60cdaa926419f43"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ab02f689946ae31e0c60cdaa926419f43">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ab02f689946ae31e0c60cdaa926419f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <a href="namespaceasio.html#ab02f689946ae31e0c60cdaa926419f43">Подробнее...</a><br /></td></tr>
<tr class="separator:ab02f689946ae31e0c60cdaa926419f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab935fe986ec9477db62af1e7d514e6ed"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:ab935fe986ec9477db62af1e7d514e6ed"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ab935fe986ec9477db62af1e7d514e6ed">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, char delim, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:ab935fe986ec9477db62af1e7d514e6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cb7c507ff2509dc675e040ebce3338"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:ae9cb7c507ff2509dc675e040ebce3338"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae9cb7c507ff2509dc675e040ebce3338">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, char delim, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:ae9cb7c507ff2509dc675e040ebce3338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc4d5ec4ec23d9aec3cdf8ae4e76872"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:a0bc4d5ec4ec23d9aec3cdf8ae4e76872"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0bc4d5ec4ec23d9aec3cdf8ae4e76872">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:a0bc4d5ec4ec23d9aec3cdf8ae4e76872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7a79fc07a0a5dcbb8ac5c4e9658466"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:a9d7a79fc07a0a5dcbb8ac5c4e9658466"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9d7a79fc07a0a5dcbb8ac5c4e9658466">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:a9d7a79fc07a0a5dcbb8ac5c4e9658466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c499c6a5bf36dfe4eae35c9afdb76a2"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition &gt; </td></tr>
<tr class="memitem:a8c499c6a5bf36dfe4eae35c9afdb76a2"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8c499c6a5bf36dfe4eae35c9afdb76a2">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, MatchCondition match_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:a8c499c6a5bf36dfe4eae35c9afdb76a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d2663e7af5457346f4463d16e4237a"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition &gt; </td></tr>
<tr class="memitem:a57d2663e7af5457346f4463d16e4237a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a57d2663e7af5457346f4463d16e4237a">read_until</a> (SyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, MatchCondition match_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;)</td></tr>
<tr class="separator:a57d2663e7af5457346f4463d16e4237a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad1e914adbdf6f6114f6b339929e567"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a3ad1e914adbdf6f6114f6b339929e567"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3ad1e914adbdf6f6114f6b339929e567">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, char delim, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v1.html">detail::initiate_async_read_until_delim_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), delim))</td></tr>
<tr class="separator:a3ad1e914adbdf6f6114f6b339929e567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b8c7f7b5dca9540b846756a3ff44d7"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a62b8c7f7b5dca9540b846756a3ff44d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a62b8c7f7b5dca9540b846756a3ff44d7">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v1.html">detail::initiate_async_read_until_delim_string_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), static_cast&lt; std::string &gt;(delim)))</td></tr>
<tr class="separator:a62b8c7f7b5dca9540b846756a3ff44d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e2b9e0203c3bf154ad13a9919b52a1"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:ab1e2b9e0203c3bf154ad13a9919b52a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ab1e2b9e0203c3bf154ad13a9919b52a1">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, MatchCondition match_condition, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v1.html">detail::initiate_async_read_until_match_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), match_condition))</td></tr>
<tr class="separator:ab1e2b9e0203c3bf154ad13a9919b52a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad031c3f6eaf5829d17ce2caa6318ae8"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:aad031c3f6eaf5829d17ce2caa6318ae8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aad031c3f6eaf5829d17ce2caa6318ae8">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v1.html">detail::initiate_async_read_until_delim_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), delim))</td></tr>
<tr class="separator:aad031c3f6eaf5829d17ce2caa6318ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5ced357513dc5138ae582ad97d1d11"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:adc5ced357513dc5138ae582ad97d1d11"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#adc5ced357513dc5138ae582ad97d1d11">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v1.html">detail::initiate_async_read_until_delim_string_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), static_cast&lt; std::string &gt;(delim)))</td></tr>
<tr class="separator:adc5ced357513dc5138ae582ad97d1d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0045b6048d9d6d577bc11a3ff0c717"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename MatchCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a9f0045b6048d9d6d577bc11a3ff0c717"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9f0045b6048d9d6d577bc11a3ff0c717">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v1.html">detail::initiate_async_read_until_match_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), match_condition))</td></tr>
<tr class="separator:a9f0045b6048d9d6d577bc11a3ff0c717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d739462073c9d8c28ebf8ac04a3bbed"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a3d739462073c9d8c28ebf8ac04a3bbed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3d739462073c9d8c28ebf8ac04a3bbed">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, char delim, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v2.html">detail::initiate_async_read_until_delim_v2</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), delim))</td></tr>
<tr class="separator:a3d739462073c9d8c28ebf8ac04a3bbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2482cd1728656c93008e415475f6eccc"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a2482cd1728656c93008e415475f6eccc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2482cd1728656c93008e415475f6eccc">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> delim, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v2.html">detail::initiate_async_read_until_delim_string_v2</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), static_cast&lt; std::string &gt;(delim)))</td></tr>
<tr class="separator:a2482cd1728656c93008e415475f6eccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331200c3f73e54b6e22b55133dab6ffd"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </td></tr>
<tr class="memitem:a331200c3f73e54b6e22b55133dab6ffd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a331200c3f73e54b6e22b55133dab6ffd">async_read_until</a> (AsyncReadStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, MatchCondition match_condition, ReadToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v2.html">detail::initiate_async_read_until_match_v2</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), match_condition))</td></tr>
<tr class="separator:a331200c3f73e54b6e22b55133dab6ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66f1b3121cdb136eb23189c00b5bad4"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename F , ASIO_COMPLETION_TOKEN_FOR(typename detail::spawn_signature&lt; result_of_t&lt; F(basic_yield_context&lt; Executor &gt;)&gt;&gt;::type) CompletionToken&gt; </td></tr>
<tr class="memitem:aa66f1b3121cdb136eb23189c00b5bad4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa66f1b3121cdb136eb23189c00b5bad4">spawn</a> (const Executor &amp;ex, F &amp;&amp;function, CompletionToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="namespaceasio.html#ae03d27556f68768ced98d0eac4a06afd">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt;&gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td></tr>
<tr class="memdesc:aa66f1b3121cdb136eb23189c00b5bad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given executor.  <a href="namespaceasio.html#aa66f1b3121cdb136eb23189c00b5bad4">Подробнее...</a><br /></td></tr>
<tr class="separator:aa66f1b3121cdb136eb23189c00b5bad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a451e464208bbebc81d95561bbe2fdf"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename F , ASIO_COMPLETION_TOKEN_FOR(typename detail::spawn_signature&lt; result_of_t&lt; F(basic_yield_context&lt; typename ExecutionContext::executor_type &gt;)&gt;&gt;::type) CompletionToken&gt; </td></tr>
<tr class="memitem:a2a451e464208bbebc81d95561bbe2fdf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2a451e464208bbebc81d95561bbe2fdf">spawn</a> (ExecutionContext &amp;ctx, F &amp;&amp;function, CompletionToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; typename ExecutionContext::executor_type &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) -&gt; decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="namespaceasio.html#ae03d27556f68768ced98d0eac4a06afd">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; typename ExecutionContext::executor_type &gt;)&gt;&gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; typename ExecutionContext::executor_type &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td></tr>
<tr class="memdesc:a2a451e464208bbebc81d95561bbe2fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given execution context.  <a href="namespaceasio.html#a2a451e464208bbebc81d95561bbe2fdf">Подробнее...</a><br /></td></tr>
<tr class="separator:a2a451e464208bbebc81d95561bbe2fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50c06820bfd7c45e903818bdc2bb578"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename F , ASIO_COMPLETION_TOKEN_FOR(typename detail::spawn_signature&lt; result_of_t&lt; F(basic_yield_context&lt; Executor &gt;)&gt;&gt;::type) CompletionToken&gt; </td></tr>
<tr class="memitem:aa50c06820bfd7c45e903818bdc2bb578"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa50c06820bfd7c45e903818bdc2bb578">spawn</a> (const <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt; &amp;ctx, F &amp;&amp;function, CompletionToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="namespaceasio.html#ae03d27556f68768ced98d0eac4a06afd">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt;&gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td></tr>
<tr class="memdesc:aa50c06820bfd7c45e903818bdc2bb578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine, inheriting the executor of another.  <a href="namespaceasio.html#aa50c06820bfd7c45e903818bdc2bb578">Подробнее...</a><br /></td></tr>
<tr class="separator:aa50c06820bfd7c45e903818bdc2bb578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f08eda862b625adefbacb69a97d475"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a62f08eda862b625adefbacb69a97d475"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a62f08eda862b625adefbacb69a97d475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">Подробнее...</a><br /></td></tr>
<tr class="separator:a62f08eda862b625adefbacb69a97d475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c18920cf77046e1a78823245148256e"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a0c18920cf77046e1a78823245148256e"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0c18920cf77046e1a78823245148256e">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a0c18920cf77046e1a78823245148256e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="namespaceasio.html#a0c18920cf77046e1a78823245148256e">Подробнее...</a><br /></td></tr>
<tr class="separator:a0c18920cf77046e1a78823245148256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86befc1c843c2b0a1dae51cb7696a23"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ae86befc1c843c2b0a1dae51cb7696a23"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae86befc1c843c2b0a1dae51cb7696a23">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ae86befc1c843c2b0a1dae51cb7696a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="namespaceasio.html#ae86befc1c843c2b0a1dae51cb7696a23">Подробнее...</a><br /></td></tr>
<tr class="separator:ae86befc1c843c2b0a1dae51cb7696a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a4f9019cc125d0290171f0c186166e"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a46a4f9019cc125d0290171f0c186166e"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a46a4f9019cc125d0290171f0c186166e">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a46a4f9019cc125d0290171f0c186166e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="namespaceasio.html#a46a4f9019cc125d0290171f0c186166e">Подробнее...</a><br /></td></tr>
<tr class="separator:a46a4f9019cc125d0290171f0c186166e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62498a9eca8616498e67c01b4b4bac58"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a62498a9eca8616498e67c01b4b4bac58"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a62498a9eca8616498e67c01b4b4bac58">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a62498a9eca8616498e67c01b4b4bac58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="namespaceasio.html#a62498a9eca8616498e67c01b4b4bac58">Подробнее...</a><br /></td></tr>
<tr class="separator:a62498a9eca8616498e67c01b4b4bac58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bc4d0643f807559cb1bf545c1051a9"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:af5bc4d0643f807559cb1bf545c1051a9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af5bc4d0643f807559cb1bf545c1051a9">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:af5bc4d0643f807559cb1bf545c1051a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="namespaceasio.html#af5bc4d0643f807559cb1bf545c1051a9">Подробнее...</a><br /></td></tr>
<tr class="separator:af5bc4d0643f807559cb1bf545c1051a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca810c91f23c73f89cb89b8cd45494c"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 &gt; </td></tr>
<tr class="memitem:abca810c91f23c73f89cb89b8cd45494c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#abca810c91f23c73f89cb89b8cd45494c">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:abca810c91f23c73f89cb89b8cd45494c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="namespaceasio.html#abca810c91f23c73f89cb89b8cd45494c">Подробнее...</a><br /></td></tr>
<tr class="separator:abca810c91f23c73f89cb89b8cd45494c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38d4fdf1fff53bd865bf20e9cd95ab9"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ac38d4fdf1fff53bd865bf20e9cd95ab9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac38d4fdf1fff53bd865bf20e9cd95ab9">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ac38d4fdf1fff53bd865bf20e9cd95ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="namespaceasio.html#ac38d4fdf1fff53bd865bf20e9cd95ab9">Подробнее...</a><br /></td></tr>
<tr class="separator:ac38d4fdf1fff53bd865bf20e9cd95ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393e12e427f89cb932c6a2bd800236fb"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a393e12e427f89cb932c6a2bd800236fb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a393e12e427f89cb932c6a2bd800236fb">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a393e12e427f89cb932c6a2bd800236fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="namespaceasio.html#a393e12e427f89cb932c6a2bd800236fb">Подробнее...</a><br /></td></tr>
<tr class="separator:a393e12e427f89cb932c6a2bd800236fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85807d13da87adf48b62979f65f41152"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator &gt; </td></tr>
<tr class="memitem:a85807d13da87adf48b62979f65f41152"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a85807d13da87adf48b62979f65f41152">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="memdesc:a85807d13da87adf48b62979f65f41152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="namespaceasio.html#a85807d13da87adf48b62979f65f41152">Подробнее...</a><br /></td></tr>
<tr class="separator:a85807d13da87adf48b62979f65f41152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator &gt; </td></tr>
<tr class="memitem:af72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af72f7eddd7d4629ea2e2b7f5b7f355bc">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:af72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="namespaceasio.html#af72f7eddd7d4629ea2e2b7f5b7f355bc">Подробнее...</a><br /></td></tr>
<tr class="separator:af72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80988391fb309ee53cc557d0065550a"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:aa80988391fb309ee53cc557d0065550a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa80988391fb309ee53cc557d0065550a">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition)</td></tr>
<tr class="memdesc:aa80988391fb309ee53cc557d0065550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="namespaceasio.html#aa80988391fb309ee53cc557d0065550a">Подробнее...</a><br /></td></tr>
<tr class="separator:aa80988391fb309ee53cc557d0065550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353faf23a7bcb2c3fc3022506b292d4a"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a353faf23a7bcb2c3fc3022506b292d4a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a353faf23a7bcb2c3fc3022506b292d4a">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a353faf23a7bcb2c3fc3022506b292d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="namespaceasio.html#a353faf23a7bcb2c3fc3022506b292d4a">Подробнее...</a><br /></td></tr>
<tr class="separator:a353faf23a7bcb2c3fc3022506b292d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af982fe40762c23e1eb4ea166b4019208"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:af982fe40762c23e1eb4ea166b4019208"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af982fe40762c23e1eb4ea166b4019208">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:af982fe40762c23e1eb4ea166b4019208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="namespaceasio.html#af982fe40762c23e1eb4ea166b4019208">Подробнее...</a><br /></td></tr>
<tr class="separator:af982fe40762c23e1eb4ea166b4019208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eabfb4da832af9df0f85696c8022727"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 &gt; </td></tr>
<tr class="memitem:a5eabfb4da832af9df0f85696c8022727"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5eabfb4da832af9df0f85696c8022727">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a5eabfb4da832af9df0f85696c8022727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="namespaceasio.html#a5eabfb4da832af9df0f85696c8022727">Подробнее...</a><br /></td></tr>
<tr class="separator:a5eabfb4da832af9df0f85696c8022727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a6eb174ec37a28df640469f970b102"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ac3a6eb174ec37a28df640469f970b102"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac3a6eb174ec37a28df640469f970b102">write</a> (SyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ac3a6eb174ec37a28df640469f970b102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="namespaceasio.html#ac3a6eb174ec37a28df640469f970b102">Подробнее...</a><br /></td></tr>
<tr class="separator:ac3a6eb174ec37a28df640469f970b102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505e7a885317c073053fb7f252cc7b04"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename ConstBufferSequence , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:a505e7a885317c073053fb7f252cc7b04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a505e7a885317c073053fb7f252cc7b04">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write.html">detail::initiate_async_write</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a505e7a885317c073053fb7f252cc7b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72b992e102c1bebe5dca6f7bcb436d7"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename ConstBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:aa72b992e102c1bebe5dca6f7bcb436d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa72b992e102c1bebe5dca6f7bcb436d7">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, const ConstBufferSequence &amp;buffers, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write.html">detail::initiate_async_write</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:aa72b992e102c1bebe5dca6f7bcb436d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8aff82f1f0a456c8bd8d63ae4b4b37"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename DynamicBuffer_v1 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:a8a8aff82f1f0a456c8bd8d63ae4b4b37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8a8aff82f1f0a456c8bd8d63ae4b4b37">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a8a8aff82f1f0a456c8bd8d63ae4b4b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de7473e8cbaa0c1454b95200636749f"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:a0de7473e8cbaa0c1454b95200636749f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a0de7473e8cbaa0c1454b95200636749f">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v1 &amp;&amp;buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a0de7473e8cbaa0c1454b95200636749f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab510e035996445e9879684d81579673"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:aab510e035996445e9879684d81579673"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aab510e035996445e9879684d81579673">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:aab510e035996445e9879684d81579673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3e08fa509649b8dd26cca294e4b371"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename Allocator , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:a1d3e08fa509649b8dd26cca294e4b371"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1d3e08fa509649b8dd26cca294e4b371">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a1d3e08fa509649b8dd26cca294e4b371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efc5ef2e4b428464ba08bb83aea6129"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename DynamicBuffer_v2 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:a4efc5ef2e4b428464ba08bb83aea6129"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4efc5ef2e4b428464ba08bb83aea6129">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v2.html">detail::initiate_async_write_dynbuf_v2</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a4efc5ef2e4b428464ba08bb83aea6129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac482a6b720fbbe2688afa1e69ab0a129"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:ac482a6b720fbbe2688afa1e69ab0a129"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac482a6b720fbbe2688afa1e69ab0a129">async_write</a> (AsyncWriteStream &amp;<a class="el" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>, DynamicBuffer_v2 buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v2.html">detail::initiate_async_write_dynbuf_v2</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:ac482a6b720fbbe2688afa1e69ab0a129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51133c1e260b8abeeed55646e765fdd6"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a51133c1e260b8abeeed55646e765fdd6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a51133c1e260b8abeeed55646e765fdd6">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a51133c1e260b8abeeed55646e765fdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="namespaceasio.html#a51133c1e260b8abeeed55646e765fdd6">Подробнее...</a><br /></td></tr>
<tr class="separator:a51133c1e260b8abeeed55646e765fdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add67a05a29d183782491d14aceec7d41"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:add67a05a29d183782491d14aceec7d41"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#add67a05a29d183782491d14aceec7d41">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:add67a05a29d183782491d14aceec7d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="namespaceasio.html#add67a05a29d183782491d14aceec7d41">Подробнее...</a><br /></td></tr>
<tr class="separator:add67a05a29d183782491d14aceec7d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1abcb5870505ea2a0c524a59638da0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a8c1abcb5870505ea2a0c524a59638da0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8c1abcb5870505ea2a0c524a59638da0">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a8c1abcb5870505ea2a0c524a59638da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="namespaceasio.html#a8c1abcb5870505ea2a0c524a59638da0">Подробнее...</a><br /></td></tr>
<tr class="separator:a8c1abcb5870505ea2a0c524a59638da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6b2f5dd13f4273695fbf0cdec0314a"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a3e6b2f5dd13f4273695fbf0cdec0314a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3e6b2f5dd13f4273695fbf0cdec0314a">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition)</td></tr>
<tr class="memdesc:a3e6b2f5dd13f4273695fbf0cdec0314a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="namespaceasio.html#a3e6b2f5dd13f4273695fbf0cdec0314a">Подробнее...</a><br /></td></tr>
<tr class="separator:a3e6b2f5dd13f4273695fbf0cdec0314a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431966af634f0701ceac7f54fc1b0371"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a431966af634f0701ceac7f54fc1b0371"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a431966af634f0701ceac7f54fc1b0371">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a431966af634f0701ceac7f54fc1b0371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="namespaceasio.html#a431966af634f0701ceac7f54fc1b0371">Подробнее...</a><br /></td></tr>
<tr class="separator:a431966af634f0701ceac7f54fc1b0371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db1f75a907c17918092b41f2f242104"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:a1db1f75a907c17918092b41f2f242104"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1db1f75a907c17918092b41f2f242104">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="memdesc:a1db1f75a907c17918092b41f2f242104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="namespaceasio.html#a1db1f75a907c17918092b41f2f242104">Подробнее...</a><br /></td></tr>
<tr class="separator:a1db1f75a907c17918092b41f2f242104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f42435acf937c35ee4c81af44ee6ce"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:aa6f42435acf937c35ee4c81af44ee6ce"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa6f42435acf937c35ee4c81af44ee6ce">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aa6f42435acf937c35ee4c81af44ee6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="namespaceasio.html#aa6f42435acf937c35ee4c81af44ee6ce">Подробнее...</a><br /></td></tr>
<tr class="separator:aa6f42435acf937c35ee4c81af44ee6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e23f5418309ba130d75f6757b7b8e15"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a2e23f5418309ba130d75f6757b7b8e15"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2e23f5418309ba130d75f6757b7b8e15">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition)</td></tr>
<tr class="memdesc:a2e23f5418309ba130d75f6757b7b8e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="namespaceasio.html#a2e23f5418309ba130d75f6757b7b8e15">Подробнее...</a><br /></td></tr>
<tr class="separator:a2e23f5418309ba130d75f6757b7b8e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff40274147e80d3b902b3a719f979e3a"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:aff40274147e80d3b902b3a719f979e3a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aff40274147e80d3b902b3a719f979e3a">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at.html">detail::initiate_async_write_at</a>&lt; AsyncRandomAccessWriteDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:aff40274147e80d3b902b3a719f979e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007ae4a9e3ecea6b02ebeed8dd7f855f"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:a007ae4a9e3ecea6b02ebeed8dd7f855f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a007ae4a9e3ecea6b02ebeed8dd7f855f">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at.html">detail::initiate_async_write_at</a>&lt; AsyncRandomAccessWriteDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a007ae4a9e3ecea6b02ebeed8dd7f855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d21c5fbc0b6ac9839d1023307aae129"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:a1d21c5fbc0b6ac9839d1023307aae129"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1d21c5fbc0b6ac9839d1023307aae129">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at__streambuf.html">detail::initiate_async_write_at_streambuf</a>&lt; AsyncRandomAccessWriteDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td></tr>
<tr class="separator:a1d21c5fbc0b6ac9839d1023307aae129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22aebde0039839b99cfd2e7973ec519d"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </td></tr>
<tr class="memitem:a22aebde0039839b99cfd2e7973ec519d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a22aebde0039839b99cfd2e7973ec519d">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, WriteToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at__streambuf.html">detail::initiate_async_write_at_streambuf</a>&lt; AsyncRandomAccessWriteDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td></tr>
<tr class="separator:a22aebde0039839b99cfd2e7973ec519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96ddebcabf9c7f1524f803bc063a62b"><td class="memTemplParams" colspan="2">template&lt;ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken&gt; </td></tr>
<tr class="memitem:ab96ddebcabf9c7f1524f803bc063a62b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b">post</a> (NullaryToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__post.html">detail::initiate_post</a> &gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:ab96ddebcabf9c7f1524f803bc063a62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b">Подробнее...</a><br /></td></tr>
<tr class="separator:ab96ddebcabf9c7f1524f803bc063a62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e26b0422e66c6dbc1b161830964d2c9"><td class="memTemplParams" colspan="2">template&lt;typename Executor , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:a1e26b0422e66c6dbc1b161830964d2c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1e26b0422e66c6dbc1b161830964d2c9">post</a> (const Executor &amp;ex, NullaryToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; Executor &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;(<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &amp;&amp;<a class="el" href="structasio_1_1can__require.html">can_require</a>&lt; Executor, <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#ae363485c4c68b7d6dee9f9bb863e3877">execution::blocking_t::never_t</a> &gt;::value)||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__post__with__executor.html">detail::initiate_post_with_executor</a>&lt; Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a1e26b0422e66c6dbc1b161830964d2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="namespaceasio.html#a1e26b0422e66c6dbc1b161830964d2c9">Подробнее...</a><br /></td></tr>
<tr class="separator:a1e26b0422e66c6dbc1b161830964d2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04753b6108fc896cc453f89c28bebbb6"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </td></tr>
<tr class="memitem:a04753b6108fc896cc453f89c28bebbb6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a04753b6108fc896cc453f89c28bebbb6">post</a> (ExecutionContext &amp;ctx, NullaryToken &amp;&amp;<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>=<a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt; typename ExecutionContext::executor_type &gt;(), <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0) -&gt; decltype(<a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__post__with__executor.html">detail::initiate_post_with_executor</a>&lt; typename ExecutionContext::executor_type &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))</td></tr>
<tr class="memdesc:a04753b6108fc896cc453f89c28bebbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="namespaceasio.html#a04753b6108fc896cc453f89c28bebbb6">Подробнее...</a><br /></td></tr>
<tr class="separator:a04753b6108fc896cc453f89c28bebbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316656e80eb9e91ec172ae49f001df9e"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken , typename... Values&gt; </td></tr>
<tr class="memitem:a316656e80eb9e91ec172ae49f001df9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1prepend__t.html">prepend_t</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; CompletionToken &gt;, <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; Values &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a316656e80eb9e91ec172ae49f001df9e">prepend</a> (CompletionToken &amp;&amp;completion_token, Values &amp;&amp;... values)</td></tr>
<tr class="separator:a316656e80eb9e91ec172ae49f001df9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb265a718a670a944c524da5482b8c0"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:affb265a718a670a944c524da5482b8c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1redirect__error__t.html">redirect_error_t</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; CompletionToken &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#affb265a718a670a944c524da5482b8c0">redirect_error</a> (CompletionToken &amp;&amp;completion_token, <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:affb265a718a670a944c524da5482b8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a completion_token to capture error_code values to a variable.  <a href="namespaceasio.html#affb265a718a670a944c524da5482b8c0">Подробнее...</a><br /></td></tr>
<tr class="separator:affb265a718a670a944c524da5482b8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbb11e9cf940e24d3220e9b37c17964"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5fbb11e9cf940e24d3220e9b37c17964">buffer_sequence_begin</a> (const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a5fbb11e9cf940e24d3220e9b37c17964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <a href="namespaceasio.html#a5fbb11e9cf940e24d3220e9b37c17964">Подробнее...</a><br /></td></tr>
<tr class="separator:a5fbb11e9cf940e24d3220e9b37c17964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48be03d3d92b51e047630441999a7033"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a48be03d3d92b51e047630441999a7033">buffer_sequence_begin</a> (const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a48be03d3d92b51e047630441999a7033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <a href="namespaceasio.html#a48be03d3d92b51e047630441999a7033">Подробнее...</a><br /></td></tr>
<tr class="separator:a48be03d3d92b51e047630441999a7033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484d9fbc9f5b149a3867b807945da77f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a484d9fbc9f5b149a3867b807945da77f">buffer_sequence_end</a> (const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a484d9fbc9f5b149a3867b807945da77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <a href="namespaceasio.html#a484d9fbc9f5b149a3867b807945da77f">Подробнее...</a><br /></td></tr>
<tr class="separator:a484d9fbc9f5b149a3867b807945da77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb2439fdacc7d489e9dcd774c93f21d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1cb2439fdacc7d489e9dcd774c93f21d">buffer_sequence_end</a> (const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a1cb2439fdacc7d489e9dcd774c93f21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <a href="namespaceasio.html#a1cb2439fdacc7d489e9dcd774c93f21d">Подробнее...</a><br /></td></tr>
<tr class="separator:a1cb2439fdacc7d489e9dcd774c93f21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe13ad24e316f94e7ff8a197ac2a40be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#afe13ad24e316f94e7ff8a197ac2a40be">buffer</a> (const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:afe13ad24e316f94e7ff8a197ac2a40be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a buffer representing the entire registered buffer.  <a href="namespaceasio.html#afe13ad24e316f94e7ff8a197ac2a40be">Подробнее...</a><br /></td></tr>
<tr class="separator:afe13ad24e316f94e7ff8a197ac2a40be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bc6057a4682b36c1180b56107ff160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a83bc6057a4682b36c1180b56107ff160">buffer</a> (const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a83bc6057a4682b36c1180b56107ff160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a buffer representing the entire registered buffer.  <a href="namespaceasio.html#a83bc6057a4682b36c1180b56107ff160">Подробнее...</a><br /></td></tr>
<tr class="separator:a83bc6057a4682b36c1180b56107ff160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacafdf44af129753e05ba770785b4acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aacafdf44af129753e05ba770785b4acc">buffer</a> (const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;b, std::size_t n) noexcept</td></tr>
<tr class="memdesc:aacafdf44af129753e05ba770785b4acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a buffer representing part of a registered buffer.  <a href="namespaceasio.html#aacafdf44af129753e05ba770785b4acc">Подробнее...</a><br /></td></tr>
<tr class="separator:aacafdf44af129753e05ba770785b4acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa87a00e12c0e47cf34203dfb2c3ef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aaaa87a00e12c0e47cf34203dfb2c3ef1">buffer</a> (const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;b, std::size_t n) noexcept</td></tr>
<tr class="memdesc:aaaa87a00e12c0e47cf34203dfb2c3ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a buffer representing part of a registered buffer.  <a href="namespaceasio.html#aaaa87a00e12c0e47cf34203dfb2c3ef1">Подробнее...</a><br /></td></tr>
<tr class="separator:aaaa87a00e12c0e47cf34203dfb2c3ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f1fd1cb6a3fa85681fea378fef6abb"><td class="memTemplParams" colspan="2">template&lt;typename Executor &gt; </td></tr>
<tr class="memitem:ad8f1fd1cb6a3fa85681fea378fef6abb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1strand.html">strand</a>&lt; Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad8f1fd1cb6a3fa85681fea378fef6abb">make_strand</a> (const Executor &amp;ex, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:ad8f1fd1cb6a3fa85681fea378fef6abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an executor.  <a href="namespaceasio.html#ad8f1fd1cb6a3fa85681fea378fef6abb">Подробнее...</a><br /></td></tr>
<tr class="separator:ad8f1fd1cb6a3fa85681fea378fef6abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63385b38f9c6d5c54c2791a8a903dd07"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a63385b38f9c6d5c54c2791a8a903dd07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1strand.html">strand</a>&lt; typename ExecutionContext::executor_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a63385b38f9c6d5c54c2791a8a903dd07">make_strand</a> (ExecutionContext &amp;ctx, <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;=0)</td></tr>
<tr class="memdesc:a63385b38f9c6d5c54c2791a8a903dd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an execution context.  <a href="namespaceasio.html#a63385b38f9c6d5c54c2791a8a903dd07">Подробнее...</a><br /></td></tr>
<tr class="separator:a63385b38f9c6d5c54c2791a8a903dd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Переменные</h2></td></tr>
<tr class="memitem:a3a930211f940077a2cd1fb88532f9a9d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classasio_1_1deferred__t.html">deferred_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3a930211f940077a2cd1fb88532f9a9d">deferred</a></td></tr>
<tr class="separator:a3a930211f940077a2cd1fb88532f9a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc282e2ffff99631f6d194d893c12bc0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classasio_1_1detached__t.html">detached_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#adc282e2ffff99631f6d194d893c12bc0">detached</a></td></tr>
<tr class="separator:adc282e2ffff99631f6d194d893c12bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80c4033469ae5aaa092c0d49852403c"><td class="memItemLeft" align="right" valign="top">awaitable&lt; T, AwaitableExecutor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a></td></tr>
<tr class="separator:aa80c4033469ae5aaa092c0d49852403c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff1e9f7bb336026f18afa2221c9df07"><td class="memItemLeft" align="right" valign="top">awaitable&lt; T, AwaitableExecutor &gt; CompletionToken &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a></td></tr>
<tr class="separator:adff1e9f7bb336026f18afa2221c9df07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac172b717c13db01d7f99af7e42edcb68"><td class="memItemLeft" align="right" valign="top">F &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac172b717c13db01d7f99af7e42edcb68">f</a></td></tr>
<tr class="separator:ac172b717c13db01d7f99af7e42edcb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8d07aef5f11fbd332259ad52db3eeb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structasio_1_1executor__arg__t.html">executor_arg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2f8d07aef5f11fbd332259ad52db3eeb">executor_arg</a></td></tr>
<tr class="separator:a2f8d07aef5f11fbd332259ad52db3eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Типы</h2>
<a id="ab5f5a4bba64d7b519ebdf44fd19a491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f5a4bba64d7b519ebdf44fd19a491f">&#9670;&nbsp;</a></span>add_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#ab5f5a4bba64d7b519ebdf44fd19a491f">asio::add_const_t</a> = typedef typename std::add_const&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e8e6f159ea11c2c055614ef353a69fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8e6f159ea11c2c055614ef353a69fd">&#9670;&nbsp;</a></span>add_lvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a2e8e6f159ea11c2c055614ef353a69fd">asio::add_lvalue_reference_t</a> = typedef typename std::add_lvalue_reference&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f2428214df6ad5b92cba3999fc6d25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2428214df6ad5b92cba3999fc6d25e">&#9670;&nbsp;</a></span>aligned_storage_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, std::size_t A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a6f2428214df6ad5b92cba3999fc6d25e">asio::aligned_storage_t</a> = typedef typename <a class="el" href="structasio_1_1aligned__storage.html">aligned_storage</a>&lt;N, A&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36a2efaadb823ea5daa2722235f03b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a2efaadb823ea5daa2722235f03b79">&#9670;&nbsp;</a></span>associated_allocator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a36a2efaadb823ea5daa2722235f03b79">asio::associated_allocator_t</a> = typedef typename <a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt;T, Allocator&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7abd10b459023e652684747584eaf567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abd10b459023e652684747584eaf567">&#9670;&nbsp;</a></span>associated_cancellation_slot_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename CancellationSlot  = cancellation_slot&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a7abd10b459023e652684747584eaf567">asio::associated_cancellation_slot_t</a> = typedef typename <a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a>&lt;T, CancellationSlot&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a947971ca8e87d2d9d7791b50b7fed58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947971ca8e87d2d9d7791b50b7fed58d">&#9670;&nbsp;</a></span>associated_executor_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor  = system_executor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a947971ca8e87d2d9d7791b50b7fed58d">asio::associated_executor_t</a> = typedef typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T, Executor&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a5218562467927b84b03f687a29578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5218562467927b84b03f687a29578f">&#9670;&nbsp;</a></span>associated_immediate_executor_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a8a5218562467927b84b03f687a29578f">asio::associated_immediate_executor_t</a> = typedef typename <a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a>&lt;T, Executor&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d85a0e28424dfdf416a9a812841606b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d85a0e28424dfdf416a9a812841606b">&#9670;&nbsp;</a></span>cancellation_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type</a> <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7335867dac5c662e8386346c9669d710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7335867dac5c662e8386346c9669d710">&#9670;&nbsp;</a></span>completion_signature_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a7335867dac5c662e8386346c9669d710">asio::completion_signature_of_t</a> = typedef typename <a class="el" href="structasio_1_1completion__signature__of.html">completion_signature_of</a>&lt;T, Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0332484df24f23affcc056f9085b8a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0332484df24f23affcc056f9085b8a92">&#9670;&nbsp;</a></span>conditional_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool C, typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a0332484df24f23affcc056f9085b8a92">asio::conditional_t</a> = typedef typename std::conditional&lt;C, T, U&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8f73389553384e0af82754b8491f177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f73389553384e0af82754b8491f177">&#9670;&nbsp;</a></span>constraint_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Condition, typename Type  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">F CompletionToken <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">asio::constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Инициализатор</b><div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> async_initiate&lt;CompletionToken, void(std::exception_ptr, T)&gt;(</div>
<div class="line">      detail::initiate_co_spawn&lt;AwaitableExecutor&gt;(AwaitableExecutor(ex)),</div>
<div class="line">      <a class="code" href="bind__immediate__executor_8cpp.html#a87da3d8264af1c9427605148f20dd9c4">token</a>, detail::awaitable_as_function&lt;T, AwaitableExecutor&gt;(std::move(<a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>)))</div>
<div class="ttc" id="abind__immediate__executor_8cpp_html_a87da3d8264af1c9427605148f20dd9c4"><div class="ttname"><a href="bind__immediate__executor_8cpp.html#a87da3d8264af1c9427605148f20dd9c4">token</a></div><div class="ttdeci">token</div><div class="ttdef"><b>Definition:</b> bind_immediate_executor.cpp:50</div></div>
<div class="ttc" id="anamespaceasio_html_aa80c4033469ae5aaa092c0d49852403c"><div class="ttname"><a href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">asio::a</a></div><div class="ttdeci">awaitable&lt; T, AwaitableExecutor &gt; a</div><div class="ttdef"><b>Definition:</b> co_spawn.hpp:342</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d03dfdd5dd0ffa4aaf6832eda695664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d03dfdd5dd0ffa4aaf6832eda695664">&#9670;&nbsp;</a></span>decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">asio::decay_t</a> = typedef typename std::decay&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84bbc083cf9153b28ce2d86c3ea16458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bbc083cf9153b28ce2d86c3ea16458">&#9670;&nbsp;</a></span>default_completion_token_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">asio::default_completion_token_t</a> = typedef typename <a class="el" href="structasio_1_1default__completion__token.html">default_completion_token</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c7be67c717fae6f2e1b186573b74b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7be67c717fae6f2e1b186573b74b44">&#9670;&nbsp;</a></span>disable_cancellation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a334c4a4c42fdb79d7ebc3e73b517e6f8">cancellation_type::none</a>&gt; <a class="el" href="namespaceasio.html#a8c7be67c717fae6f2e1b186573b74b44">asio::disable_cancellation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A cancellation filter that disables cancellation. </p>

</div>
</div>
<a id="a847109104af3016e3bb18a8ab5b2123c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847109104af3016e3bb18a8ab5b2123c">&#9670;&nbsp;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool C, typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a847109104af3016e3bb18a8ab5b2123c">asio::enable_if_t</a> = typedef typename std::enable_if&lt;C, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29d149df79dc30ac3e926e1ec85e5849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d149df79dc30ac3e926e1ec85e5849">&#9670;&nbsp;</a></span>enable_partial_cancellation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; static_cast&lt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a>&gt; static_cast&lt;unsigned int&gt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>) | static_cast&lt;unsigned int&gt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a>))&gt; <a class="el" href="namespaceasio.html#a29d149df79dc30ac3e926e1ec85e5849">asio::enable_partial_cancellation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bbee6470702e960e05ea7d244173a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbee6470702e960e05ea7d244173a53">&#9670;&nbsp;</a></span>enable_terminal_cancellation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>&gt; <a class="el" href="namespaceasio.html#a8bbee6470702e960e05ea7d244173a53">asio::enable_terminal_cancellation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A cancellation filter that enables terminal cancellation only. </p>

</div>
</div>
<a id="aed9b0c348b4e739128d5bf18fb87a0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9b0c348b4e739128d5bf18fb87a0e3">&#9670;&nbsp;</a></span>enable_total_cancellation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio_1_1cancellation__filter.html">cancellation_filter</a>&lt; static_cast&lt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">cancellation_type_t</a>&gt; static_cast&lt;unsigned int&gt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a>) | static_cast&lt;unsigned int&gt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a>) | static_cast&lt;unsigned int&gt;<a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6afbb44b4487415b134bce9c790a27fe5e">cancellation_type::total</a>))&gt; <a class="el" href="namespaceasio.html#aed9b0c348b4e739128d5bf18fb87a0e3">asio::enable_total_cancellation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae434d49ea968ad09c18f44d08c98aaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae434d49ea968ad09c18f44d08c98aaa4">&#9670;&nbsp;</a></span>error_category</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::error_category <a class="el" href="namespaceasio.html#ae434d49ea968ad09c18f44d08c98aaa4">asio::error_category</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8914468bc40252ae5e5c666adb951cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8914468bc40252ae5e5c666adb951cf">&#9670;&nbsp;</a></span>error_code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::error_code <a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac62851a86dfa77e72fd80d2e6ccab76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62851a86dfa77e72fd80d2e6ccab76f">&#9670;&nbsp;</a></span>high_resolution_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::high_resolution_clock &gt; <a class="el" href="namespaceasio.html#ac62851a86dfa77e72fd80d2e6ccab76f">asio::high_resolution_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a timer based on the high resolution clock. </p>
<p>This typedef uses the C++11 <code>&lt;chrono&gt;</code> standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality.">basic_waitable_timer</a> template directly: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> basic_waitable_timer&lt;boost::chrono::high_resolution_clock&gt; <a class="code" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>;</div>
<div class="ttc" id="abind__allocator_8cpp_html_af1abddd6ed87a43a672d1f851b84a694"><div class="ttname"><a href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a></div><div class="ttdeci">steady_timer timer</div><div class="ttdef"><b>Definition:</b> bind_allocator.cpp:37</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8904bd25ca421af4140ab7ac95b0b956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8904bd25ca421af4140ab7ac95b0b956">&#9670;&nbsp;</a></span>io_service</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1io__context.html">io_context</a> <a class="el" href="namespaceasio.html#a8904bd25ca421af4140ab7ac95b0b956">asio::io_service</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for backwards compatibility. </p>

</div>
</div>
<a id="a5793dc026a52e88c629a8cb3fded0d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5793dc026a52e88c629a8cb3fded0d26">&#9670;&nbsp;</a></span>prefer_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Properties&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a5793dc026a52e88c629a8cb3fded0d26">asio::prefer_result_t</a> = typedef typename <a class="el" href="structasio_1_1prefer__result.html">prefer_result</a>&lt;T, Properties...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55201409b23036671550beeb6cc3b94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55201409b23036671550beeb6cc3b94e">&#9670;&nbsp;</a></span>prefer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio__prefer__fn_1_1impl.html">asio_prefer_fn::impl</a> <a class="el" href="namespaceasio.html#a55201409b23036671550beeb6cc3b94e">asio::prefer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa91495cbc0319a786cc883e78f1f463d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91495cbc0319a786cc883e78f1f463d">&#9670;&nbsp;</a></span>query_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Property &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#aa91495cbc0319a786cc883e78f1f463d">asio::query_result_t</a> = typedef typename <a class="el" href="structasio_1_1query__result.html">query_result</a>&lt;T, Property&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aecee0160ad9fd66180683316b4846d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecee0160ad9fd66180683316b4846d4b">&#9670;&nbsp;</a></span>query_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio__query__fn_1_1impl.html">asio_query_fn::impl</a> <a class="el" href="namespaceasio.html#aecee0160ad9fd66180683316b4846d4b">asio::query_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f56d824eb0ac784f9040d69cb5c9b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f56d824eb0ac784f9040d69cb5c9b02">&#9670;&nbsp;</a></span>remove_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a4f56d824eb0ac784f9040d69cb5c9b02">asio::remove_cv_t</a> = typedef typename std::remove_cv&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afce63a7f0a33f1ca68320eb2bca47fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce63a7f0a33f1ca68320eb2bca47fb4">&#9670;&nbsp;</a></span>remove_cvref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#afce63a7f0a33f1ca68320eb2bca47fb4">asio::remove_cvref_t</a> = typedef typename <a class="el" href="structasio_1_1remove__cvref.html">remove_cvref</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7ed0be1096cd3f9ba4758a7ce1f3294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ed0be1096cd3f9ba4758a7ce1f3294">&#9670;&nbsp;</a></span>remove_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#ad7ed0be1096cd3f9ba4758a7ce1f3294">asio::remove_pointer_t</a> = typedef typename std::remove_pointer&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34192a90d4d961bbd9f1a5264be0e081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34192a90d4d961bbd9f1a5264be0e081">&#9670;&nbsp;</a></span>remove_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">asio::remove_reference_t</a> = typedef typename std::remove_reference&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb141fa42dd3edf2f777105b8d246988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb141fa42dd3edf2f777105b8d246988">&#9670;&nbsp;</a></span>require_concept_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Property &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#abb141fa42dd3edf2f777105b8d246988">asio::require_concept_result_t</a> = typedef typename <a class="el" href="structasio_1_1require__concept__result.html">require_concept_result</a>&lt;T, Property&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23510e91b2cc59d7d19e64f6a0f0b64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23510e91b2cc59d7d19e64f6a0f0b64f">&#9670;&nbsp;</a></span>require_concept_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio__require__concept__fn_1_1impl.html">asio_require_concept_fn::impl</a> <a class="el" href="namespaceasio.html#a23510e91b2cc59d7d19e64f6a0f0b64f">asio::require_concept_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a663cc02e852bddcae88370910e172af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663cc02e852bddcae88370910e172af1">&#9670;&nbsp;</a></span>require_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Properties&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a663cc02e852bddcae88370910e172af1">asio::require_result_t</a> = typedef typename <a class="el" href="structasio_1_1require__result.html">require_result</a>&lt;T, Properties...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f6bab0c8ad8c073a605675ec7232926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6bab0c8ad8c073a605675ec7232926">&#9670;&nbsp;</a></span>require_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structasio__require__fn_1_1impl.html">asio_require_fn::impl</a> <a class="el" href="namespaceasio.html#a0f6bab0c8ad8c073a605675ec7232926">asio::require_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae03d27556f68768ced98d0eac4a06afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03d27556f68768ced98d0eac4a06afd">&#9670;&nbsp;</a></span>result_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#ae03d27556f68768ced98d0eac4a06afd">asio::result_of_t</a> = typedef typename std::result_of&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f135fc124cc60e4e00dc2dbb309f354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f135fc124cc60e4e00dc2dbb309f354">&#9670;&nbsp;</a></span>signal_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a> <a class="el" href="namespaceasio.html#a4f135fc124cc60e4e00dc2dbb309f354">asio::signal_set</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the typical usage of a signal set. </p>

</div>
</div>
<a id="af97767413ad2526e9941d17f112b5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97767413ad2526e9941d17f112b5018">&#9670;&nbsp;</a></span>static_thread_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1thread__pool.html">thread_pool</a> <a class="el" href="namespaceasio.html#af97767413ad2526e9941d17f112b5018">asio::static_thread_pool</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a627a7abd2bc87969838f17e46b8dc20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627a7abd2bc87969838f17e46b8dc20d">&#9670;&nbsp;</a></span>steady_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::steady_clock &gt; <a class="el" href="namespaceasio.html#a627a7abd2bc87969838f17e46b8dc20d">asio::steady_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a timer based on the steady clock. </p>
<p>This typedef uses the C++11 <code>&lt;chrono&gt;</code> standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality.">basic_waitable_timer</a> template directly: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> basic_waitable_timer&lt;boost::chrono::steady_clock&gt; <a class="code" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6a7ba348943527312eeace3492bf32ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7ba348943527312eeace3492bf32ee">&#9670;&nbsp;</a></span>streambuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a> <a class="el" href="namespaceasio.html#a6a7ba348943527312eeace3492bf32ee">asio::streambuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the typical usage of <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a>. </p>

</div>
</div>
<a id="ac5e0b6db67d52eba50e168ae78c1a049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e0b6db67d52eba50e168ae78c1a049">&#9670;&nbsp;</a></span>system_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::system_error <a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9afc37336b3232b8b291ab23e98a9201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afc37336b3232b8b291ab23e98a9201">&#9670;&nbsp;</a></span>system_executor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__system__executor.html">basic_system_executor</a>&lt;<a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#a0ee9cc739b3b11aa5a584a4310a47e22">execution::blocking_t::possibly_t</a>, <a class="el" href="structasio_1_1execution_1_1detail_1_1relationship__t.html#ad59f7aede6089578c4505b171e27369b">execution::relationship_t::fork_t</a>, std::allocator&lt;<a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>&gt; &gt; <a class="el" href="namespaceasio.html#a9afc37336b3232b8b291ab23e98a9201">asio::system_executor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An executor that uses arbitrary threads. </p>
<p>The system executor represents an execution context where functions are permitted to run on arbitrary threads. When the blocking.never property is established, the system executor will schedule the function to run on an unspecified system thread pool. When either blocking.possibly or blocking.always is established, the executor invokes the function immediately. </p>

</div>
</div>
<a id="a2d65c694154683a53496180854859975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d65c694154683a53496180854859975">&#9670;&nbsp;</a></span>system_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::system_clock &gt; <a class="el" href="namespaceasio.html#a2d65c694154683a53496180854859975">asio::system_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a timer based on the system clock. </p>
<p>This typedef uses the C++11 <code>&lt;chrono&gt;</code> standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality.">basic_waitable_timer</a> template directly: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> basic_waitable_timer&lt;boost::chrono::system_clock&gt; <a class="code" href="bind__allocator_8cpp.html#af1abddd6ed87a43a672d1f851b84a694">timer</a>;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad943bac379d214a815ababf78040b051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad943bac379d214a815ababf78040b051">&#9670;&nbsp;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#ad943bac379d214a815ababf78040b051">asio::type_identity_t</a> = typedef typename <a class="el" href="structasio_1_1type__identity.html">type_identity</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05e34b80842ec318c893ca4eb6316c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e34b80842ec318c893ca4eb6316c42">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasio.html#a05e34b80842ec318c893ca4eb6316c42">asio::void_t</a> = typedef typename <a class="el" href="structasio_1_1void__type.html">void_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09b73624bafbe0c55f0da6b594cbc886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b73624bafbe0c55f0da6b594cbc886">&#9670;&nbsp;</a></span>yield_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt;<a class="el" href="classasio_1_1any__io__executor.html">any_io_executor</a>&gt; <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">asio::yield_context</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A completion_token object that represents the currently executing coroutine. </p>

</div>
</div>
<h2 class="groupheader">Перечисления</h2>
<a id="ae02aa651224af4b25dc476fc01ce29f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02aa651224af4b25dc476fc01ce29f6">&#9670;&nbsp;</a></span>cancellation_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> : unsigned int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Элементы перечислений</th></tr><tr><td class="fieldname"><a id="ae02aa651224af4b25dc476fc01ce29f6a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb"></a>terminal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f"></a>partial&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae02aa651224af4b25dc476fc01ce29f6afbb44b4487415b134bce9c790a27fe5e"></a>total&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae02aa651224af4b25dc476fc01ce29f6aa181a603769c1f98ad927e7367c7aa51"></a>all&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Функции</h2>
<a id="adf08702b1a8a7a6af573ca3ff6c402be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf08702b1a8a7a6af573ca3ff6c402be">&#9670;&nbsp;</a></span>add_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> asio::add_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Service *&#160;</td>
          <td class="paramname"><em>svc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use <a class="el" href="namespaceasio.html#a9e72dd23c9362d084e639acace1d23c7">make_service()</a>.) Add a service object to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>. This function is used to add a service to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
    <tr><td class="paramname">svc</td><td>The service object. On success, ownership of the service object is transferred to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>. When the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object is destroyed, it will destroy the service object by performing:<div class="fragment"><div class="line"><span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>execution_context::service*<span class="keyword">&gt;</span>(svc) </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1service__already__exists.html">asio::service_already_exists</a></td><td>Thrown if a service of the given type is already present in the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>.</td></tr>
    <tr><td class="paramname"><a class="el" href="classasio_1_1invalid__service__owner.html">asio::invalid_service_owner</a></td><td>Thrown if the service's owning <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> is not the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object specified by the <code>e</code> parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9671ab1d43c6f6ec3daff4f3416b8afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9671ab1d43c6f6ec3daff4f3416b8afc">&#9670;&nbsp;</a></span>aligned_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> asio::aligned_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05f47493124a84c4bd4fd59c07e006a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f47493124a84c4bd4fd59c07e006a4">&#9670;&nbsp;</a></span>aligned_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>* asio::aligned_new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09fd5a7dd30ae955ea23bab8217d9489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fd5a7dd30ae955ea23bab8217d9489">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename... Values&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1append__t.html">append_t</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;CompletionToken&gt;, <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;Values&gt;...&gt; asio::append </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>completion_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Values &amp;&amp;...&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Completion token type used to specify that the completion handler arguments should be passed additional values after the results of the operation. </p>

</div>
</div>
<a id="a4ea102f8b62f7d43a164036cfd504e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea102f8b62f7d43a164036cfd504e56">&#9670;&nbsp;</a></span>as_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1as__tuple__t.html">as_tuple_t</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;CompletionToken&gt; &gt; asio::as_tuple </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>completion_token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adapt a completion_token to specify that the completion handler arguments should be combined into a single tuple argument. </p>

</div>
</div>
<a id="a7613e3b437b2491c154e056f1a26668f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7613e3b437b2491c154e056f1a26668f">&#9670;&nbsp;</a></span>asio_handler_is_continuation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool asio::asio_handler_is_continuation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default continuation function for handlers. </p>
<p>Asynchronous operations may represent a continuation of the asynchronous control flow associated with the current handler. The implementation can use this knowledge to optimise scheduling of the handler.</p>
<p>Implement asio_handler_is_continuation for your own handlers to indicate when a handler represents a continuation.</p>
<p>The default implementation of the continuation hook returns <code>false</code>.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">class </span>my_handler;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="namespaceasio.html#a7613e3b437b2491c154e056f1a26668f">asio_handler_is_continuation</a>(my_handler* <a class="code" href="namespaceasio_1_1execution.html#adebdf38d8a61e5145c9d6b51730e6a74">context</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceasio_1_1execution_html_adebdf38d8a61e5145c9d6b51730e6a74"><div class="ttname"><a href="namespaceasio_1_1execution.html#adebdf38d8a61e5145c9d6b51730e6a74">asio::execution::context</a></div><div class="ttdeci">constexpr context_t context</div><div class="ttdef"><b>Definition:</b> context.hpp:141</div></div>
<div class="ttc" id="anamespaceasio_html_a7613e3b437b2491c154e056f1a26668f"><div class="ttname"><a href="namespaceasio.html#a7613e3b437b2491c154e056f1a26668f">asio::asio_handler_is_continuation</a></div><div class="ttdeci">bool asio_handler_is_continuation(...)</div><div class="ttdoc">Default continuation function for handlers.</div><div class="ttdef"><b>Definition:</b> handler_continuation_hook.hpp:45</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a280ea30802ca4f92b837d51ef9c60ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280ea30802ca4f92b837d51ef9c60ee5">&#9670;&nbsp;</a></span>ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename F , ASIO_COMPLETION_TOKEN_FOR(typename detail::awaitable_signature&lt; result_of_t&lt; F()&gt;&gt;::type) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename detail::awaitable_signature&lt; <a class="el" href="namespaceasio.html#ae03d27556f68768ced98d0eac4a06afd">result_of_t</a>&lt; F()&gt;&gt;::type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bcd6e783eb9d5fd4691c2cfa3e40f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcd6e783eb9d5fd4691c2cfa3e40f43">&#9670;&nbsp;</a></span>ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename AwaitableExecutor , ASIO_COMPLETION_TOKEN_FOR(void(std::exception_ptr)) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(std::exception_ptr)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c0d72619732becbd6a8aa9a1a831ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0d72619732becbd6a8aa9a1a831ca2">&#9670;&nbsp;</a></span>ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename T , typename AwaitableExecutor , ASIO_COMPLETION_TOKEN_FOR(void(std::exception_ptr, T)) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(std::exception_ptr, T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6ea5e73f74a6dfa4cc01889fbacfc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ea5e73f74a6dfa4cc01889fbacfc99">&#9670;&nbsp;</a></span>async_compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename Signature , typename Implementation , typename... IoObjectsOrExecutors&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_compose </td>
          <td>(</td>
          <td class="paramtype">Implementation &amp;&amp;&#160;</td>
          <td class="paramname"><em>implementation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad943bac379d214a815ababf78040b051">type_identity_t</a>&lt; CompletionToken &gt; &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IoObjectsOrExecutors &amp;&amp;...&#160;</td>
          <td class="paramname"><em>io_objects_or_executors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;CompletionToken, Signature&gt;(
      <a class="el" href="namespaceasio_1_1detail.html#afe104b4cace61ff8b235ddd3ffadcea9">detail::make_initiate_composed_op</a>&lt;Signature&gt;(
        <a class="el" href="namespaceasio_1_1detail.html#a908951adb6fcd5849b0fa9ddc0d297e5">detail::make_composed_io_executors</a>(
          <a class="el" href="namespaceasio_1_1detail.html#a390920449946d0e5b743593f9fa8ac27">detail::get_composed_io_executor</a>(
            static_cast&lt;IoObjectsOrExecutors&amp;&amp;&gt;(
              io_objects_or_executors))...)),
      <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt;Implementation&amp;&amp;&gt;(implementation)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launch an asynchronous operation with a stateful implementation. </p>
<p>The async_compose function simplifies the implementation of composed asynchronous operations automatically wrapping a stateful function object with a conforming intermediate completion handler.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">implementation</td><td>A function object that contains the implementation of the composed asynchronous operation. The first argument to the function object is a non-const reference to the enclosing intermediate completion handler. The remaining arguments are any arguments that originate from the completion handlers of any asynchronous operations performed by the implementation.</td></tr>
    <tr><td class="paramname">token</td><td>The completion token.</td></tr>
    <tr><td class="paramname">io_objects_or_executors</td><td>Zero or more I/O objects or I/O executors for which outstanding work must be maintained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>By default, terminal per-operation cancellation is enabled for composed operations that are implemented using <code>async_compose</code>. To disable cancellation for the composed operation, or to alter its supported cancellation types, call the <code>self</code> object's <code>reset_cancellation_state</code> function.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">struct </span>async_echo_implementation</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a>&amp; socket_;</div>
<div class="line">  <a class="code" href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a> buffer_;</div>
<div class="line">  <span class="keyword">enum</span> { starting, reading, writing } state_;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Self&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(Self&amp; <span class="keyword">self</span>,</div>
<div class="line">      <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> error = {},</div>
<div class="line">      std::size_t n = 0)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">switch</span> (state_)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> starting:</div>
<div class="line">      state_ = reading;</div>
<div class="line">      socket_.async_read_some(</div>
<div class="line">          buffer_, std::move(<span class="keyword">self</span>));</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> reading:</div>
<div class="line">      <span class="keywordflow">if</span> (error)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">self</span>.complete(error, 0);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">        state_ = writing;</div>
<div class="line">        <a class="code" href="namespaceasio.html#a505e7a885317c073053fb7f252cc7b04">asio::async_write</a>(socket_, buffer_,</div>
<div class="line">            <a class="code" href="namespaceasio.html#adb2ada9400d78a5df0e5f65dd2b9967e">asio::transfer_exactly</a>(n),</div>
<div class="line">            std::move(<span class="keyword">self</span>));</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> writing:</div>
<div class="line">      <span class="keyword">self</span>.complete(error, n);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionToken&gt;</div>
<div class="line"><span class="keyword">auto</span> async_echo(<a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a>&amp; <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>,</div>
<div class="line">    <a class="code" href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a> <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">buffer</a>,</div>
<div class="line">    CompletionToken&amp;&amp; <a class="code" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>) -&gt;</div>
<div class="line">  decltype(</div>
<div class="line">    <a class="code" href="namespaceasio.html#ae6ea5e73f74a6dfa4cc01889fbacfc99">asio::async_compose</a>&lt;CompletionToken,</div>
<div class="line">      <span class="keywordtype">void</span>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(</div>
<div class="line">        std::declval&lt;async_echo_implementation&gt;(),</div>
<div class="line">        <a class="code" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceasio.html#ae6ea5e73f74a6dfa4cc01889fbacfc99">asio::async_compose</a>&lt;CompletionToken,</div>
<div class="line">    <a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;(</div>
<div class="line">      async_echo_implementation{<a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">buffer</a>,</div>
<div class="line">        async_echo_implementation::starting},</div>
<div class="line">      <a class="code" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">socket</a>);</div>
<div class="line">} </div>
<div class="ttc" id="abind__immediate__executor_8cpp_html_a59a5a6248bbe8018ef97e7c0490d1508"><div class="ttname"><a href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a></div><div class="ttdeci">void()&gt;(declval&lt; initiate_immediate &gt;()</div></div>
<div class="ttc" id="aclassasio_1_1mutable__buffer_html"><div class="ttname"><a href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a></div><div class="ttdoc">Holds a buffer that can be modified.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:79</div></div>
<div class="ttc" id="anamespaceasio_1_1detail_1_1socket__ops_html_a90aa9a854148c26da8232e25988623d8"><div class="ttname"><a href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">asio::detail::socket_ops::socket</a></div><div class="ttdeci">socket_type socket(int af, int type, int protocol, asio::error_code &amp;ec)</div><div class="ttdef"><b>Definition:</b> socket_ops.ipp:1808</div></div>
<div class="ttc" id="anamespaceasio_html_a505e7a885317c073053fb7f252cc7b04"><div class="ttname"><a href="namespaceasio.html#a505e7a885317c073053fb7f252cc7b04">asio::async_write</a></div><div class="ttdeci">auto async_write(AsyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;token, constraint_t&lt; is_const_buffer_sequence&lt; ConstBufferSequence &gt;::value &gt;) -&gt; decltype(async_initiate&lt; WriteToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_write&lt; AsyncWriteStream &gt;&gt;(), token, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</div><div class="ttdef"><b>Definition:</b> write.hpp:469</div></div>
<div class="ttc" id="anamespaceasio_html_ac8914468bc40252ae5e5c666adb951cf"><div class="ttname"><a href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a></div><div class="ttdeci">std::error_code error_code</div><div class="ttdef"><b>Definition:</b> error_code.hpp:26</div></div>
<div class="ttc" id="anamespaceasio_html_adb2ada9400d78a5df0e5f65dd2b9967e"><div class="ttname"><a href="namespaceasio.html#adb2ada9400d78a5df0e5f65dd2b9967e">asio::transfer_exactly</a></div><div class="ttdeci">detail::transfer_exactly_t transfer_exactly(std::size_t size)</div><div class="ttdef"><b>Definition:</b> completion_condition.hpp:206</div></div>
<div class="ttc" id="anamespaceasio_html_adff1e9f7bb336026f18afa2221c9df07"><div class="ttname"><a href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">asio::token</a></div><div class="ttdeci">awaitable&lt; T, AwaitableExecutor &gt; CompletionToken &amp;&amp; token</div><div class="ttdef"><b>Definition:</b> co_spawn.hpp:342</div></div>
<div class="ttc" id="anamespaceasio_html_ae6ea5e73f74a6dfa4cc01889fbacfc99"><div class="ttname"><a href="namespaceasio.html#ae6ea5e73f74a6dfa4cc01889fbacfc99">asio::async_compose</a></div><div class="ttdeci">auto async_compose(Implementation &amp;&amp;implementation, type_identity_t&lt; CompletionToken &gt; &amp;token, IoObjectsOrExecutors &amp;&amp;... io_objects_or_executors) -&gt; decltype(async_initiate&lt; CompletionToken, Signature &gt;(detail::make_initiate_composed_op&lt; Signature &gt;(detail::make_composed_io_executors(detail::get_composed_io_executor(static_cast&lt; IoObjectsOrExecutors &amp;&amp; &gt;(io_objects_or_executors))...)), token, static_cast&lt; Implementation &amp;&amp; &gt;(implementation)))</div><div class="ttdoc">Launch an asynchronous operation with a stateful implementation.</div><div class="ttdef"><b>Definition:</b> compose.hpp:294</div></div>
<div class="ttc" id="anamespaceasio_html_af691d016b23fd6c2da9ac91ce00c2e7e"><div class="ttname"><a href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a></div><div class="ttdeci">ASIO_NODISCARD ASIO_MUTABLE_BUFFER buffer(const mutable_buffer &amp;b) noexcept</div><div class="ttdoc">Create a new modifiable buffer from an existing buffer.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:862</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a779f9e4d80bfe1a45a60aff146f909b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779f9e4d80bfe1a45a60aff146f909b0">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, typename Protocol::endpoint)) RangeConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeConnectToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;Executor&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;RangeConnectToken,
      <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__range__connect.html">detail::initiate_async_range_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, endpoints, connect_condition))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, <span class="keyword">typename</span> Protocol::endpoint) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">r.async_resolve(q, resolve_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> resolve_handler(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::results_type results)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!ec)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="namespaceasio.html#aebeb13d868fe4894497e23cff8a8f586">asio::async_connect</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, results,</div>
<div class="line">        my_connect_condition(),</div>
<div class="line">        <a class="code" href="cpp03_2services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="cpp03_2services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    <span class="keyword">const</span> tcp::endpoint&amp; endpoint)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// An error occurred.</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; endpoint &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} </div>
<div class="ttc" id="ablocking_8cpp_html_a0337bda4434eac48c7c441ec80725e39"><div class="ttname"><a href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a></div><div class="ttdeci">exec::blocking_t s</div><div class="ttdef"><b>Definition:</b> blocking.cpp:26</div></div>
<div class="ttc" id="acpp03_2services_2daytime__client_8cpp_html_aabdaf73cc003280ddecc73a18a0f7925"><div class="ttname"><a href="cpp03_2services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a></div><div class="ttdeci">void connect_handler(const asio::error_code &amp;e, tcp::socket *s)</div><div class="ttdef"><b>Definition:</b> daytime_client.cpp:43</div></div>
<div class="ttc" id="anamespaceasio__query__fn_html_a3d6e4aae3743b6a687ef4d0ecad4a29c"><div class="ttname"><a href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">asio_query_fn::query</a></div><div class="ttdeci">void query()</div></div>
<div class="ttc" id="anamespaceasio_html_aebeb13d868fe4894497e23cff8a8f586"><div class="ttname"><a href="namespaceasio.html#aebeb13d868fe4894497e23cff8a8f586">asio::async_connect</a></div><div class="ttdeci">auto async_connect(basic_socket&lt; Protocol, Executor &gt; &amp;s, const EndpointSequence &amp;endpoints, RangeConnectToken &amp;&amp;token=default_completion_token_t&lt; Executor &gt;(), constraint_t&lt; is_endpoint_sequence&lt; EndpointSequence &gt;::value &gt;=0) -&gt; decltype(async_initiate&lt; RangeConnectToken, void(asio::error_code, typename Protocol::endpoint)&gt;(declval&lt; detail::initiate_async_range_connect&lt; Protocol, Executor &gt;&gt;(), token, endpoints, declval&lt; detail::default_connect_condition &gt;()))</div><div class="ttdef"><b>Definition:</b> connect.hpp:693</div></div>
<div class="ttc" id="astructasio_1_1execution_1_1detail_1_1blocking__t_html"><div class="ttname"><a href="structasio_1_1execution_1_1detail_1_1blocking__t.html">asio::execution::detail::blocking_t</a></div><div class="ttdef"><b>Definition:</b> blocking.hpp:200</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="aebeb13d868fe4894497e23cff8a8f586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebeb13d868fe4894497e23cff8a8f586">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, typename Protocol::endpoint)) RangeConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeConnectToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;Executor&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;RangeConnectToken,
      <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, typename Protocol::endpoint)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__range__connect.html">detail::initiate_async_range_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, endpoints, declval&lt;<a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a>&gt;()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, the successfully connected endpoint.</span></div>
<div class="line">  <span class="comment">// Otherwise, a default-constructed endpoint.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; endpoint</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, <span class="keyword">typename</span> Protocol::endpoint) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">r.async_resolve(q, resolve_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> resolve_handler(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::results_type results)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!ec)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="namespaceasio.html#aebeb13d868fe4894497e23cff8a8f586">asio::async_connect</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, results, <a class="code" href="cpp03_2services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="cpp03_2services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    <span class="keyword">const</span> tcp::endpoint&amp; endpoint)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="a731f44690527def78bf8a7f70c9c030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731f44690527def78bf8a7f70c9c030e">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;Executor&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;IteratorConnectToken,
      <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, Iterator(), connect_condition))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="aab6552bd57c7d027bf01cd226401d206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6552bd57c7d027bf01cd226401d206">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;Executor&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;IteratorConnectToken,
      <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, end, connect_condition))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">r.async_resolve(q, resolve_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> resolve_handler(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::iterator i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!ec)</div>
<div class="line">  {</div>
<div class="line">    tcp::resolver::iterator end;</div>
<div class="line">    <a class="code" href="namespaceasio.html#aebeb13d868fe4894497e23cff8a8f586">asio::async_connect</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, i, end,</div>
<div class="line">        my_connect_condition(),</div>
<div class="line">        <a class="code" href="cpp03_2services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="cpp03_2services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::iterator i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// An error occurred.</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;endpoint() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="af51be8c5a5131d75a429dd48571568fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51be8c5a5131d75a429dd48571568fe">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;Executor&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;IteratorConnectToken,
      <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, end, declval&lt;<a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a>&gt;()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> std::vector&lt;tcp::endpoint&gt; endpoints = ...;</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code" href="namespaceasio.html#aebeb13d868fe4894497e23cff8a8f586">asio::async_connect</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    endpoints.begin(), endpoints.end(),</div>
<div class="line">    <a class="code" href="cpp03_2services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="cpp03_2services_2daytime__client_8cpp.html#aabdaf73cc003280ddecc73a18a0f7925">connect_handler</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">    std::vector&lt;tcp::endpoint&gt;::iterator i)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="a81058f1cca8a51244c6e48f192156cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81058f1cca8a51244c6e48f192156cce">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, Iterator)) IteratorConnectToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;Executor&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;IteratorConnectToken,
      <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> (<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator)&gt;(
        declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>&lt;Protocol, Executor&gt;&gt;(),
        <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, begin, Iterator(),
        declval&lt;<a class="el" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a>&gt;()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established. It is an initiating function for an asynchronous_operation, and always returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the connect completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, Iterator) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the socket's <code>async_connect</code> operation. </p>

</div>
</div>
<a id="a26f784a1c5604d9cdb7ead506e6b7ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f784a1c5604d9cdb7ead506e6b7ebe">&#9670;&nbsp;</a></span>async_initiate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , ASIO_COMPLETION_SIGNATURE... Signatures, typename Initiation , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signatures...&gt;::value, typename <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;CompletionToken&gt;, Signatures...&gt;::return_type&gt; asio::async_initiate </td>
          <td>(</td>
          <td class="paramtype">Initiation &amp;&amp;&#160;</td>
          <td class="paramname"><em>initiation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad943bac379d214a815ababf78040b051">type_identity_t</a>&lt; CompletionToken &gt; &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbf600e256af39d8a0c65fb6e3eb988d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf600e256af39d8a0c65fb6e3eb988d">&#9670;&nbsp;</a></span>async_initiate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , ASIO_COMPLETION_SIGNATURE... Signatures, typename Initiation , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_initiate </td>
          <td>(</td>
          <td class="paramtype">Initiation &amp;&amp;&#160;</td>
          <td class="paramname"><em>initiation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad943bac379d214a815ababf78040b051">type_identity_t</a>&lt; CompletionToken &gt; &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;
    <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt;
      CompletionToken, Signatures...&gt;::value,
    decltype(
      <a class="el" href="classasio_1_1async__result.html">async_result</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;CompletionToken&gt;, Signatures...&gt;::initiate(
        static_cast&lt;Initiation&amp;&amp;&gt;(initiation),
        static_cast&lt;CompletionToken&amp;&amp;&gt;(<a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>),
        static_cast&lt;Args&amp;&amp;&gt;(args)...))&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6926d1f699f1b1fda72aa7c4d3125741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6926d1f699f1b1fda72aa7c4d3125741">&#9670;&nbsp;</a></span>async_read() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="aebdedc8e67bdad64c8ef83dac8021b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdedc8e67bdad64c8ef83dac8021b52">&#9670;&nbsp;</a></span>async_read() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#ad686d881d915fd25eb761add24af9e75">asio::async_read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_a4a82e92df79aa8401a8bc2117d4cf900"><div class="ttname"><a href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a></div><div class="ttdeci">detail::transfer_all_t transfer_all()</div><div class="ttdef"><b>Definition:</b> completion_condition.hpp:138</div></div>
<div class="ttc" id="anamespaceasio_html_ad686d881d915fd25eb761add24af9e75"><div class="ttname"><a href="namespaceasio.html#ad686d881d915fd25eb761add24af9e75">asio::async_read</a></div><div class="ttdeci">auto async_read(AsyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadToken &amp;&amp;token, constraint_t&lt; is_mutable_buffer_sequence&lt; MutableBufferSequence &gt;::value &gt;) -&gt; decltype(async_initiate&lt; ReadToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_read&lt; AsyncReadStream &gt;&gt;(), token, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</div><div class="ttdef"><b>Definition:</b> read.hpp:504</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="ad686d881d915fd25eb761add24af9e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad686d881d915fd25eb761add24af9e75">&#9670;&nbsp;</a></span>async_read() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read.html">detail::initiate_async_read</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#ad686d881d915fd25eb761add24af9e75">asio::async_read</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">   <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code" href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_a2b10af704afcd6c7ed7f0d3b740033ef"><div class="ttname"><a href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a></div><div class="ttdeci">detail::transfer_at_least_t transfer_at_least(std::size_t minimum)</div><div class="ttdef"><b>Definition:</b> completion_condition.hpp:172</div></div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a062769b089b146e06a644df48c4e32aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062769b089b146e06a644df48c4e32aa">&#9670;&nbsp;</a></span>async_read() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename MutableBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read.html">detail::initiate_async_read</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#ad686d881d915fd25eb761add24af9e75">asio::async_read</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#ad686d881d915fd25eb761add24af9e75">asio::async_read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a23260781ee8346a7872eff0e51b037a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23260781ee8346a7872eff0e51b037a5">&#9670;&nbsp;</a></span>async_read() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="ae3fe6ab0939cad6da2190818ffa4b8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fe6ab0939cad6da2190818ffa4b8d1">&#9670;&nbsp;</a></span>async_read() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#ad686d881d915fd25eb761add24af9e75">asio::async_read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a53897322b95c74daeb021d39edfd6cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53897322b95c74daeb021d39edfd6cd0">&#9670;&nbsp;</a></span>async_read() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v2.html">detail::initiate_async_read_dynbuf_v2</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a10d6d25d6a7f40eee7cf38634549f695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d6d25d6a7f40eee7cf38634549f695">&#9670;&nbsp;</a></span>async_read() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__dynbuf__v2.html">detail::initiate_async_read_dynbuf_v2</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#ad686d881d915fd25eb761add24af9e75">asio::async_read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a1d52e0bb20d0e0ccf2d948906c7409b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d52e0bb20d0e0ccf2d948906c7409b0">&#9670;&nbsp;</a></span>async_read_at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessReadDevice::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at__streambuf.html">detail::initiate_async_read_at_streambuf</a>&lt; AsyncRandomAccessReadDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async_read_some_at function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessReadDevice</code> type's async_read_some_at operation. </p>

</div>
</div>
<a id="a289ecb2e4aad891c8367133b14c11134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289ecb2e4aad891c8367133b14c11134">&#9670;&nbsp;</a></span>async_read_at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessReadDevice , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessReadDevice::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at__streambuf.html">detail::initiate_async_read_at_streambuf</a>&lt; AsyncRandomAccessReadDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#afb3e2f9690fef3e01df80513906c4658">asio::async_read_at</a>(</div>
<div class="line">   d, 42, b,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_afb3e2f9690fef3e01df80513906c4658"><div class="ttname"><a href="namespaceasio.html#afb3e2f9690fef3e01df80513906c4658">asio::async_read_at</a></div><div class="ttdeci">auto async_read_at(AsyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadToken &amp;&amp;token) -&gt; decltype(async_initiate&lt; ReadToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_read_at&lt; AsyncRandomAccessReadDevice &gt;&gt;(), token, offset, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</div><div class="ttdef"><b>Definition:</b> read_at.hpp:366</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessReadDevice</code> type's async_read_some_at operation. </p>

</div>
</div>
<a id="afb3e2f9690fef3e01df80513906c4658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3e2f9690fef3e01df80513906c4658">&#9670;&nbsp;</a></span>async_read_at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessReadDevice::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at.html">detail::initiate_async_read_at</a>&lt; AsyncRandomAccessReadDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async_read_some_at function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#afb3e2f9690fef3e01df80513906c4658">asio::async_read_at</a>(d, 42,</div>
<div class="line">   <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code" href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessReadDevice</code> type's async_read_some_at operation. </p>

</div>
</div>
<a id="a7e2da6a1b552029a80b606dfb58ad80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2da6a1b552029a80b606dfb58ad80a">&#9670;&nbsp;</a></span>async_read_at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessReadDevice , typename MutableBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessReadDevice::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__at.html">detail::initiate_async_read_at</a>&lt; AsyncRandomAccessReadDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#afb3e2f9690fef3e01df80513906c4658">asio::async_read_at</a>(d, 42, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#afb3e2f9690fef3e01df80513906c4658">asio::async_read_at</a>(</div>
<div class="line">   d, 42, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessReadDevice</code> type's async_read_some_at operation. </p>

</div>
</div>
<a id="adc5ced357513dc5138ae582ad97d1d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5ced357513dc5138ae582ad97d1d11">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v1.html">detail::initiate_async_read_until_delim_string_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), static_cast&lt; std::string &gt;(delim)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::istream is(&amp;b);</div>
<div class="line">    std::string line;</div>
<div class="line">    std::getline(is, line);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div>
<div class="ttc" id="aclassasio_1_1basic__streambuf_html"><div class="ttname"><a href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a></div><div class="ttdoc">Automatically resizable buffer class based on std::streambuf.</div><div class="ttdef"><b>Definition:</b> basic_streambuf.hpp:113</div></div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="aad031c3f6eaf5829d17ce2caa6318ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad031c3f6eaf5829d17ce2caa6318ae8">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v1.html">detail::initiate_async_read_until_delim_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), delim))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::istream is(&amp;b);</div>
<div class="line">    std::string line;</div>
<div class="line">    std::getline(is, line);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <span class="charliteral">&#39;\n&#39;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a9f0045b6048d9d6d577bc11a3ff0c717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0045b6048d9d6d577bc11a3ff0c717">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , typename MatchCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v1.html">detail::initiate_async_read_until_match_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), match_condition))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a streambuf until a function object indicates a match. This function is used to asynchronously read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area that have been fully consumed by the</span></div>
<div class="line">  <span class="comment">// match function. O if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a streambuf until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code" href="classasio_1_1basic__streambuf.html#a9e2ffddcb9e89d68048254ea787c2258">asio::streambuf::const_buffers_type</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">asio::streambuf b;</div>
<div class="line"><a class="code" href="namespaceasio.html#a3ad1e914adbdf6f6114f6b339929e567">asio::async_read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, match_whitespace, handler);</div>
<div class="ttc" id="aclassasio_1_1basic__streambuf_html_a9e2ffddcb9e89d68048254ea787c2258"><div class="ttname"><a href="classasio_1_1basic__streambuf.html#a9e2ffddcb9e89d68048254ea787c2258">asio::basic_streambuf::const_buffers_type</a></div><div class="ttdeci">ASIO_CONST_BUFFER const_buffers_type</div><div class="ttdef"><b>Definition:</b> basic_streambuf.hpp:122</div></div>
<div class="ttc" id="aclassasio_1_1buffers__iterator_html"><div class="ttname"><a href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a></div><div class="ttdoc">A random access iterator over the bytes in a buffer sequence.</div><div class="ttdef"><b>Definition:</b> buffers_iterator.hpp:111</div></div>
<div class="ttc" id="anamespaceasio_html_a3ad1e914adbdf6f6114f6b339929e567"><div class="ttname"><a href="namespaceasio.html#a3ad1e914adbdf6f6114f6b339929e567">asio::async_read_until</a></div><div class="ttdeci">auto async_read_until(AsyncReadStream &amp;s, DynamicBuffer_v1 &amp;&amp;buffers, char delim, ReadToken &amp;&amp;token, constraint_t&lt; is_dynamic_buffer_v1&lt; decay_t&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, constraint_t&lt; !is_dynamic_buffer_v2&lt; decay_t&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;) -&gt; decltype(async_initiate&lt; ReadToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_read_until_delim_v1&lt; AsyncReadStream &gt;&gt;(), token, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), delim))</div><div class="ttdef"><b>Definition:</b> read_until.hpp:1034</div></div>
</div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a streambuf until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> <a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) : c_(<a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">asio::streambuf b;</div>
<div class="line"><a class="code" href="namespaceasio.html#a3ad1e914adbdf6f6114f6b339929e567">asio::async_read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <a class="code" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>), handler);</div>
<div class="ttc" id="aclassmatch__char_html"><div class="ttname"><a href="classmatch__char.html">match_char</a></div><div class="ttdef"><b>Definition:</b> read_until.cpp:457</div></div>
<div class="ttc" id="anamespaceasio_1_1experimental_html_a4607a9754bf2707c054f0ff16b958b82"><div class="ttname"><a href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">asio::experimental::c</a></div><div class="ttdeci">Executor c</div><div class="ttdef"><b>Definition:</b> co_spawn.hpp:66</div></div>
<div class="ttc" id="anamespaceasio_html"><div class="ttname"><a href="namespaceasio.html">asio</a></div><div class="ttdef"><b>Definition:</b> any_completion_executor.hpp:27</div></div>
</div><!-- fragment --><dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a62b8c7f7b5dca9540b846756a3ff44d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b8c7f7b5dca9540b846756a3ff44d7">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v1.html">detail::initiate_async_read_until_delim_string_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), static_cast&lt; std::string &gt;(delim)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = data.substr(0, n);</div>
<div class="line">    data.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the string <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a3ad1e914adbdf6f6114f6b339929e567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad1e914adbdf6f6114f6b339929e567">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v1.html">detail::initiate_async_read_until_delim_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), delim))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = data.substr(0, n);</div>
<div class="line">    data.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <span class="charliteral">&#39;\n&#39;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="ab1e2b9e0203c3bf154ad13a9919b52a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e2b9e0203c3bf154ad13a9919b52a1">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v1.html">detail::initiate_async_read_until_match_v1</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), match_condition))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;typename DynamicBuffer_v1::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area that have been fully consumed by the match</span></div>
<div class="line">  <span class="comment">// function. O if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a <code>std::string</code> until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code" href="namespaceasio.html#a3ad1e914adbdf6f6114f6b339929e567">asio::async_read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, match_whitespace, handler);</div>
<div class="ttc" id="aclassasio_1_1const__buffers__1_html"><div class="ttname"><a href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a></div><div class="ttdef"><b>Definition:</b> buffer.hpp:294</div></div>
</div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> <a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) : c_(<a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code" href="namespaceasio.html#a3ad1e914adbdf6f6114f6b339929e567">asio::async_read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <a class="code" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>), handler);</div>
</div><!-- fragment --><dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a2482cd1728656c93008e415475f6eccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2482cd1728656c93008e415475f6eccc">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__string__v2.html">detail::initiate_async_read_until_delim_string_v2</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), static_cast&lt; std::string &gt;(delim)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = data.substr(0, n);</div>
<div class="line">    data.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the string <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a3d739462073c9d8c28ebf8ac04a3bbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d739462073c9d8c28ebf8ac04a3bbed">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__delim__v2.html">detail::initiate_async_read_until_delim_v2</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), delim))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = data.substr(0, n);</div>
<div class="line">    data.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <span class="charliteral">&#39;\n&#39;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a331200c3f73e54b6e22b55133dab6ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331200c3f73e54b6e22b55133dab6ffd">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) ReadToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncReadStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; ReadToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__read__until__match__v2.html">detail::initiate_async_read_until_match_v2</a>&lt; AsyncReadStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), match_condition))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;typename DynamicBuffer_v2::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the read completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area that have been fully consumed by the match</span></div>
<div class="line">  <span class="comment">// function. O if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a <code>std::string</code> until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code" href="namespaceasio.html#a3ad1e914adbdf6f6114f6b339929e567">asio::async_read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, match_whitespace, handler);</div>
</div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> <a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) : c_(<a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code" href="namespaceasio.html#a3ad1e914adbdf6f6114f6b339929e567">asio::async_read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <a class="code" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>), handler);</div>
</div><!-- fragment --><dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncReadStream</code> type's <code>async_read_some</code> operation. </p>

</div>
</div>
<a id="a1d3e08fa509649b8dd26cca294e4b371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3e08fa509649b8dd26cca294e4b371">&#9670;&nbsp;</a></span>async_write() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename Allocator , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="aab510e035996445e9879684d81579673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab510e035996445e9879684d81579673">&#9670;&nbsp;</a></span>async_write() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncWriteStream::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, <a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a>&lt; Allocator &gt;(b), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a505e7a885317c073053fb7f252cc7b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505e7a885317c073053fb7f252cc7b04">&#9670;&nbsp;</a></span>async_write() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename ConstBufferSequence , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write.html">detail::initiate_async_write</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a505e7a885317c073053fb7f252cc7b04">asio::async_write</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">   <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code" href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="aa72b992e102c1bebe5dca6f7bcb436d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72b992e102c1bebe5dca6f7bcb436d7">&#9670;&nbsp;</a></span>async_write() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename ConstBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncWriteStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write.html">detail::initiate_async_write</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a505e7a885317c073053fb7f252cc7b04">asio::async_write</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a0de7473e8cbaa0c1454b95200636749f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de7473e8cbaa0c1454b95200636749f">&#9670;&nbsp;</a></span>async_write() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a8a8aff82f1f0a456c8bd8d63ae4b4b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8aff82f1f0a456c8bd8d63ae4b4b37">&#9670;&nbsp;</a></span>async_write() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename DynamicBuffer_v1 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncWriteStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v1.html">detail::initiate_async_write_dynbuf_v1</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v1 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="ac482a6b720fbbe2688afa1e69ab0a129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac482a6b720fbbe2688afa1e69ab0a129">&#9670;&nbsp;</a></span>async_write() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v2.html">detail::initiate_async_write_dynbuf_v2</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a4efc5ef2e4b428464ba08bb83aea6129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efc5ef2e4b428464ba08bb83aea6129">&#9670;&nbsp;</a></span>async_write() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream , typename DynamicBuffer_v2 , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncWriteStream::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__dynbuf__v2.html">detail::initiate_async_write_dynbuf_v2</a>&lt; AsyncWriteStream &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; DynamicBuffer_v2 &amp;&amp; &gt;(buffers), <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncWriteStream</code> type's <code>async_write_some</code> operation. </p>

</div>
</div>
<a id="a1d21c5fbc0b6ac9839d1023307aae129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d21c5fbc0b6ac9839d1023307aae129">&#9670;&nbsp;</a></span>async_write_at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessWriteDevice::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at__streambuf.html">detail::initiate_async_write_at_streambuf</a>&lt; AsyncRandomAccessWriteDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async_write_some_at function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessWriteDevice</code> type's async_write_some_at operation. </p>

</div>
</div>
<a id="a22aebde0039839b99cfd2e7973ec519d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22aebde0039839b99cfd2e7973ec519d">&#9670;&nbsp;</a></span>async_write_at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessWriteDevice::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at__streambuf.html">detail::initiate_async_write_at_streambuf</a>&lt; AsyncRandomAccessWriteDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, &amp;b, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessWriteDevice</code> type's async_write_some_at operation. </p>

</div>
</div>
<a id="aff40274147e80d3b902b3a719f979e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff40274147e80d3b902b3a719f979e3a">&#9670;&nbsp;</a></span>async_write_at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessWriteDevice::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at.html">detail::initiate_async_write_at</a>&lt; AsyncRandomAccessWriteDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async_write_some_at function.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#aff40274147e80d3b902b3a719f979e3a">asio::async_write_at</a>(d, 42,</div>
<div class="line">   <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code" href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_aff40274147e80d3b902b3a719f979e3a"><div class="ttname"><a href="namespaceasio.html#aff40274147e80d3b902b3a719f979e3a">asio::async_write_at</a></div><div class="ttdeci">auto async_write_at(AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteToken &amp;&amp;token) -&gt; decltype(async_initiate&lt; WriteToken, void(asio::error_code, std::size_t)&gt;(declval&lt; detail::initiate_async_write_at&lt; AsyncRandomAccessWriteDevice &gt;&gt;(), token, offset, buffers, static_cast&lt; CompletionCondition &amp;&amp; &gt;(completion_condition)))</div><div class="ttdef"><b>Definition:</b> write_at.hpp:351</div></div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessWriteDevice</code> type's async_write_some_at operation. </p>

</div>
</div>
<a id="a007ae4a9e3ecea6b02ebeed8dd7f855f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007ae4a9e3ecea6b02ebeed8dd7f855f">&#9670;&nbsp;</a></span>async_write_at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , ASIO_COMPLETION_TOKEN_FOR(void(asio::error_code, std::size_t)) WriteToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;AsyncRandomAccessWriteDevice::executor_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; WriteToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t)&gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__async__write__at.html">detail::initiate_async_write_at</a>&lt; AsyncRandomAccessWriteDevice &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, offset, buffers, <a class="el" href="structtransfer__all.html">transfer_all</a>()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. It is an initiating function for an asynchronous_operation, and always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler, which will be called when the write completes. Potential completion tokens include use_future, use_awaitable, <a class="el" href="namespaceasio.html#a09b73624bafbe0c55f0da6b594cbc886">yield_context</a>, or a function object with the correct completion signature. The function signature of the completion handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the completion handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(<a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>, std::size_t) </div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#aff40274147e80d3b902b3a719f979e3a">asio::async_write_at</a>(d, 42, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>This asynchronous operation supports cancellation for the following <a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6">asio::cancellation_type</a> values:</dd></dl>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> </li>
</ul>
<ul>
<li><code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6a0e87c1212a698494dcdb198af3e0eb2f">cancellation_type::partial</a></code> </li>
</ul>
<p>if they are also supported by the <code>AsyncRandomAccessWriteDevice</code> type's async_write_some_at operation. </p>

</div>
</div>
<a id="a6dc1edea36e4260b8f7c65d3dc4aa522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc1edea36e4260b8f7c65d3dc4aa522">&#9670;&nbsp;</a></span>bind_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1allocator__binder.html">allocator_binder</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;T&gt;, Allocator&gt; asio::bind_allocator </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associate an object of type <code>T</code> with an allocator of type <code>Allocator</code>. </p>

</div>
</div>
<a id="a9de893a31b1037808c1c41311dd2860d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de893a31b1037808c1c41311dd2860d">&#9670;&nbsp;</a></span>bind_cancellation_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CancellationSlot , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1cancellation__slot__binder.html">cancellation_slot_binder</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;T&gt;, CancellationSlot&gt; asio::bind_cancellation_slot </td>
          <td>(</td>
          <td class="paramtype">const CancellationSlot &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associate an object of type <code>T</code> with a cancellation slot of type <code>CancellationSlot</code>. </p>

</div>
</div>
<a id="a3861d399297bcd40766f133773ea88e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3861d399297bcd40766f133773ea88e7">&#9670;&nbsp;</a></span>bind_executor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;T&gt;, Executor&gt; asio::bind_executor </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate an object of type <code>T</code> with an executor of type <code>Executor</code>. </p>

</div>
</div>
<a id="ac68f928d90d17a7a2ef7749ca06b92c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68f928d90d17a7a2ef7749ca06b92c1">&#9670;&nbsp;</a></span>bind_executor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;T&gt;, typename ExecutionContext::executor_type&gt; asio::bind_executor </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate an object of type <code>T</code> with an execution context's executor. </p>

</div>
</div>
<a id="afd91a512d2dfbc4faa108791856147a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd91a512d2dfbc4faa108791856147a1">&#9670;&nbsp;</a></span>bind_immediate_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1immediate__executor__binder.html">immediate_executor_binder</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;T&gt;, Executor&gt; asio::bind_immediate_executor </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associate an object of type <code>T</code> with a immediate executor of type <code>Executor</code>. </p>

</div>
</div>
<a id="a0a2e76bbc8d686f8c816fe49873a4666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2e76bbc8d686f8c816fe49873a4666">&#9670;&nbsp;</a></span>buffer() <span class="overload">[1/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a00c6a9bbe7e9cba49430d37caae476cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c6a9bbe7e9cba49430d37caae476cd">&#9670;&nbsp;</a></span>buffer() <span class="overload">[2/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8e6a0ab72797048aa4629781e650d65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6a0ab72797048aa4629781e650d65e">&#9670;&nbsp;</a></span>buffer() <span class="overload">[3/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af92b80f670c5f74b5402342f87fd9d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92b80f670c5f74b5402342f87fd9d28">&#9670;&nbsp;</a></span>buffer() <span class="overload">[4/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3e2c9f5266bd40548109072a006bd4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2c9f5266bd40548109072a006bd4db">&#9670;&nbsp;</a></span>buffer() <span class="overload">[5/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>const_buffer(b)</code>. </dd></dl>

</div>
</div>
<a id="a8e22c4da973f9cec891970c007ea8a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e22c4da973f9cec891970c007ea8a7b">&#9670;&nbsp;</a></span>buffer() <span class="overload">[6/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   b.data(),</div>
<div class="line">   min(b.size(), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a83bc6057a4682b36c1180b56107ff160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83bc6057a4682b36c1180b56107ff160">&#9670;&nbsp;</a></span>buffer() <span class="overload">[7/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a buffer representing the entire registered buffer. </p>

</div>
</div>
<a id="aaaa87a00e12c0e47cf34203dfb2c3ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa87a00e12c0e47cf34203dfb2c3ef1">&#9670;&nbsp;</a></span>buffer() <span class="overload">[8/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a buffer representing part of a registered buffer. </p>

</div>
</div>
<a id="af691d016b23fd6c2da9ac91ce00c2e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af691d016b23fd6c2da9ac91ce00c2e7e">&#9670;&nbsp;</a></span>buffer() <span class="overload">[9/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>mutable_buffer(b)</code>. </dd></dl>

</div>
</div>
<a id="a2b4a73cd878cb3ce83da935fb9932f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4a73cd878cb3ce83da935fb9932f23">&#9670;&nbsp;</a></span>buffer() <span class="overload">[10/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   b.data(),</div>
<div class="line">   min(b.size(), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="afe13ad24e316f94e7ff8a197ac2a40be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe13ad24e316f94e7ff8a197ac2a40be">&#9670;&nbsp;</a></span>buffer() <span class="overload">[11/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a buffer representing the entire registered buffer. </p>

</div>
</div>
<a id="aacafdf44af129753e05ba770785b4acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacafdf44af129753e05ba770785b4acc">&#9670;&nbsp;</a></span>buffer() <span class="overload">[12/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a buffer representing part of a registered buffer. </p>

</div>
</div>
<a id="a1f2b1693298fb564b28c7440eff1774e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2b1693298fb564b28c7440eff1774e">&#9670;&nbsp;</a></span>buffer() <span class="overload">[13/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(data),</div>
<div class="line">   N * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a66b5df59bccdd5b06f8d93416472105c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b5df59bccdd5b06f8d93416472105c">&#9670;&nbsp;</a></span>buffer() <span class="overload">[14/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(data),</div>
<div class="line">   min(N * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac28b3f525cd9132dde4eceff0d1c8611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28b3f525cd9132dde4eceff0d1c8611">&#9670;&nbsp;</a></span>buffer() <span class="overload">[15/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code><a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a>(data.data(), data.size() * sizeof(Elem))</code>.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="aca8ad05e2147e00fe0019da3b12caac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8ad05e2147e00fe0019da3b12caac1">&#9670;&nbsp;</a></span>buffer() <span class="overload">[16/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(Elem), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="a32d16f55d0457afe5971519eafa4f2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d16f55d0457afe5971519eafa4f2b2">&#9670;&nbsp;</a></span>buffer() <span class="overload">[17/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="aa8958d330420418a8ca049279026dc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8958d330420418a8ca049279026dc3f">&#9670;&nbsp;</a></span>buffer() <span class="overload">[18/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="a7df15a068b182e5dbc67e7a9831ac663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df15a068b182e5dbc67e7a9831ac663">&#9670;&nbsp;</a></span>buffer() <span class="overload">[19/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::const_iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(<span class="keyword">typename</span> T::value_type)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1725cb81df773d48f415111dc9d66d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1725cb81df773d48f415111dc9d66d07">&#9670;&nbsp;</a></span>buffer() <span class="overload">[20/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::const_iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(</div>
<div class="line">     data.size() * <span class="keyword">sizeof</span>(<span class="keyword">typename</span> T::value_type),</div>
<div class="line">     max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a609e222330f06ff048c78d40431953e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609e222330f06ff048c78d40431953e5">&#9670;&nbsp;</a></span>buffer() <span class="overload">[21/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given memory range. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>const_buffer(data, size_in_bytes)</code>. </dd></dl>

</div>
</div>
<a id="a4ddf466e8044ce08813fc66d4097d213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddf466e8044ce08813fc66d4097d213">&#9670;&nbsp;</a></span>buffer() <span class="overload">[22/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(data),</div>
<div class="line">   N * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a56a0a6ae44a23ca25b1836da782cd616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a0a6ae44a23ca25b1836da782cd616">&#9670;&nbsp;</a></span>buffer() <span class="overload">[23/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(data),</div>
<div class="line">   min(N * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adfa3e7d25d0f90000eebc400c02dfbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa3e7d25d0f90000eebc400c02dfbf0">&#9670;&nbsp;</a></span>buffer() <span class="overload">[24/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; const PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae1f602fab6a887916ee3aac0769dc46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f602fab6a887916ee3aac0769dc46a">&#9670;&nbsp;</a></span>buffer() <span class="overload">[25/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; const PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5da2efeb42c04e368055e1b5f7780132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da2efeb42c04e368055e1b5f7780132">&#9670;&nbsp;</a></span>buffer() <span class="overload">[26/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aff494b6b08d0ae82723ec370cd91d39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff494b6b08d0ae82723ec370cd91d39a">&#9670;&nbsp;</a></span>buffer() <span class="overload">[27/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a691ba65873879c5541119faff29aa0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691ba65873879c5541119faff29aa0f4">&#9670;&nbsp;</a></span>buffer() <span class="overload">[28/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code><a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a>(data.size() ? &amp;data[0] : 0, data.size() * sizeof(Elem))</code>.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="a1dc4d596625f545097450584d532a71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc4d596625f545097450584d532a71e">&#9670;&nbsp;</a></span>buffer() <span class="overload">[29/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(Elem), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="a84688fa20c384874e1eddf5c81d8c331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84688fa20c384874e1eddf5c81d8c331">&#9670;&nbsp;</a></span>buffer() <span class="overload">[30/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="af717cc04e6415768402160b063ec6202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af717cc04e6415768402160b063ec6202">&#9670;&nbsp;</a></span>buffer() <span class="overload">[31/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="aeb3bc2e4b9e6bf8ff64eab08344002aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3bc2e4b9e6bf8ff64eab08344002aa">&#9670;&nbsp;</a></span>buffer() <span class="overload">[32/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_const&lt; <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(<span class="keyword">typename</span> T::value_type)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9025af2d8c7f20168a21c860ce06d2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9025af2d8c7f20168a21c860ce06d2fd">&#9670;&nbsp;</a></span>buffer() <span class="overload">[33/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_const&lt; <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(<span class="keyword">typename</span> T::value_type)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a230a757727dfa8eac34c54df06cf6fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230a757727dfa8eac34c54df06cf6fa0">&#9670;&nbsp;</a></span>buffer() <span class="overload">[34/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_const&lt; <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(</div>
<div class="line">     data.size() * <span class="keyword">sizeof</span>(<span class="keyword">typename</span> T::value_type),</div>
<div class="line">     max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a52644e5a827859367e71ebeafe1a9fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52644e5a827859367e71ebeafe1a9fca">&#9670;&nbsp;</a></span>buffer() <span class="overload">[35/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__contiguous__iterator.html">is_contiguous_iterator</a>&lt; typename T::iterator &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T, <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_const&lt; <a class="el" href="namespaceasio.html#a34192a90d4d961bbd9f1a5264be0e081">remove_reference_t</a>&lt; typename std::iterator_traits&lt; typename T::iterator &gt;::reference &gt; &gt;::value, <a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a> &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structasio_1_1defaulted__constraint.html">defaulted_constraint</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from a contiguous container. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(</div>
<div class="line">     data.size() * <span class="keyword">sizeof</span>(<span class="keyword">typename</span> T::value_type),</div>
<div class="line">     max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a390401d56dbdf838be8a09ec7ce4d4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390401d56dbdf838be8a09ec7ce4d4d4">&#9670;&nbsp;</a></span>buffer() <span class="overload">[36/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given memory range. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>mutable_buffer(data, size_in_bytes)</code>. </dd></dl>

</div>
</div>
<a id="a240b9552e7e1deb855c98e11583b88a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240b9552e7e1deb855c98e11583b88a5">&#9670;&nbsp;</a></span>buffer_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointerToPodType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointerToPodType asio::buffer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a non-modifiable buffer to a specified pointer to POD type. </p>

</div>
</div>
<a id="a8365a4bf9ba53918c758263fd3b0fb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8365a4bf9ba53918c758263fd3b0fb36">&#9670;&nbsp;</a></span>buffer_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointerToPodType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointerToPodType asio::buffer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a non-modifiable buffer to a specified pointer to POD type. </p>

</div>
</div>
<a id="a9ab876ca15e1fd4f5f12caa8e0cac327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab876ca15e1fd4f5f12caa8e0cac327">&#9670;&nbsp;</a></span>buffer_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::buffer_copy </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies bytes from a source buffer sequence to a target buffer sequence. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>A modifiable buffer sequence representing the memory regions to which the bytes will be copied.</td></tr>
    <tr><td class="paramname">source</td><td>A non-modifiable buffer sequence representing the memory regions from which the bytes will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes copied.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The number of bytes copied is the lesser of:</dd></dl>
<ul>
<li><code>buffer_size(target)</code> </li>
</ul>
<ul>
<li><code>buffer_size(source)</code> </li>
</ul>
<p>This function is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions. </p>

</div>
</div>
<a id="a4f84f2c9b443140a1b8693c5491ffde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f84f2c9b443140a1b8693c5491ffde4">&#9670;&nbsp;</a></span>buffer_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::buffer_copy </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_bytes_to_copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies a limited number of bytes from a source buffer sequence to a target buffer sequence. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>A modifiable buffer sequence representing the memory regions to which the bytes will be copied.</td></tr>
    <tr><td class="paramname">source</td><td>A non-modifiable buffer sequence representing the memory regions from which the bytes will be copied.</td></tr>
    <tr><td class="paramname">max_bytes_to_copy</td><td>The maximum number of bytes to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes copied.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>The number of bytes copied is the lesser of:</dd></dl>
<ul>
<li><code>buffer_size(target)</code> </li>
</ul>
<ul>
<li><code>buffer_size(source)</code> </li>
</ul>
<ul>
<li><code>max_bytes_to_copy</code> </li>
</ul>
<p>This function is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions. </p>

</div>
</div>
<a id="afbcd07567a0f9eeaacd8bd0b08689e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcd07567a0f9eeaacd8bd0b08689e80">&#9670;&nbsp;</a></span>buffer_sequence_begin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(c.begin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="a1288ea04d255a07a8050e8016b554d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1288ea04d255a07a8050e8016b554d0b">&#9670;&nbsp;</a></span>buffer_sequence_begin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(c.begin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="a48be03d3d92b51e047630441999a7033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48be03d3d92b51e047630441999a7033">&#9670;&nbsp;</a></span>buffer_sequence_begin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>* asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="a686f3b0e674a7bc5b10582960f5c7e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686f3b0e674a7bc5b10582960f5c7e6a">&#9670;&nbsp;</a></span>buffer_sequence_begin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>* asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">const ConstBuffer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; const ConstBuffer *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="a5fbb11e9cf940e24d3220e9b37c17964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbb11e9cf940e24d3220e9b37c17964">&#9670;&nbsp;</a></span>buffer_sequence_begin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>* asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="a5b4d8d749d450ac578b620e5c61250e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4d8d749d450ac578b620e5c61250e5">&#9670;&nbsp;</a></span>buffer_sequence_begin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>* asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">const MutableBuffer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; const MutableBuffer *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="afe41182ab29c34a81752396b25ba0d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe41182ab29c34a81752396b25ba0d1a">&#9670;&nbsp;</a></span>buffer_sequence_end() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(c.end())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="ab7a057966e62697d09cafab0009eda0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a057966e62697d09cafab0009eda0e">&#9670;&nbsp;</a></span>buffer_sequence_end() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; const C *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &amp;&amp;!is_convertible&lt; const C *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(c.end())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="a1cb2439fdacc7d489e9dcd774c93f21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb2439fdacc7d489e9dcd774c93f21d">&#9670;&nbsp;</a></span>buffer_sequence_end() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>* asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__registered__buffer.html">const_registered_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="a290ddb5ce8b88216e2042f5c5db79694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290ddb5ce8b88216e2042f5c5db79694">&#9670;&nbsp;</a></span>buffer_sequence_end() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>* asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">const ConstBuffer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; const ConstBuffer *, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="a484d9fbc9f5b149a3867b807945da77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484d9fbc9f5b149a3867b807945da77f">&#9670;&nbsp;</a></span>buffer_sequence_end() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>* asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__registered__buffer.html">mutable_registered_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="aa68ad2484cefa6ed9a53783912ae0cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68ad2484cefa6ed9a53783912ae0cd1">&#9670;&nbsp;</a></span>buffer_sequence_end() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>* asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">const MutableBuffer &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; const MutableBuffer *, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="a32ffb00a82a2cb0dcbb976e02d82cc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ffb00a82a2cb0dcbb976e02d82cc79">&#9670;&nbsp;</a></span>buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::buffer_size </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of bytes in a buffer sequence. </p>
<p>The <code>buffer_size</code> function determines the total size of all buffers in the buffer sequence, as if computed as follows:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">size_t</span> total_size = 0;</div>
<div class="line"><span class="keyword">auto</span> i = <a class="code" href="namespaceasio.html#a5b4d8d749d450ac578b620e5c61250e5">asio::buffer_sequence_begin</a>(buffers);</div>
<div class="line"><span class="keyword">auto</span> end = <a class="code" href="namespaceasio.html#aa68ad2484cefa6ed9a53783912ae0cd1">asio::buffer_sequence_end</a>(buffers);</div>
<div class="line"><span class="keywordflow">for</span> (; i != end; ++i)</div>
<div class="line">{</div>
<div class="line">  const_buffer b(*i);</div>
<div class="line">  total_size += b.size();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> total_size; </div>
<div class="ttc" id="anamespaceasio_html_a5b4d8d749d450ac578b620e5c61250e5"><div class="ttname"><a href="namespaceasio.html#a5b4d8d749d450ac578b620e5c61250e5">asio::buffer_sequence_begin</a></div><div class="ttdeci">const mutable_buffer * buffer_sequence_begin(const MutableBuffer &amp;b, constraint_t&lt; is_convertible&lt; const MutableBuffer *, const mutable_buffer * &gt;::value &gt;=0) noexcept</div><div class="ttdoc">Get an iterator to the first element in a buffer sequence.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:374</div></div>
<div class="ttc" id="anamespaceasio_html_aa68ad2484cefa6ed9a53783912ae0cd1"><div class="ttname"><a href="namespaceasio.html#aa68ad2484cefa6ed9a53783912ae0cd1">asio::buffer_sequence_end</a></div><div class="ttdeci">const mutable_buffer * buffer_sequence_end(const MutableBuffer &amp;b, constraint_t&lt; is_convertible&lt; const MutableBuffer *, const mutable_buffer * &gt;::value &gt;=0) noexcept</div><div class="ttdoc">Get an iterator to one past the end element in a buffer sequence.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:425</div></div>
</div><!-- fragment --><p>The <code>BufferSequence</code> template parameter may meet either of the <code>ConstBufferSequence</code> or <code>MutableBufferSequence</code> type requirements. </p>

</div>
</div>
<a id="a9d6099d23e9bf78b2b1ad82d164d3d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6099d23e9bf78b2b1ad82d164d3d7e">&#9670;&nbsp;</a></span>buffers_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt;BufferSequence&gt; asio::buffers_begin </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an iterator representing the beginning of the buffers' data. </p>

</div>
</div>
<a id="a2ef4b181d4561848de38fac7907d4a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef4b181d4561848de38fac7907d4a0b">&#9670;&nbsp;</a></span>buffers_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt;BufferSequence&gt; asio::buffers_end </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an iterator representing the end of the buffers' data. </p>

</div>
</div>
<a id="a5abd764e6b852835571e5cb4c930bd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abd764e6b852835571e5cb4c930bd7e">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line"><a class="code" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, r.resolve(q), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">} </div>
<div class="ttc" id="anamespaceasio_html_ad9722498362a99a18c1daabb554ac3f7"><div class="ttname"><a href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a></div><div class="ttdeci">Protocol::endpoint connect(basic_socket&lt; Protocol, Executor &gt; &amp;s, const EndpointSequence &amp;endpoints, constraint_t&lt; is_endpoint_sequence&lt; EndpointSequence &gt;::value &gt;=0)</div><div class="ttdoc">Establishes a socket connection by trying each endpoint in a sequence.</div><div class="ttdef"><b>Definition:</b> connect.hpp:105</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ade06be9648ccde981018a338c7632e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade06be9648ccde981018a338c7632e45">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line">tcp::endpoint e = <a class="code" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    r.resolve(q), my_connect_condition(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a031d5e27ec81047da231bde839fb85bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031d5e27ec81047da231bde839fb85bb">&#9670;&nbsp;</a></span>connect() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line">tcp::endpoint e = <a class="code" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    r.resolve(q), my_connect_condition());</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; e &lt;&lt; std::endl; </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad9722498362a99a18c1daabb554ac3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9722498362a99a18c1daabb554ac3f7">&#9670;&nbsp;</a></span>connect() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename EndpointSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, r.resolve(q)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2ca5902654f85cf76894c70a5b6dff8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca5902654f85cf76894c70a5b6dff8c">&#9670;&nbsp;</a></span>connect() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="acdbda2bad32196cba1acb1c55e8de48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbda2bad32196cba1acb1c55e8de48c">&#9670;&nbsp;</a></span>connect() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="a9e5d277d4becd28d1ce842b06dd49fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5d277d4becd28d1ce842b06dd49fc3">&#9670;&nbsp;</a></span>connect() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="a9236388f7582169e3db3ff52e8a38a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9236388f7582169e3db3ff52e8a38a11">&#9670;&nbsp;</a></span>connect() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9" title="(Deprecated.) The iterator type.">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="aa8c58255744686dfcd930523d98bc0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c58255744686dfcd930523d98bc0c2">&#9670;&nbsp;</a></span>connect() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>An iterator denoting the successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, e.begin(), e.end()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5be799cfeb2dc75e371ffba20d2e62db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be799cfeb2dc75e371ffba20d2e62db">&#9670;&nbsp;</a></span>connect() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line"><a class="code" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, e.begin(), e.end(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad2f94719f8fa630e293df94e5819e4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f94719f8fa630e293df94e5819e4ba">&#9670;&nbsp;</a></span>connect() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>An iterator denoting the successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line">tcp::resolver::results_type::iterator i = <a class="code" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(</div>
<div class="line">    <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, e.begin(), e.end(), my_connect_condition());</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;endpoint() &lt;&lt; std::endl; </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aec7be5e72ae43d07fced121d88f7b1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7be5e72ae43d07fced121d88f7b1e2">&#9670;&nbsp;</a></span>connect() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor , typename Iterator , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line"><a class="code" href="namespaceasio__query__fn.html#a3d6e4aae3743b6a687ef4d0ecad4a29c">tcp::resolver::query</a> q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line"><a class="code" href="namespaceasio_1_1detail_1_1socket__ops.html#a90aa9a854148c26da8232e25988623d8">tcp::socket</a> <a class="code" href="blocking_8cpp.html#a0337bda4434eac48c7c441ec80725e39">s</a>(my_context);</div>
<div class="line"><a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line">tcp::resolver::results_type::iterator i = <a class="code" href="namespaceasio.html#ad9722498362a99a18c1daabb554ac3f7">asio::connect</a>(</div>
<div class="line">    <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, e.begin(), e.end(), my_connect_condition());</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;endpoint() &lt;&lt; std::endl;</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a098a6ff85aafb5dde83726487338ad0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098a6ff85aafb5dde83726487338ad0b">&#9670;&nbsp;</a></span>consign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename... Values&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1consign__t.html">consign_t</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;CompletionToken&gt;, <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;Values&gt;...&gt; asio::consign </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>completion_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Values &amp;&amp;...&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Completion token adapter used to specify that the completion handler should carry additional values along with it. This completion token adapter is typically used to keep at least one copy of an object, such as a smart pointer, alive until the completion handler is called. </p>

</div>
</div>
<a id="a3804553f7845ac3c1adf58c5e872be92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3804553f7845ac3c1adf58c5e872be92">&#9670;&nbsp;</a></span>defer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto asio::defer </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;Executor&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;(<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &amp;&amp;<a class="el" href="structasio_1_1can__require.html">can_require</a>&lt; Executor, <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#ae363485c4c68b7d6dee9f9bb863e3877">execution::blocking_t::never_t</a> &gt;::value)||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__defer__with__executor.html">detail::initiate_defer_with_executor</a>&lt;Executor&gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#a22593523345cc52158f906f33a38cb15" title="Submits a completion token or function object for execution.">defer()</a></code>.</p>
<p>The use of <code><a class="el" href="namespaceasio.html#a22593523345cc52158f906f33a38cb15" title="Submits a completion token or function object for execution.">defer()</a></code>, rather than <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b">post()</a>, indicates the caller's preference that the executor defer the queueing of the function object. This may allow the executor to optimise queueing for cases when the function object represents a continuation of the current call context.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The target executor.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void()</a>&gt;(Init{ex}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using</span> executor_type = Executor;</div>
<div class="line">  <span class="keyword">explicit</span> Init(<span class="keyword">const</span> Executor&amp; ex) : ex_(ex) {}</div>
<div class="line">  executor_type get_executor() const noexcept { <span class="keywordflow">return</span> ex_; }</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Executor ex_; <span class="comment">// exposition only</span></div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> of type <code>Ex1</code> by performing<div class="fragment"><div class="line"><span class="keyword">auto</span> ex1 = <a class="code" href="namespaceasio.html#ababee4f6241fcc45f5d49b89085e6a62">get_associated_executor</a>(handler, ex); </div>
<div class="ttc" id="anamespaceasio_html_ababee4f6241fcc45f5d49b89085e6a62"><div class="ttname"><a href="namespaceasio.html#ababee4f6241fcc45f5d49b89085e6a62">asio::get_associated_executor</a></div><div class="ttdeci">ASIO_NODISCARD associated_executor&lt; T &gt;::type get_associated_executor(const T &amp;t) noexcept</div><div class="ttdoc">Helper function to obtain an object's associated executor.</div><div class="ttdef"><b>Definition:</b> associated_executor.hpp:143</div></div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler); </div>
<div class="ttc" id="anamespaceasio_html_a713d72690f79a12548b3d3199b6d2a16"><div class="ttname"><a href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">asio::get_associated_allocator</a></div><div class="ttdeci">ASIO_NODISCARD associated_allocator&lt; T &gt;::type get_associated_allocator(const T &amp;t) noexcept</div><div class="ttdoc">Helper function to obtain an object's associated allocator.</div><div class="ttdef"><b>Definition:</b> associated_allocator.hpp:140</div></div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is true, constructs a function object <code>f</code> with a member <code>executor_</code> that is initialised with <code>prefer(ex1, execution::outstanding_work.tracked)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler_);</div>
<div class="line"><a class="code" href="namespaceasio__prefer__fn.html#a9ec3f44aa720d0090954ce296b9b6677">prefer</a>(executor_, <a class="code" href="namespaceasio_1_1execution.html#a926bc4243fb20fcef1eab6ec71a9cd2c">execution::allocator</a>(<a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>)).execute(std::move(handler_));</div>
<div class="ttc" id="anamespaceasio_1_1execution_html_a926bc4243fb20fcef1eab6ec71a9cd2c"><div class="ttname"><a href="namespaceasio_1_1execution.html#a926bc4243fb20fcef1eab6ec71a9cd2c">asio::execution::allocator</a></div><div class="ttdeci">constexpr allocator_t&lt; void &gt; allocator</div><div class="ttdef"><b>Definition:</b> allocator.hpp:228</div></div>
<div class="ttc" id="anamespaceasio__prefer__fn_html_a9ec3f44aa720d0090954ce296b9b6677"><div class="ttname"><a href="namespaceasio__prefer__fn.html#a9ec3f44aa720d0090954ce296b9b6677">asio_prefer_fn::prefer</a></div><div class="ttdeci">void prefer()</div></div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is false, constructs a function object <code>f</code> with a member <code>work_</code> that is initialised with <code>make_work_guard(ex1)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler_);</div>
<div class="line">work_.get_executor().dispatch(std::move(handler_), <a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>);</div>
<div class="line">work_.reset(); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line"><a class="code" href="namespaceasio__prefer__fn.html#a9ec3f44aa720d0090954ce296b9b6677">prefer</a>(</div>
<div class="line">   <a class="code" href="namespaceasio__prefer__fn.html#ad9f5bbff9f811ec8260d87188a67e7af">require</a>(ex, <a class="code" href="namespaceasio_1_1execution.html#a7c3ae01b985e7cceb8342211456dfcbc">execution::blocking</a>.never),</div>
<div class="line">   <a class="code" href="namespaceasio_1_1execution.html#a52c60ce77fc6ec92c640afc33e47641d">execution::relationship</a>.continuation,</div>
<div class="line">   <a class="code" href="namespaceasio_1_1execution.html#a926bc4243fb20fcef1eab6ec71a9cd2c">execution::allocator</a>(alloc)</div>
<div class="line"> ).execute(std::move(<a class="code" href="namespaceasio.html#ac172b717c13db01d7f99af7e42edcb68">f</a>)); </div>
<div class="ttc" id="anamespaceasio_1_1execution_html_a52c60ce77fc6ec92c640afc33e47641d"><div class="ttname"><a href="namespaceasio_1_1execution.html#a52c60ce77fc6ec92c640afc33e47641d">asio::execution::relationship</a></div><div class="ttdeci">constexpr relationship_t relationship</div><div class="ttdef"><b>Definition:</b> relationship.hpp:545</div></div>
<div class="ttc" id="anamespaceasio_1_1execution_html_a7c3ae01b985e7cceb8342211456dfcbc"><div class="ttname"><a href="namespaceasio_1_1execution.html#a7c3ae01b985e7cceb8342211456dfcbc">asio::execution::blocking</a></div><div class="ttdeci">constexpr blocking_t blocking</div><div class="ttdef"><b>Definition:</b> blocking.hpp:895</div></div>
<div class="ttc" id="anamespaceasio__prefer__fn_html_ad9f5bbff9f811ec8260d87188a67e7af"><div class="ttname"><a href="namespaceasio__prefer__fn.html#ad9f5bbff9f811ec8260d87188a67e7af">asio_prefer_fn::require</a></div><div class="ttdeci">void require()</div></div>
<div class="ttc" id="anamespaceasio_html_ac172b717c13db01d7f99af7e42edcb68"><div class="ttname"><a href="namespaceasio.html#ac172b717c13db01d7f99af7e42edcb68">asio::f</a></div><div class="ttdeci">F &amp;&amp; f</div><div class="ttdef"><b>Definition:</b> co_spawn.hpp:410</div></div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.defer(std::move(<a class="code" href="namespaceasio.html#ac172b717c13db01d7f99af7e42edcb68">f</a>), alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a771cc8268158afdb68d73c52398d4817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771cc8268158afdb68d73c52398d4817">&#9670;&nbsp;</a></span>defer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto asio::defer </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;typename&#160;ExecutionContext::executor_type&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__defer__with__executor.html">detail::initiate_defer_with_executor</a>&lt;
        typename ExecutionContext::executor_type&gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An execution context, from which the target executor is obtained.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd><code>defer(ctx.get_executor(), forward&lt;NullaryToken&gt;(token))</code>.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a22593523345cc52158f906f33a38cb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22593523345cc52158f906f33a38cb15">&#9670;&nbsp;</a></span>defer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto asio::defer </td>
          <td>(</td>
          <td class="paramtype">NullaryToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__defer.html">detail::initiate_defer</a>&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#a22593523345cc52158f906f33a38cb15" title="Submits a completion token or function object for execution.">defer()</a></code>.</p>
<p>The use of <code><a class="el" href="namespaceasio.html#a22593523345cc52158f906f33a38cb15" title="Submits a completion token or function object for execution.">defer()</a></code>, rather than <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b">post()</a>, indicates the caller's preference that the executor defer the queueing of the function object. This may allow the executor to optimise queueing for cases when the function object represents a continuation of the current call context.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void()</a>&gt;(Init{}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> of type <code>Ex</code> by performing<div class="fragment"><div class="line"><span class="keyword">auto</span> ex = <a class="code" href="namespaceasio.html#ababee4f6241fcc45f5d49b89085e6a62">get_associated_executor</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line"><a class="code" href="namespaceasio__prefer__fn.html#a9ec3f44aa720d0090954ce296b9b6677">prefer</a>(</div>
<div class="line">   <a class="code" href="namespaceasio__prefer__fn.html#ad9f5bbff9f811ec8260d87188a67e7af">require</a>(ex, <a class="code" href="namespaceasio_1_1execution.html#a7c3ae01b985e7cceb8342211456dfcbc">execution::blocking</a>.never),</div>
<div class="line">   <a class="code" href="namespaceasio_1_1execution.html#a52c60ce77fc6ec92c640afc33e47641d">execution::relationship</a>.continuation,</div>
<div class="line">   <a class="code" href="namespaceasio_1_1execution.html#a926bc4243fb20fcef1eab6ec71a9cd2c">execution::allocator</a>(alloc)</div>
<div class="line"> ).execute(std::forward&lt;CompletionHandler&gt;(completion_handler)); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.defer(</div>
<div class="line">   std::forward&lt;CompletionHandler&gt;(completion_handler),</div>
<div class="line">   alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a80db88672c1158f8662ac040ad6cb975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80db88672c1158f8662ac040ad6cb975">&#9670;&nbsp;</a></span>dispatch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::dispatch </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;Executor&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__dispatch__with__executor.html">detail::initiate_dispatch_with_executor</a>&lt;Executor&gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the specified executor. The function object may be called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#a0b53f4ff238fefdfbaf52153b89e6abd" title="Submits a completion token or function object for execution.">dispatch()</a></code>. Otherwise, it is queued for execution.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The target executor.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void()</a>&gt;(Init{ex}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using</span> executor_type = Executor;</div>
<div class="line">  <span class="keyword">explicit</span> Init(<span class="keyword">const</span> Executor&amp; ex) : ex_(ex) {}</div>
<div class="line">  executor_type get_executor() const noexcept { <span class="keywordflow">return</span> ex_; }</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Executor ex_; <span class="comment">// exposition only</span></div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> of type <code>Ex1</code> by performing<div class="fragment"><div class="line"><span class="keyword">auto</span> ex1 = <a class="code" href="namespaceasio.html#ababee4f6241fcc45f5d49b89085e6a62">get_associated_executor</a>(handler, ex); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is true, constructs a function object <code>f</code> with a member <code>executor_</code> that is initialised with <code>prefer(ex1, execution::outstanding_work.tracked)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler_);</div>
<div class="line"><a class="code" href="namespaceasio__prefer__fn.html#a9ec3f44aa720d0090954ce296b9b6677">prefer</a>(executor_, <a class="code" href="namespaceasio_1_1execution.html#a926bc4243fb20fcef1eab6ec71a9cd2c">execution::allocator</a>(<a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>)).execute(std::move(handler_));</div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is false, constructs a function object <code>f</code> with a member <code>work_</code> that is initialised with <code>make_work_guard(ex1)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler_);</div>
<div class="line">work_.get_executor().dispatch(std::move(handler_), <a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>);</div>
<div class="line">work_.reset(); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line"><a class="code" href="namespaceasio__prefer__fn.html#a9ec3f44aa720d0090954ce296b9b6677">prefer</a>(ex, <a class="code" href="namespaceasio_1_1execution.html#a926bc4243fb20fcef1eab6ec71a9cd2c">execution::allocator</a>(alloc)).execute(std::move(<a class="code" href="namespaceasio.html#ac172b717c13db01d7f99af7e42edcb68">f</a>)); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.dispatch(std::move(<a class="code" href="namespaceasio.html#ac172b717c13db01d7f99af7e42edcb68">f</a>), alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a61872a90ad6c43350f9c0f0d4d1bcff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61872a90ad6c43350f9c0f0d4d1bcff7">&#9670;&nbsp;</a></span>dispatch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::dispatch </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;ExecutionContext::executor_type&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__dispatch__with__executor.html">detail::initiate_dispatch_with_executor</a>&lt;
        typename ExecutionContext::executor_type&gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An execution context, from which the target executor is obtained.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd><code>dispatch(ctx.get_executor(), forward&lt;NullaryToken&gt;(token))</code>.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0b53f4ff238fefdfbaf52153b89e6abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b53f4ff238fefdfbaf52153b89e6abd">&#9670;&nbsp;</a></span>dispatch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::dispatch </td>
          <td>(</td>
          <td class="paramtype">NullaryToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__dispatch.html">detail::initiate_dispatch</a>&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the object's associated executor. The function object may be called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#a0b53f4ff238fefdfbaf52153b89e6abd" title="Submits a completion token or function object for execution.">dispatch()</a></code>. Otherwise, it is queued for execution.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void()</a>&gt;(Init{}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> of type <code>Ex</code> by performing<div class="fragment"><div class="line"><span class="keyword">auto</span> ex = <a class="code" href="namespaceasio.html#ababee4f6241fcc45f5d49b89085e6a62">get_associated_executor</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line"><a class="code" href="namespaceasio__prefer__fn.html#a9ec3f44aa720d0090954ce296b9b6677">prefer</a>(ex, <a class="code" href="namespaceasio_1_1execution.html#a926bc4243fb20fcef1eab6ec71a9cd2c">execution::allocator</a>(alloc)).execute(</div>
<div class="line">   std::forward&lt;CompletionHandler&gt;(completion_handler)); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.dispatch(</div>
<div class="line">   std::forward&lt;CompletionHandler&gt;(completion_handler),</div>
<div class="line">   alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ace6f6adc11c370728371137c6b88fded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6f6adc11c370728371137c6b88fded">&#9670;&nbsp;</a></span>dynamic_buffer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt;Elem, Traits, Allocator&gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given string. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>dynamic_string_buffer&lt;Elem, Traits, Allocator&gt;(data)</code>. </dd></dl>

</div>
</div>
<a id="acaddfeb029fa95e3f6470d258ebe36f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaddfeb029fa95e3f6470d258ebe36f3">&#9670;&nbsp;</a></span>dynamic_buffer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt;Elem, Traits, Allocator&gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given string. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>dynamic_string_buffer&lt;Elem, Traits, Allocator&gt;(data, max_size)</code>. </dd></dl>

</div>
</div>
<a id="a8a694b7ecee8746dafc8c99d194aeb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a694b7ecee8746dafc8c99d194aeb68">&#9670;&nbsp;</a></span>dynamic_buffer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt;Elem, Allocator&gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Elem, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given vector. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>dynamic_vector_buffer&lt;Elem, Allocator&gt;(data)</code>. </dd></dl>

</div>
</div>
<a id="ae141ff85742cdbc7e1080a3a3af80d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae141ff85742cdbc7e1080a3a3af80d62">&#9670;&nbsp;</a></span>dynamic_buffer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt;Elem, Allocator&gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Elem, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given vector. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>dynamic_vector_buffer&lt;Elem, Allocator&gt;(data, max_size)</code>. </dd></dl>

</div>
</div>
<a id="a713d72690f79a12548b3d3199b6d2a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713d72690f79a12548b3d3199b6d2a16">&#9670;&nbsp;</a></span>get_associated_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt;T&gt;::type asio::get_associated_allocator </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated allocator. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>associated_allocator&lt;T&gt;::get(t)</code> </dd></dl>

</div>
</div>
<a id="a82c18a9b1d0d55eb89746a4c0e679345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c18a9b1d0d55eb89746a4c0e679345">&#9670;&nbsp;</a></span>get_associated_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto asio::get_associated_allocator </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt;T, Allocator&gt;::get(t, <a class="el" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated allocator. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>associated_allocator&lt;T, Allocator&gt;::get(t, a)</code> </dd></dl>

</div>
</div>
<a id="a3b51cb1d32c89024cf7768bcce6f649e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b51cb1d32c89024cf7768bcce6f649e">&#9670;&nbsp;</a></span>get_associated_cancellation_slot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a>&lt;T&gt;::type asio::get_associated_cancellation_slot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated <a class="el" href="classasio_1_1cancellation__slot.html" title="A slot associated with a cancellation signal.">cancellation_slot</a>. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>associated_cancellation_slot&lt;T&gt;::get(t)</code> </dd></dl>

</div>
</div>
<a id="a69ba7c6fbf3206e8f4fbc64bc69c5644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ba7c6fbf3206e8f4fbc64bc69c5644">&#9670;&nbsp;</a></span>get_associated_cancellation_slot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename CancellationSlot &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto asio::get_associated_cancellation_slot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CancellationSlot &amp;&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structasio_1_1associated__cancellation__slot.html">associated_cancellation_slot</a>&lt;T, CancellationSlot&gt;::get(t, st))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated <a class="el" href="classasio_1_1cancellation__slot.html" title="A slot associated with a cancellation signal.">cancellation_slot</a>. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code><a class="el" href="structasio_1_1associated__cancellation__slot.html" title="Traits type used to obtain the cancellation_slot associated with an object.">associated_cancellation_slot</a>&lt;T, CancellationSlot&gt;::get(t, st)</code> </dd></dl>

</div>
</div>
<a id="ababee4f6241fcc45f5d49b89085e6a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababee4f6241fcc45f5d49b89085e6a62">&#9670;&nbsp;</a></span>get_associated_executor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T&gt;::type asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>associated_executor&lt;T&gt;::get(t)</code> </dd></dl>

</div>
</div>
<a id="ad0f3ac3ddba1f3274b26dcb8f4b8c6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f3ac3ddba1f3274b26dcb8f4b8c6f6">&#9670;&nbsp;</a></span>get_associated_executor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T, Executor&gt;::get(t, ex))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>associated_executor&lt;T, Executor&gt;::get(t, ex)</code> </dd></dl>

</div>
</div>
<a id="afa0760a87f5f3fd90c84bd107449be00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0760a87f5f3fd90c84bd107449be00">&#9670;&nbsp;</a></span>get_associated_executor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T, typename ExecutionContext::executor_type&gt;::type asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code><a class="el" href="structasio_1_1associated__executor.html" title="Traits type used to obtain the executor associated with an object.">associated_executor</a>&lt;T, typename ExecutionContext::executor_type&gt;::get(t, ctx.get_executor())</code> </dd></dl>

</div>
</div>
<a id="a754bcbf3e3c8b84637a949642a35e03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754bcbf3e3c8b84637a949642a35e03b">&#9670;&nbsp;</a></span>get_associated_immediate_executor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> auto asio::get_associated_immediate_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a>&lt;T, Executor&gt;::get(t, ex))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code>associated_immediate_executor&lt;T, Executor&gt;::get(t, ex)</code> </dd></dl>

</div>
</div>
<a id="acf785ef6a588421ec1805478d13ce1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf785ef6a588421ec1805478d13ce1d3">&#9670;&nbsp;</a></span>get_associated_immediate_executor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="structasio_1_1associated__immediate__executor.html">associated_immediate_executor</a>&lt;T, typename ExecutionContext::executor_type&gt;::type asio::get_associated_immediate_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Возвращает</dt><dd><code><a class="el" href="structasio_1_1associated__immediate__executor.html" title="Traits type used to obtain the immediate executor associated with an object.">associated_immediate_executor</a>&lt;T, typename ExecutionContext::executor_type&gt;::get(t, ctx.get_executor())</code> </dd></dl>

</div>
</div>
<a id="a2e34e09c0ef0fc9a740fc96a62c4d2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e34e09c0ef0fc9a740fc96a62c4d2d5">&#9670;&nbsp;</a></span>has_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool asio::has_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to determine whether the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> contains a service object corresponding to the given service type.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>A boolean indicating whether the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> contains the service. </dd></dl>

</div>
</div>
<a id="a9e72dd23c9362d084e639acace1d23c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e72dd23c9362d084e639acace1d23c7">&#9670;&nbsp;</a></span>make_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Service&amp; asio::make_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to add a service to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
    <tr><td class="paramname">args</td><td>Zero or more arguments to be passed to the service constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1service__already__exists.html">asio::service_already_exists</a></td><td>Thrown if a service of the given type is already present in the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8f1fd1cb6a3fa85681fea378fef6abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f1fd1cb6a3fa85681fea378fef6abb">&#9670;&nbsp;</a></span>make_strand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1strand.html">strand</a>&lt;Executor&gt; asio::make_strand </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an executor. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>An executor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>A strand constructed with the specified executor. </dd></dl>

</div>
</div>
<a id="a63385b38f9c6d5c54c2791a8a903dd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63385b38f9c6d5c54c2791a8a903dd07">&#9670;&nbsp;</a></span>make_strand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1strand.html">strand</a>&lt;typename ExecutionContext::executor_type&gt; asio::make_strand </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an execution context. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An execution context, from which an executor will be obtained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>A strand constructed with the execution context's executor, obtained by performing <code>ctx.get_executor()</code>. </dd></dl>

</div>
</div>
<a id="a09e1859adad251134e5c146b263fac5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e1859adad251134e5c146b263fac5a">&#9670;&nbsp;</a></span>make_work_guard() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt;Executor&gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>An executor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>A work guard constructed with the specified executor. </dd></dl>

</div>
</div>
<a id="a274b320676965e3bd10bdcc8a2c24336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274b320676965e3bd10bdcc8a2c24336">&#9670;&nbsp;</a></span>make_work_guard() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt;T&gt;::value &amp;&amp; !is_convertible&lt;T&amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a>&amp;&gt;::value, <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T&gt; &gt;::type&gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>An arbitrary object, such as a completion handler, for which the associated executor will be obtained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>A work guard constructed with the associated executor of the object <code>t</code>, which is obtained as if by calling <code>get_associated_executor(t)</code>. </dd></dl>

</div>
</div>
<a id="a66586166967838d0924298cee3b042d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66586166967838d0924298cee3b042d4">&#9670;&nbsp;</a></span>make_work_guard() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt;<a class="el" href="namespaceasio.html#a947971ca8e87d2d9d7791b50b7fed58d">associated_executor_t</a>&lt;T, Executor&gt; &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>An arbitrary object, such as a completion handler, for which the associated executor will be obtained.</td></tr>
    <tr><td class="paramname">ex</td><td>An executor to be used as the candidate object when determining the associated executor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>A work guard constructed with the associated executor of the object <code>t</code>, which is obtained as if by calling <code>get_associated_executor(t, ex)</code>. </dd></dl>

</div>
</div>
<a id="ad34b7d3ea8eab4f3a308422c2772c62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34b7d3ea8eab4f3a308422c2772c62e">&#9670;&nbsp;</a></span>make_work_guard() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; <a class="el" href="namespaceasio.html#a947971ca8e87d2d9d7791b50b7fed58d">associated_executor_t</a>&lt;T, typename ExecutionContext::executor_type&gt; &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; T &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>An arbitrary object, such as a completion handler, for which the associated executor will be obtained.</td></tr>
    <tr><td class="paramname">ctx</td><td>An execution context, from which an executor is obtained to use as the candidate object for determining the associated executor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>A work guard constructed with the associated executor of the object <code>t</code>, which is obtained as if by calling <code>get_associated_executor(t, ctx.get_executor())</code>. </dd></dl>

</div>
</div>
<a id="a38be2110c5123ceebc94f91971b93f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38be2110c5123ceebc94f91971b93f31">&#9670;&nbsp;</a></span>make_work_guard() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt;typename ExecutionContext::executor_type&gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An execution context, from which an executor will be obtained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>A work guard constructed with the execution context's executor, obtained by performing <code>ctx.get_executor()</code>. </dd></dl>

</div>
</div>
<a id="acb1502dd4243e9745eaad2753e5ee24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1502dd4243e9745eaad2753e5ee24c">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Head , typename Tail &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::operator| </td>
          <td>(</td>
          <td class="paramtype">Head&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tail &amp;&amp;&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;
      <a class="el" href="structasio_1_1is__deferred.html">is_deferred</a>&lt;Head&gt;::value,
      decltype(static_cast&lt;Head&amp;&amp;&gt;(head)(static_cast&lt;Tail&amp;&amp;&gt;(tail)))
    &gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipe operator used to chain deferred operations. </p>

</div>
</div>
<a id="a1e26b0422e66c6dbc1b161830964d2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e26b0422e66c6dbc1b161830964d2c9">&#9670;&nbsp;</a></span>post() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;Executor&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::post </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;Executor&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt;(<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &amp;&amp;<a class="el" href="structasio_1_1can__require.html">can_require</a>&lt; Executor, <a class="el" href="structasio_1_1execution_1_1detail_1_1blocking__t.html#ae363485c4c68b7d6dee9f9bb863e3877">execution::blocking_t::never_t</a> &gt;::value)||<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__post__with__executor.html">detail::initiate_post_with_executor</a>&lt;Executor&gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">post()</a></code>.</p>
<p>The use of <code><a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">post()</a></code>, rather than <a class="el" href="namespaceasio.html#a22593523345cc52158f906f33a38cb15">defer()</a>, indicates the caller's preference that the function object be eagerly queued for execution.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The target executor.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void()</a>&gt;(Init{ex}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using</span> executor_type = Executor;</div>
<div class="line">  <span class="keyword">explicit</span> Init(<span class="keyword">const</span> Executor&amp; ex) : ex_(ex) {}</div>
<div class="line">  executor_type get_executor() const noexcept { <span class="keywordflow">return</span> ex_; }</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Executor ex_; <span class="comment">// exposition only</span></div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> of type <code>Ex1</code> by performing<div class="fragment"><div class="line"><span class="keyword">auto</span> ex1 = <a class="code" href="namespaceasio.html#ababee4f6241fcc45f5d49b89085e6a62">get_associated_executor</a>(handler, ex); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is true, constructs a function object <code>f</code> with a member <code>executor_</code> that is initialised with <code>prefer(ex1, execution::outstanding_work.tracked)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler_);</div>
<div class="line"><a class="code" href="namespaceasio__prefer__fn.html#a9ec3f44aa720d0090954ce296b9b6677">prefer</a>(executor_, <a class="code" href="namespaceasio_1_1execution.html#a926bc4243fb20fcef1eab6ec71a9cd2c">execution::allocator</a>(<a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>)).execute(std::move(handler_));</div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex1&gt;::value</code> is false, constructs a function object <code>f</code> with a member <code>work_</code> that is initialised with <code>make_work_guard(ex1)</code>, a member <code>handler_</code> that is a decay-copy of <code>completion_handler</code>, and a function call operator that performs: <div class="fragment"><div class="line"> <span class="keyword">auto</span> <a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a> = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler_);</div>
<div class="line">work_.get_executor().dispatch(std::move(handler_), <a class="code" href="namespaceasio.html#aa80c4033469ae5aaa092c0d49852403c">a</a>);</div>
<div class="line">work_.reset(); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line"><a class="code" href="namespaceasio__prefer__fn.html#a9ec3f44aa720d0090954ce296b9b6677">prefer</a>(</div>
<div class="line">   <a class="code" href="namespaceasio__prefer__fn.html#ad9f5bbff9f811ec8260d87188a67e7af">require</a>(ex, <a class="code" href="namespaceasio_1_1execution.html#a7c3ae01b985e7cceb8342211456dfcbc">execution::blocking</a>.never),</div>
<div class="line">   <a class="code" href="namespaceasio_1_1execution.html#a52c60ce77fc6ec92c640afc33e47641d">execution::relationship</a>.<a class="code" href="yield_8hpp.html#ab2e49d0b8dbb3181c7d1f622fd5ea1b4">fork</a>,</div>
<div class="line">   <a class="code" href="namespaceasio_1_1execution.html#a926bc4243fb20fcef1eab6ec71a9cd2c">execution::allocator</a>(alloc)</div>
<div class="line"> ).execute(std::move(<a class="code" href="namespaceasio.html#ac172b717c13db01d7f99af7e42edcb68">f</a>)); </div>
<div class="ttc" id="ayield_8hpp_html_ab2e49d0b8dbb3181c7d1f622fd5ea1b4"><div class="ttname"><a href="yield_8hpp.html#ab2e49d0b8dbb3181c7d1f622fd5ea1b4">fork</a></div><div class="ttdeci">#define fork</div><div class="ttdef"><b>Definition:</b> yield.hpp:22</div></div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.post(std::move(<a class="code" href="namespaceasio.html#ac172b717c13db01d7f99af7e42edcb68">f</a>), alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a04753b6108fc896cc453f89c28bebbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04753b6108fc896cc453f89c28bebbb6">&#9670;&nbsp;</a></span>post() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken = default_completion_token_t&lt;typename ExecutionContext::executor_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::post </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;ExecutionContext::executor_type&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__post__with__executor.html">detail::initiate_post_with_executor</a>&lt;
        typename ExecutionContext::executor_type&gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An execution context, from which the target executor is obtained.</td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd><code>post(ctx.get_executor(), forward&lt;NullaryToken&gt;(token))</code>.</dd></dl>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab96ddebcabf9c7f1524f803bc063a62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96ddebcabf9c7f1524f803bc063a62b">&#9670;&nbsp;</a></span>post() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ASIO_COMPLETION_TOKEN_FOR(void()) NullaryToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::post </td>
          <td>(</td>
          <td class="paramtype">NullaryToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td> -&gt; decltype(
    <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>()&gt;(
      declval&lt;<a class="el" href="classasio_1_1detail_1_1initiate__post.html">detail::initiate_post</a>&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">post()</a></code>.</p>
<p>The use of <code><a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">post()</a></code>, rather than <a class="el" href="namespaceasio.html#a22593523345cc52158f906f33a38cb15">defer()</a>, indicates the caller's preference that the function object be eagerly queued for execution.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The completion_token that will be used to produce a completion handler. The function signature of the completion handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>This function returns <code>async_initiate&lt;NullaryToken, <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void()</a>&gt;(Init{}, token)</code>, where <code>Init</code> is a function object type defined as:</dd></dl>
<div class="fragment"><div class="line"> <span class="keyword">class </span>Init</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionHandler&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CompletionHandler&amp;&amp; completion_handler) <span class="keyword">const</span>;</div>
<div class="line">}; </div>
</div><!-- fragment --><p>The function call operator of <code>Init:</code> </p>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> of type <code>Ex</code> by performing<div class="fragment"><div class="line"><span class="keyword">auto</span> ex = <a class="code" href="namespaceasio.html#ababee4f6241fcc45f5d49b89085e6a62">get_associated_executor</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <div class="fragment"><div class="line"><span class="keyword">auto</span> alloc = <a class="code" href="namespaceasio.html#a713d72690f79a12548b3d3199b6d2a16">get_associated_allocator</a>(handler); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is true, performs <div class="fragment"><div class="line"><a class="code" href="namespaceasio__prefer__fn.html#a9ec3f44aa720d0090954ce296b9b6677">prefer</a>(</div>
<div class="line">   <a class="code" href="namespaceasio__prefer__fn.html#ad9f5bbff9f811ec8260d87188a67e7af">require</a>(ex, <a class="code" href="namespaceasio_1_1execution.html#a7c3ae01b985e7cceb8342211456dfcbc">execution::blocking</a>.never),</div>
<div class="line">   <a class="code" href="namespaceasio_1_1execution.html#a52c60ce77fc6ec92c640afc33e47641d">execution::relationship</a>.<a class="code" href="yield_8hpp.html#ab2e49d0b8dbb3181c7d1f622fd5ea1b4">fork</a>,</div>
<div class="line">   <a class="code" href="namespaceasio_1_1execution.html#a926bc4243fb20fcef1eab6ec71a9cd2c">execution::allocator</a>(alloc)</div>
<div class="line"> ).execute(std::forward&lt;CompletionHandler&gt;(completion_handler)); </div>
</div><!-- fragment --></li>
</ul>
<ul>
<li>If <code>execution::is_executor&lt;Ex&gt;::value</code> is false, performs <div class="fragment"><div class="line">ex.post(</div>
<div class="line">   std::forward&lt;CompletionHandler&gt;(completion_handler),</div>
<div class="line">   alloc); </div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>() </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a316656e80eb9e91ec172ae49f001df9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316656e80eb9e91ec172ae49f001df9e">&#9670;&nbsp;</a></span>prepend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken , typename... Values&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1prepend__t.html">prepend_t</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;CompletionToken&gt;, <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;Values&gt;...&gt; asio::prepend </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>completion_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Values &amp;&amp;...&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Completion token type used to specify that the completion handler arguments should be passed additional values before the results of the operation. </p>

</div>
</div>
<a id="aaeda9d140628ff399cbe4a076cb15cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeda9d140628ff399cbe4a076cb15cee">&#9670;&nbsp;</a></span>read() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a631b112099009564a8489b63a33e32b5"><div class="ttname"><a href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a></div><div class="ttdeci">std::size_t read(SyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec, constraint_t&lt; is_mutable_buffer_sequence&lt; MutableBufferSequence &gt;::value &gt;)</div><div class="ttdoc">Attempt to read a certain amount of data from a stream before returning.</div><div class="ttdef"><b>Definition:</b> read.hpp:63</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abc0bc3183df1291c7b2a35ec30d5428c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0bc3183df1291c7b2a35ec30d5428c">&#9670;&nbsp;</a></span>read() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aeadfb55ae835155abb8b6dc11a063b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadfb55ae835155abb8b6dc11a063b54">&#9670;&nbsp;</a></span>read() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6038b695e95ef357b104f35a28edfe3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6038b695e95ef357b104f35a28edfe3d">&#9670;&nbsp;</a></span>read() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a32d5cec2634f5f444db542d796627711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d5cec2634f5f444db542d796627711">&#9670;&nbsp;</a></span>read() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a631b112099009564a8489b63a33e32b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631b112099009564a8489b63a33e32b5">&#9670;&nbsp;</a></span>read() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a022c8748d9ecfadccd38327387244ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022c8748d9ecfadccd38327387244ab7">&#9670;&nbsp;</a></span>read() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code" href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a5a1b66b2a02d69ef013a6c4624ac1b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1b66b2a02d69ef013a6c4624ac1b33">&#9670;&nbsp;</a></span>read() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab546d1db1f4826ad961bbf51babd74f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab546d1db1f4826ad961bbf51babd74f4">&#9670;&nbsp;</a></span>read() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0e1c411da158a7ef94ed6e304beffae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1c411da158a7ef94ed6e304beffae6">&#9670;&nbsp;</a></span>read() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a5a42b8438aa955e5bbf53a06586fe8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a42b8438aa955e5bbf53a06586fe8fd">&#9670;&nbsp;</a></span>read() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a58f94b6f250650e0e9dcdf4efdf72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a58f94b6f250650e0e9dcdf4efdf72a">&#9670;&nbsp;</a></span>read() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6cc36adb5f0d169ee071a8b975f31a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc36adb5f0d169ee071a8b975f31a91">&#9670;&nbsp;</a></span>read() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a06e0fa9049de9257c2fd7f2911ffa3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e0fa9049de9257c2fd7f2911ffa3fd">&#9670;&nbsp;</a></span>read() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a35b1028b8db552014dd3a038f46075ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b1028b8db552014dd3a038f46075ea">&#9670;&nbsp;</a></span>read() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae71e9ea0f6b103926654caf7acf87578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71e9ea0f6b103926654caf7acf87578">&#9670;&nbsp;</a></span>read() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a301406c670bc22190df6e8628cbf0037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301406c670bc22190df6e8628cbf0037">&#9670;&nbsp;</a></span>read_at() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(</div>
<div class="line">   d, 42, b,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a88604242259da9fb0bacf3c4f0cc0002"><div class="ttname"><a href="namespaceasio.html#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a></div><div class="ttdeci">std::size_t read_at(SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec)</div><div class="ttdef"><b>Definition:</b> read_at.hpp:67</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4511bad893697fc58d379d6e00aa84ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4511bad893697fc58d379d6e00aa84ff">&#9670;&nbsp;</a></span>read_at() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(</div>
<div class="line">   d, 42, b,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0126c00568f324b47c24b494c97ece14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0126c00568f324b47c24b494c97ece14">&#9670;&nbsp;</a></span>read_at() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a926222f6d0bb8a716a17161a1eb725aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926222f6d0bb8a716a17161a1eb725aa">&#9670;&nbsp;</a></span>read_at() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a4ef7a26ff401494d673ad462a3f3f5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef7a26ff401494d673ad462a3f3f5c0">&#9670;&nbsp;</a></span>read_at() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(d, 42, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(</div>
<div class="line">   d, 42, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6587e766e26325457154a5dac2a0b785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6587e766e26325457154a5dac2a0b785">&#9670;&nbsp;</a></span>read_at() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(d, 42,</div>
<div class="line">   <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(</div>
<div class="line">   d, 42, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa16ebd52ad98e521ea4b75676d4db9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16ebd52ad98e521ea4b75676d4db9fd">&#9670;&nbsp;</a></span>read_at() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(d, 42, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code" href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a88604242259da9fb0bacf3c4f0cc0002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88604242259da9fb0bacf3c4f0cc0002">&#9670;&nbsp;</a></span>read_at() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a03a433d903eae4dd097bc2c55efbf1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a433d903eae4dd097bc2c55efbf1ee">&#9670;&nbsp;</a></span>read_until() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a>&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div>
<div class="line"><a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <span class="stringliteral">&quot;\r\n&quot;</span>);</div>
<div class="line">std::istream is(&amp;b);</div>
<div class="line">std::string line;</div>
<div class="line">std::getline(is, line); </div>
<div class="ttc" id="anamespaceasio_html_adf2910ba892099b5f30c18e346a5cc6c"><div class="ttname"><a href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a></div><div class="ttdeci">std::size_t read_until(SyncReadStream &amp;s, DynamicBuffer_v1 &amp;&amp;buffers, char delim, constraint_t&lt; is_dynamic_buffer_v1&lt; decay_t&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;, constraint_t&lt; !is_dynamic_buffer_v2&lt; decay_t&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;)</div><div class="ttdef"><b>Definition:</b> read_until.hpp:76</div></div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="a78faf8cf08d47515162de95b18b0a860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78faf8cf08d47515162de95b18b0a860">&#9670;&nbsp;</a></span>read_until() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="a1aae2baa82596a6a9ad320e80b016006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aae2baa82596a6a9ad320e80b016006">&#9670;&nbsp;</a></span>read_until() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div>
<div class="line"><a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">std::istream is(&amp;b);</div>
<div class="line">std::string line;</div>
<div class="line">std::getline(is, line); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ab9d265cc5b757caf9c9a602da2d6a3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d265cc5b757caf9c9a602da2d6a3e5">&#9670;&nbsp;</a></span>read_until() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="ab02f689946ae31e0c60cdaa926419f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02f689946ae31e0c60cdaa926419f43">&#9670;&nbsp;</a></span>read_until() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the streambuf's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

</div>
</div>
<a id="a8372fc4edf57763c49ed1f8cf42e6a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8372fc4edf57763c49ed1f8cf42e6a4f">&#9670;&nbsp;</a></span>read_until() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the streambuf's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a streambuf until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code" href="classasio_1_1basic__streambuf.html#a9e2ffddcb9e89d68048254ea787c2258">asio::streambuf::const_buffers_type</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::streambuf b;</div>
<div class="line"><a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, match_whitespace);</div>
</div><!-- fragment --></dd></dl>
<p>To read data into a streambuf until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> <a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) : c_(<a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">asio::streambuf b;</div>
<div class="line"><a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b, <a class="code" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae52ffc4323125340012557d3f755b6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52ffc4323125340012557d3f755b6f7">&#9670;&nbsp;</a></span>read_until() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="a2980433deecca66ed3e8337d33abdfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2980433deecca66ed3e8337d33abdfd8">&#9670;&nbsp;</a></span>read_until() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">std::size_t n = <a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    <a class="code" href="namespaceasio.html#ace6f6adc11c370728371137c6b88fded">asio::dynamic_buffer</a>(data), <span class="stringliteral">&quot;\r\n&quot;</span>);</div>
<div class="line">std::string line = data.substr(0, n);</div>
<div class="line">data.erase(0, n); </div>
<div class="ttc" id="anamespaceasio_html_ace6f6adc11c370728371137c6b88fded"><div class="ttname"><a href="namespaceasio.html#ace6f6adc11c370728371137c6b88fded">asio::dynamic_buffer</a></div><div class="ttdeci">ASIO_NODISCARD dynamic_string_buffer&lt; Elem, Traits, Allocator &gt; dynamic_buffer(std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</div><div class="ttdoc">Create a new dynamic buffer that represents the given string.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:2194</div></div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="a0e6605f31a2f18ae729ba0a19324e632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6605f31a2f18ae729ba0a19324e632">&#9670;&nbsp;</a></span>read_until() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="adf2910ba892099b5f30c18e346a5cc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2910ba892099b5f30c18e346a5cc6c">&#9670;&nbsp;</a></span>read_until() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">std::size_t n = <a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    <a class="code" href="namespaceasio.html#ace6f6adc11c370728371137c6b88fded">asio::dynamic_buffer</a>(data), <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">std::string line = data.substr(0, n);</div>
<div class="line">data.erase(0, n); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="af4fdf1b135435f7ed959c61a89dfa260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fdf1b135435f7ed959c61a89dfa260">&#9670;&nbsp;</a></span>read_until() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;DynamicBuffer_v1::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic buffer sequence's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

</div>
</div>
<a id="a44d3fafe135ad976654c7278ce009775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d3fafe135ad976654c7278ce009775">&#9670;&nbsp;</a></span>read_until() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v1 , typename MatchCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;typename DynamicBuffer_v1::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic_buffer's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a dynamic buffer sequence until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, match_whitespace);</div>
</div><!-- fragment --></dd></dl>
<p>To read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> <a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) : c_(<a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <a class="code" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9d7a79fc07a0a5dcbb8ac5c4e9658466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7a79fc07a0a5dcbb8ac5c4e9658466">&#9670;&nbsp;</a></span>read_until() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="a0bc4d5ec4ec23d9aec3cdf8ae4e76872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc4d5ec4ec23d9aec3cdf8ae4e76872">&#9670;&nbsp;</a></span>read_until() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a>&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">std::size_t n = <a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    <a class="code" href="namespaceasio.html#ace6f6adc11c370728371137c6b88fded">asio::dynamic_buffer</a>(data), <span class="stringliteral">&quot;\r\n&quot;</span>);</div>
<div class="line">std::string line = data.substr(0, n);</div>
<div class="line">data.erase(0, n); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ae9cb7c507ff2509dc675e040ebce3338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cb7c507ff2509dc675e040ebce3338">&#9670;&nbsp;</a></span>read_until() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="ab935fe986ec9477db62af1e7d514e6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab935fe986ec9477db62af1e7d514e6ed">&#9670;&nbsp;</a></span>read_until() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string data;</div>
<div class="line">std::size_t n = <a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>,</div>
<div class="line">    <a class="code" href="namespaceasio.html#ace6f6adc11c370728371137c6b88fded">asio::dynamic_buffer</a>(data), <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">std::string line = data.substr(0, n);</div>
<div class="line">data.erase(0, n); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="a57d2663e7af5457346f4463d16e4237a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d2663e7af5457346f4463d16e4237a">&#9670;&nbsp;</a></span>read_until() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;DynamicBuffer_v2::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic buffer sequence's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

</div>
</div>
<a id="a8c499c6a5bf36dfe4eae35c9afdb76a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c499c6a5bf36dfe4eae35c9afdb76a2">&#9670;&nbsp;</a></span>read_until() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer_v2 , typename MatchCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;typename DynamicBuffer_v2::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes in the dynamic_buffer's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a dynamic buffer sequence until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = begin;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, match_whitespace);</div>
</div><!-- fragment --></dd></dl>
<p>To read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code" href="classmatch__char.html">match_char</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code" href="classmatch__char.html">match_char</a>(<span class="keywordtype">char</span> <a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) : c_(<a class="code" href="namespaceasio_1_1experimental.html#a4607a9754bf2707c054f0ff16b958b82">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;<a class="code" href="classmatch__char.html">match_char</a>&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">std::string data;</div>
<div class="line"><a class="code" href="namespaceasio.html#adf2910ba892099b5f30c18e346a5cc6c">asio::read_until</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, data, <a class="code" href="classmatch__char.html">match_char</a>(<span class="charliteral">&#39;a&#39;</span>));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="affb265a718a670a944c524da5482b8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb265a718a670a944c524da5482b8c0">&#9670;&nbsp;</a></span>redirect_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1redirect__error__t.html">redirect_error_t</a>&lt;<a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt;CompletionToken&gt; &gt; asio::redirect_error </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>completion_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adapt a completion_token to capture error_code values to a variable. </p>

</div>
</div>
<a id="a0ae7adcb674ad70e29f093845916e620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae7adcb674ad70e29f093845916e620">&#9670;&nbsp;</a></span>register_buffers() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename MutableBufferSequence , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt;MutableBufferSequence, Allocator&gt; asio::register_buffers </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffer_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register buffers with an execution context. </p>

</div>
</div>
<a id="a479d7fa3ac4a25ebe9fef9fa40f88bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479d7fa3ac4a25ebe9fef9fa40f88bb2">&#9670;&nbsp;</a></span>register_buffers() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt;MutableBufferSequence&gt; asio::register_buffers </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffer_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register buffers with an execution context. </p>

</div>
</div>
<a id="ab1bc5eecc15ae7f97b76bb4d1c80b983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bc5eecc15ae7f97b76bb4d1c80b983">&#9670;&nbsp;</a></span>register_buffers() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename MutableBufferSequence , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt;MutableBufferSequence, Allocator&gt; asio::register_buffers </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffer_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register buffers with an execution context. </p>

</div>
</div>
<a id="ad2cc2487dc0e99f671d1fc545137f1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cc2487dc0e99f671d1fc545137f1a4">&#9670;&nbsp;</a></span>register_buffers() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ae9be9d972e87a686de9e5bd8bd93b39d">ASIO_NODISCARD</a> <a class="el" href="classasio_1_1buffer__registration.html">buffer_registration</a>&lt;MutableBufferSequence&gt; asio::register_buffers </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffer_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register buffers with an execution context. </p>

</div>
</div>
<a id="aa50c06820bfd7c45e903818bdc2bb578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50c06820bfd7c45e903818bdc2bb578">&#9670;&nbsp;</a></span>spawn() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename F , ASIO_COMPLETION_TOKEN_FOR(typename detail::spawn_signature&lt; result_of_t&lt; F(basic_yield_context&lt; Executor &gt;)&gt;&gt;::type) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::spawn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;Executor&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="namespaceasio.html#ae03d27556f68768ced98d0eac4a06afd">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt;&gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new stackful coroutine, inheriting the executor of another. </p>
<p>This function is used to launch a new stackful coroutine.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Identifies the current coroutine as a parent of the new coroutine. This specifies that the new coroutine should inherit the executor of the parent. For example, if the parent coroutine is executing in a particular strand, then the new coroutine will execute in the same strand.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must be callable the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> <span class="keyword">function</span>(basic_yield_context&lt;Executor&gt; <a class="code" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
<div class="ttc" id="ayield_8hpp_html_abaa9287233697b1cd0175180304c7e1d"><div class="ttname"><a href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a></div><div class="ttdeci">#define yield</div><div class="ttdef"><b>Definition:</b> yield.hpp:18</div></div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will handle the notification that the coroutine has completed. If the return type <code>R</code> of <code>function</code> is <code>void</code>, the function signature of the completion handler must be:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr); </div>
</div><!-- fragment --><p> Otherwise, the function signature of the completion handler must be: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr, R); </div>
</div><!-- fragment --><dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(std::exception_ptr, R) </div>
</div><!-- fragment --> where <code>R</code> is the return type of the function object.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>The new thread of execution is created with a cancellation state that supports <code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> values only. To change the cancellation state, call the <a class="el" href="classasio_1_1basic__yield__context.html" title="A completion_token that represents the currently executing coroutine.">basic_yield_context</a> member function <code>reset_cancellation_state</code>. </dd></dl>

</div>
</div>
<a id="aa66f1b3121cdb136eb23189c00b5bad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66f1b3121cdb136eb23189c00b5bad4">&#9670;&nbsp;</a></span>spawn() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename F , ASIO_COMPLETION_TOKEN_FOR(typename detail::spawn_signature&lt; result_of_t&lt; F(basic_yield_context&lt; Executor &gt;)&gt;&gt;::type) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::spawn </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;Executor&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value||<a class="el" href="structasio_1_1execution_1_1is__executor.html">execution::is_executor</a>&lt; Executor &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="namespaceasio.html#ae03d27556f68768ced98d0eac4a06afd">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Executor &gt;)&gt;&gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; Executor &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new stackful coroutine that executes on a given executor. </p>
<p>This function is used to launch a new stackful coroutine.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>Identifies the executor that will run the stackful coroutine.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must be callable the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> <span class="keyword">function</span>(basic_yield_context&lt;Executor&gt; <a class="code" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will handle the notification that the coroutine has completed. If the return type <code>R</code> of <code>function</code> is <code>void</code>, the function signature of the completion handler must be:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr); </div>
</div><!-- fragment --><p> Otherwise, the function signature of the completion handler must be: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr, R); </div>
</div><!-- fragment --><dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(std::exception_ptr, R) </div>
</div><!-- fragment --> where <code>R</code> is the return type of the function object.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>The new thread of execution is created with a cancellation state that supports <code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> values only. To change the cancellation state, call the <a class="el" href="classasio_1_1basic__yield__context.html" title="A completion_token that represents the currently executing coroutine.">basic_yield_context</a> member function <code>reset_cancellation_state</code>. </dd></dl>

</div>
</div>
<a id="a2a451e464208bbebc81d95561bbe2fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a451e464208bbebc81d95561bbe2fdf">&#9670;&nbsp;</a></span>spawn() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename F , ASIO_COMPLETION_TOKEN_FOR(typename detail::spawn_signature&lt; result_of_t&lt; F(basic_yield_context&lt; typename ExecutionContext::executor_type &gt;)&gt;&gt;::type) CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto asio::spawn </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em> = <code><a class="el" href="namespaceasio.html#a84bbc083cf9153b28ce2d86c3ea16458">default_completion_token_t</a>&lt;&#160;typename&#160;ExecutionContext::executor_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype( <a class="el" href="namespaceasio.html#acbf600e256af39d8a0c65fb6e3eb988d">async_initiate</a>&lt; CompletionToken, typename <a class="el" href="structasio_1_1detail_1_1spawn__signature.html">detail::spawn_signature</a>&lt; <a class="el" href="namespaceasio.html#ae03d27556f68768ced98d0eac4a06afd">result_of_t</a>&lt; F(<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; typename ExecutionContext::executor_type &gt;)&gt;&gt;::type &gt;( declval&lt; <a class="el" href="classasio_1_1detail_1_1initiate__spawn.html">detail::initiate_spawn</a>&lt; typename ExecutionContext::executor_type &gt;&gt;(), <a class="el" href="namespaceasio.html#adff1e9f7bb336026f18afa2221c9df07">token</a>, static_cast&lt; F &amp;&amp; &gt;(function)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new stackful coroutine that executes on a given execution context. </p>
<p>This function is used to launch a new stackful coroutine.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Identifies the execution context that will run the stackful coroutine.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must be callable the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> <span class="keyword">function</span>(basic_yield_context&lt;Executor&gt; <a class="code" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">token</td><td>The completion_token that will handle the notification that the coroutine has completed. If the return type <code>R</code> of <code>function</code> is <code>void</code>, the function signature of the completion handler must be:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr); </div>
</div><!-- fragment --><p> Otherwise, the function signature of the completion handler must be: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(std::exception_ptr, R); </div>
</div><!-- fragment --><dl class="section user"><dt>Completion Signature</dt><dd><div class="fragment"><div class="line"><a class="code" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>(std::exception_ptr, R) </div>
</div><!-- fragment --> where <code>R</code> is the return type of the function object.</dd></dl>
<dl class="section user"><dt>Per-Operation Cancellation</dt><dd>The new thread of execution is created with a cancellation state that supports <code><a class="el" href="namespaceasio.html#ae02aa651224af4b25dc476fc01ce29f6aede997b0caf2ec398110d79d9eba38bb">cancellation_type::terminal</a></code> values only. To change the cancellation state, call the <a class="el" href="classasio_1_1basic__yield__context.html" title="A completion_token that represents the currently executing coroutine.">basic_yield_context</a> member function <code>reset_cancellation_state</code>. </dd></dl>

</div>
</div>
<a id="a1776aa9a745f4da041978ce17abc44ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1776aa9a745f4da041978ce17abc44ff">&#9670;&nbsp;</a></span>system_category()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceasio.html#ae434d49ea968ad09c18f44d08c98aaa4">error_category</a> &amp; asio::system_category </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error category used for the system errors produced by asio. </p>

</div>
</div>
<a id="a4a82e92df79aa8401a8bc2117d4cf900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a82e92df79aa8401a8bc2117d4cf900">&#9670;&nbsp;</a></span>transfer_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1detail_1_1transfer__all__t.html">detail::transfer_all_t</a> asio::transfer_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a completion condition function object that indicates that a read or write operation should continue until all of the data has been transferred, or until an error occurs. This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.</p>
<dl class="section user"><dt>Example</dt><dd>Reading until a buffer is full: <div class="fragment"><div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> <a class="code" href="namespaceasio_1_1detail_1_1descriptor__ops.html#ad10e658a754ff775cdcc3b3decd3c8c9">buf</a>;</div>
<div class="line"><a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line">std::size_t n = <a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">    sock, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(<a class="code" href="namespaceasio_1_1detail_1_1descriptor__ops.html#ad10e658a754ff775cdcc3b3decd3c8c9">buf</a>),</div>
<div class="line">    <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// n == 128</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassboost_1_1array_html"><div class="ttname"><a href="classboost_1_1array.html">boost::array&lt; char, 128 &gt;</a></div></div>
<div class="ttc" id="anamespaceasio_1_1detail_1_1descriptor__ops_html_ad10e658a754ff775cdcc3b3decd3c8c9"><div class="ttname"><a href="namespaceasio_1_1detail_1_1descriptor__ops.html#ad10e658a754ff775cdcc3b3decd3c8c9">asio::detail::descriptor_ops::buf</a></div><div class="ttdeci">iovec buf</div><div class="ttdef"><b>Definition:</b> descriptor_ops.hpp:83</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2b10af704afcd6c7ed7f0d3b740033ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b10af704afcd6c7ed7f0d3b740033ef">&#9670;&nbsp;</a></span>transfer_at_least()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1detail_1_1transfer__at__least__t.html">detail::transfer_at_least_t</a> asio::transfer_at_least </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>minimum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a completion condition function object that indicates that a read or write operation should continue until a minimum number of bytes has been transferred, or until an error occurs. This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.</p>
<dl class="section user"><dt>Example</dt><dd>Reading until a buffer is full or contains at least 64 bytes: <div class="fragment"><div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> <a class="code" href="namespaceasio_1_1detail_1_1descriptor__ops.html#ad10e658a754ff775cdcc3b3decd3c8c9">buf</a>;</div>
<div class="line"><a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line">std::size_t n = <a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">    sock, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(<a class="code" href="namespaceasio_1_1detail_1_1descriptor__ops.html#ad10e658a754ff775cdcc3b3decd3c8c9">buf</a>),</div>
<div class="line">    <a class="code" href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(64), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// n &gt;= 64 &amp;&amp; n &lt;= 128</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adb2ada9400d78a5df0e5f65dd2b9967e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2ada9400d78a5df0e5f65dd2b9967e">&#9670;&nbsp;</a></span>transfer_exactly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1detail_1_1transfer__exactly__t.html">detail::transfer_exactly_t</a> asio::transfer_exactly </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a completion condition function object that indicates that a read or write operation should continue until an exact number of bytes has been transferred, or until an error occurs. This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.</p>
<dl class="section user"><dt>Example</dt><dd>Reading until a buffer is full or contains exactly 64 bytes: <div class="fragment"><div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> <a class="code" href="namespaceasio_1_1detail_1_1descriptor__ops.html#ad10e658a754ff775cdcc3b3decd3c8c9">buf</a>;</div>
<div class="line"><a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> ec;</div>
<div class="line">std::size_t n = <a class="code" href="namespaceasio.html#a631b112099009564a8489b63a33e32b5">asio::read</a>(</div>
<div class="line">    sock, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(<a class="code" href="namespaceasio_1_1detail_1_1descriptor__ops.html#ad10e658a754ff775cdcc3b3decd3c8c9">buf</a>),</div>
<div class="line">    <a class="code" href="namespaceasio.html#adb2ada9400d78a5df0e5f65dd2b9967e">asio::transfer_exactly</a>(64), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// n == 64</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1810b2cc34a2ed373b761420a3d3a729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1810b2cc34a2ed373b761420a3d3a729">&#9670;&nbsp;</a></span>use_service() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service &amp; asio::use_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> will create a new instance of the service.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a0d34f8c7897fc264ad87590429a7429a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d34f8c7897fc264ad87590429a7429a">&#9670;&nbsp;</a></span>use_service() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service &amp; asio::use_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>ioc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality.">io_context</a> will create a new instance of the service.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ioc</td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality.">io_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is preserved for backwards compatibility with services that inherit from <a class="el" href="classasio_1_1io__context_1_1service.html" title="Base class for all io_context services.">io_context::service</a>. </dd></dl>

</div>
</div>
<a id="a2ac93adef3e5af6c68d5a0ce36a31ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac93adef3e5af6c68d5a0ce36a31ac6">&#9670;&nbsp;</a></span>use_service&lt; detail::io_context_impl &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceasio_1_1detail.html#a31c14df804409e01448213346a224e80">detail::io_context_impl</a>&amp; <a class="el" href="namespaceasio.html#a1810b2cc34a2ed373b761420a3d3a729">asio::use_service</a>&lt; <a class="el" href="namespaceasio_1_1detail.html#a31c14df804409e01448213346a224e80">detail::io_context_impl</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>ioc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85807d13da87adf48b62979f65f41152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85807d13da87adf48b62979f65f41152">&#9670;&nbsp;</a></span>write() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a62f08eda862b625adefbacb69a97d475"><div class="ttname"><a href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a></div><div class="ttdeci">std::size_t write(SyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec, constraint_t&lt; is_const_buffer_sequence&lt; ConstBufferSequence &gt;::value &gt;)</div><div class="ttdoc">Write a certain amount of data to a stream before returning.</div><div class="ttdef"><b>Definition:</b> write.hpp:61</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af72f7eddd7d4629ea2e2b7f5b7f355bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72f7eddd7d4629ea2e2b7f5b7f355bc">&#9670;&nbsp;</a></span>write() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, b,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa80988391fb309ee53cc557d0065550a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80988391fb309ee53cc557d0065550a">&#9670;&nbsp;</a></span>write() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a393e12e427f89cb932c6a2bd800236fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393e12e427f89cb932c6a2bd800236fb">&#9670;&nbsp;</a></span>write() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="ae86befc1c843c2b0a1dae51cb7696a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86befc1c843c2b0a1dae51cb7696a23">&#9670;&nbsp;</a></span>write() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a62f08eda862b625adefbacb69a97d475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f08eda862b625adefbacb69a97d475">&#9670;&nbsp;</a></span>write() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="a46a4f9019cc125d0290171f0c186166e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a4f9019cc125d0290171f0c186166e">&#9670;&nbsp;</a></span>write() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code" href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a0c18920cf77046e1a78823245148256e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c18920cf77046e1a78823245148256e">&#9670;&nbsp;</a></span>write() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(<a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abca810c91f23c73f89cb89b8cd45494c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca810c91f23c73f89cb89b8cd45494c">&#9670;&nbsp;</a></span>write() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a62498a9eca8616498e67c01b4b4bac58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62498a9eca8616498e67c01b4b4bac58">&#9670;&nbsp;</a></span>write() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="ac38d4fdf1fff53bd865bf20e9cd95ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38d4fdf1fff53bd865bf20e9cd95ab9">&#9670;&nbsp;</a></span>write() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5bc4d0643f807559cb1bf545c1051a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bc4d0643f807559cb1bf545c1051a9">&#9670;&nbsp;</a></span>write() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; !<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; <a class="el" href="namespaceasio.html#a1d03dfdd5dd0ffa4aaf6832eda695664">decay_t</a>&lt; DynamicBuffer_v1 &gt;&gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5eabfb4da832af9df0f85696c8022727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eabfb4da832af9df0f85696c8022727">&#9670;&nbsp;</a></span>write() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a353faf23a7bcb2c3fc3022506b292d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353faf23a7bcb2c3fc3022506b292d4a">&#9670;&nbsp;</a></span>write() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="ac3a6eb174ec37a28df640469f970b102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a6eb174ec37a28df640469f970b102">&#9670;&nbsp;</a></span>write() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af982fe40762c23e1eb4ea166b4019208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af982fe40762c23e1eb4ea166b4019208">&#9670;&nbsp;</a></span>write() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream , typename DynamicBuffer_v2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ad8f73389553384e0af82754b8491f177">constraint_t</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;::value &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a62f08eda862b625adefbacb69a97d475">asio::write</a>(</div>
<div class="line">   <a class="code" href="structasio_1_1execution_1_1detail_1_1blocking__t.html">s</a>, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1db1f75a907c17918092b41f2f242104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db1f75a907c17918092b41f2f242104">&#9670;&nbsp;</a></span>write_at() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(</div>
<div class="line">   d, 42, b,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a51133c1e260b8abeeed55646e765fdd6"><div class="ttname"><a href="namespaceasio.html#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a></div><div class="ttdeci">std::size_t write_at(SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec)</div><div class="ttdoc">Write a certain amount of data at a specified offset before returning.</div><div class="ttdef"><b>Definition:</b> write_at.hpp:65</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa6f42435acf937c35ee4c81af44ee6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f42435acf937c35ee4c81af44ee6ce">&#9670;&nbsp;</a></span>write_at() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(</div>
<div class="line">   d, 42, b,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2e23f5418309ba130d75f6757b7b8e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e23f5418309ba130d75f6757b7b8e15">&#9670;&nbsp;</a></span>write_at() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a431966af634f0701ceac7f54fc1b0371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431966af634f0701ceac7f54fc1b0371">&#9670;&nbsp;</a></span>write_at() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<a id="add67a05a29d183782491d14aceec7d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add67a05a29d183782491d14aceec7d41">&#9670;&nbsp;</a></span>write_at() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(d, 42, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(</div>
<div class="line">   d, offset, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8c1abcb5870505ea2a0c524a59638da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1abcb5870505ea2a0c524a59638da0">&#9670;&nbsp;</a></span>write_at() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(d, 42,</div>
<div class="line">   <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(</div>
<div class="line">   d, offset, buffers,</div>
<div class="line">   <a class="code" href="namespaceasio.html#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3e6b2f5dd13f4273695fbf0cdec0314a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6b2f5dd13f4273695fbf0cdec0314a">&#9670;&nbsp;</a></span>write_at() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Исключения</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceasio.html#ac5e0b6db67d52eba50e168ae78c1a049">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="namespaceasio.html#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(d, 42, <a class="code" href="namespaceasio.html#af691d016b23fd6c2da9ac91ce00c2e7e">asio::buffer</a>(data, size),</div>
<div class="line">   <a class="code" href="namespaceasio.html#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a51133c1e260b8abeeed55646e765fdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51133c1e260b8abeeed55646e765fdd6">&#9670;&nbsp;</a></span>write_at() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceasio.html#ac8914468bc40252ae5e5c666adb951cf">asio::error_code</a>&amp; error,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div>
<h2 class="groupheader">Переменные</h2>
<a id="aa80c4033469ae5aaa092c0d49852403c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80c4033469ae5aaa092c0d49852403c">&#9670;&nbsp;</a></span>a</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">awaitable&lt; <a class="el" href="bind__immediate__executor_8cpp.html#a59a5a6248bbe8018ef97e7c0490d1508">void</a>, AwaitableExecutor &gt; asio::a</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a930211f940077a2cd1fb88532f9a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a930211f940077a2cd1fb88532f9a9d">&#9670;&nbsp;</a></span>deferred</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classasio_1_1deferred__t.html">deferred_t</a> asio::deferred</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A completion_token object used to specify that an asynchronous operation should return a function object to lazily launch the operation. See the documentation for <a class="el" href="classasio_1_1deferred__t.html">asio::deferred_t</a> for a usage example. </p>

</div>
</div>
<a id="adc282e2ffff99631f6d194d893c12bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc282e2ffff99631f6d194d893c12bc0">&#9670;&nbsp;</a></span>detached</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classasio_1_1detached__t.html">detached_t</a> asio::detached</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A completion_token object used to specify that an asynchronous operation is detached. See the documentation for <a class="el" href="classasio_1_1detached__t.html">asio::detached_t</a> for a usage example. </p>

</div>
</div>
<a id="a2f8d07aef5f11fbd332259ad52db3eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8d07aef5f11fbd332259ad52db3eeb">&#9670;&nbsp;</a></span>executor_arg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structasio_1_1executor__arg__t.html">executor_arg_t</a> asio::executor_arg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A special value, similar to std::nothrow, used to disambiguate constructors that accept executor arguments. See <a class="el" href="structasio_1_1executor__arg__t.html">asio::executor_arg_t</a> and <a class="el" href="structasio_1_1uses__executor.html">asio::uses_executor</a> for more information. </p>

</div>
</div>
<a id="ac172b717c13db01d7f99af7e42edcb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac172b717c13db01d7f99af7e42edcb68">&#9670;&nbsp;</a></span>f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F &amp;&amp; asio::f</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adff1e9f7bb336026f18afa2221c9df07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff1e9f7bb336026f18afa2221c9df07">&#9670;&nbsp;</a></span>token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F CompletionToken &amp;&amp; asio::token</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
